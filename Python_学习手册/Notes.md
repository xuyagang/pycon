[TOC]

# 《Python学习手册》

本书覆盖python3.0和2.6，实例中使用3.0的print,介绍2.6语法，我的练习中使用3.0语法。

每章节和每部分后面都用练习题，解答在书的附录B中。



## 第一部分_使用入门

### 第一章_Python 如何运行

#### 1.1 为什么用python

- python注重可读性、一致性和软件质量
- 提高了效率，是c++或者Java的1/5~1/3，无需编译，可立即运行
- 可在所有主流计算机平台上快速移植代码
- 内置多种预编译并可移植模块
- 可以与应用程序的其他部分通信，是产品定制和扩展的工具

#### 1.2 python可定义为面对对象的脚本语言

- 脚本：倾向描述简单的顶层代码
  - 脚本语言可以理解为应用于快速编程任务的简单语言
- 程序：描述相对复杂的多文件应用

#### 1.3 python 的缺点

- 执行速度不够快
- python标准格式-->字节码--->解释字节码
  - 字节码是一种无关平台的格式，具有可移植性
  - 因为没有将代码编译成二进制码，python程序会比像C这样的完全编译语言慢

#### 1.4 python可以做什么？

- 从网站和游戏开发到航天飞机的控制
  - 系统编程
  - 用户图形接口
    - 内置了TKinter
  - internet脚本
  - 组件集成
  - 数据库编程
  - 数值计算和科学计算
  - 游戏、图像、人工智能、XML、机器人

#### 1.5 谁在用？

- youtube视频分享服务
- EVE Online大型多人游戏
- Maya提供了python编程API
- ...



### 第二章_python如何运行程序

- 解释器是代码与机器硬件之间的软件逻辑层
  - 解释器是_让python程序运行起来的程序_
- __.pyc__文件就是编译过的__.py__文件
  - 如果python在机器上有写入权限，程序运行后会在源码同目录下看到.pyc文件
  - 如果运行后源码未修改，下次运行直接加载.pyc文件，跳过编译步骤
  - 必须重新编译时，python会检查源文件和字节码文件的时间戳
- 程序编译为字节码后会发送到python虚拟机（PVM）
  - PVM是python的运行引擎，不是程序，无需安装，是所谓“python解释器”的最后一步

![000](D:\project\pycon\Python_学习手册\img\001.JPG)

- python语言三种主要的实现方式
  - Cpython:标准的的python实现方式
  - Jython：为了与Java集成，包含了java类
    - 让python代码能够脚本化java程序
  - IronPython：让python可以与win平台上的.NET框架和Linux上开源的Mono编写成的应用集成
- 冻结二进制文件/__Frozen Binary__
  - 用python程序生成的__独立的可执行二进制代码__
  - 简单来说就是：将python程序转为可执行程序
    - Frozen Binary 将程序的字节码，PVM以及任何程序所需要的python支持文件捆绑在一起，形成一个单独的文件包---可执行二进制程序（类似win平台的 .exe文件）
- 生成方式：
  - py2exe——win下使用
  - PyInstaller——在Linux和UNIX上使用



### 第三章_如何运行程序

- 交互提示模式运行代码

  - 在for循环和if中，用一个空行结束多行符合语句，需要按下两次Enter

- python file.py             运行file文件，在命令窗口输出结果

- python file.py > result.txt     输出结果到result.txt文件中，命令窗口不显示
  - 叫做__流重定向__(stream redirection),用于文本的输入和输出，保存起来以备查看使用
  - shell重定向方法，与python无关，只是python支持而已
    - C:\Users\Dell\Desktop>python aa.py > d:\aa.txt         （在桌面运行并输出结果到d盘）

- 模块导入和重载

  - 每一个.py文件都是 一个模块，可以导入一个模块来读取模块的内容

  - 模块通过这样的属性被外部使用

  - 大型程序有多个模块文件组成，其中一个文件设计成主文件（==顶层文件==：就是启动后运行整个程序的文件）

  - 导入工作只在第一次运行，第一次导入后，之后的导入都不会再工作，甚至改变并保存了模块源代码也不行

  - 导入开销很大，每个文件和程序运行不能重复多于一次

  - 导入必须找到文件并将其编译成字节码之后运行

  - 如果非要在同一会话（不停止和重启会话）再次运行文件，需要调用imp模块中的reload函数

    - ```python
      #  the imp module is deprecated in favour of importlib
      from imp import reload
      reload(script1)
      ```

  - reload函数希望获得的参数是一个已经加载了的模块对象名称

  - reload需要加括号，import 不需要（reload是被调用的函数，import是语句）

- 模块的属性

  - 模块是变量名的封装，被认为是命名空间，包中的变量就是所谓的属性

  - 属性就是绑定在特定对象（比如模块）上的变量名

  - 模块变量名可通过一下语句读取：

    - import
    - from
    - reload调用

  - ```python
    # 我们已有文件test.py
    	# 内容：content = ‘The Meaning of Life'
    # 方式一：grab the whole module
    import test
    test.content
    # 方式二：copy myltiple names
    from test import content
    content
    ```

  - 以上结果相同，from和import类似，from增加了对载入组件的额外赋值（content=test.content）

    - 使用from会获取文件变量的==复本==,可使用__dir()__函数查看
    - 使用import会把文件生成到一个单独的模块名称空间中，所付出的代价就是代码修改后运行需要__重载__

  - 每个模块是一个独立完备的变量包，即一个命名空间，一个模块看不到其他文件的变量名（除非显示的导入），模块在代码文件中起到了==最小化命名冲突==的作用

  - from把变量从一个文件复制到另外文件中，可能会导致相同名称的变量被覆盖（不会给出警告）

  - reload 不可传递，重载一个模块不会重载该模块导入的任何模块，因此有时需要reload多个文件

- 使用exec()运行模块文件

  - ```python
    exec(open('test.py').read())
    ```

- IDLE用户界面

  - 提供了python开发的图形界面，是使用TKinter GUI开发出来，可以在几乎任何python平台使用。

- 嵌入式调用

  - 在一些特定的领域，python代码会在一个封闭的系统中运行
  - 这样的嵌入式执行模式一般支持终端用户定制，用户可修改python代码（==python代码是解释性的，不必重新编译==）

- 总结：

  - 在系统平台终端命令行的地方运行一个脚本文件，也可通过导入、重载、exec()、IDLE的run等运行脚本



## 第二部分_类型和运算

### 第四章_python对象类型

python程序：==程序==由模块组成，==模块==包含语句，==语句==包含表达式，==表达==式建立并处理对象

#### 4.1 为什么使用内置类型

- 内置类型使程序容易编写
- 内置类型是扩展的组件
- 内置比定制的更有效率
- 内置对象是语言标准的一部分

#### 4.2 核心数据类型

- 数字
- 字符串
- 列表
- 元组
- 字典
- 集合
- 文件
- 其他：None、Bool
- 编程单元：函数、模块、类

以上并不完整，python章每样东西都是一种对象

- python中没有类型声明，运行表达式的语法决定了对象的类型，对象一旦创建就和操作集合绑定了（对字符串只可进行字符串相关操作）
  - 动态语言：自动跟踪类型而不是要求声明
  - 强类型语言：只能对一个对象进行适合该类型的语言
- 寻求帮助：
  - dir()
  - help()

___

- python核心数据名称：数字，字符串，列表，元祖，姐，字典，文件，
  - 多种数字类型：整数，浮点，复数，分数，十进制数
  - “核心”是因为他们是python语言的一部分，大多数都有特定的语法去生成他们，
- 一个具有不可变性的对象是一个__创建后不能够改变的对象__，python中的__数字、字符串和元祖__属于这个分类，尽管无法就地改变，但总可以通过运行一个表达式创建一个 新的对象
- 一个__序列__是一个_对位置进行排序的对象的集合_,字符串、列表、元祖是python中的所有的序列，他们拥有一般的序列操作（索引、切片、合并），但又有自己类型的特定方法
- __映射__表示将键和相关值相互关联的对象，字典是核心类型中唯一的映射类型。映射没有从左至右的位置顺序，支持通过键获取数据，并包含了特定的方法
- __多态__是指一个操作符（如 +）的意义取决于被操作的对象，这是python的关键思想：==不要把代码限制在特定的类型上，是代码自动适用于多种类型==



### 第五章_数字

在python中数据采用了对象的形式，无论是内置对象还是用python的工具创建的对象。

- 在python中，数字并不是一个真正的对象类型，而是__一组类似类型的分类__，数字类型完整工具包括：
  - 整数和浮点数
  - 复数
  - 固定精度的十进制
  - 有理分数
  - 集合
  - 布尔类型
  - 无穷的整数精度
  - 各种内置的函数和模块

#### 5.1 数字常量

- python提供整数（正整数和负整数）和浮点数，允许使用十六进制，八进制和二进制常量表示整数，提供复数类型，允许整数具有无穷的精度
  - 十六进制：以ox或OX开头，后接16进制数0-9，A-F
  - 八进制：0o或0O，后接0-7数
  - 二进制：0b或0B开头，后接0-1
  - 整数转为对象字符串
    - hex(int)
    - oct(int)
    - bin(int）
  - 给定进制字符串转为整数
    - int(str,base)
  - 复数
    - 复数写成实部+虚部，虚部以J或j结尾
    - 也可用内置的complex(real,imag)创建复数

#### 5.2 表达式操作符

- 表达式是处理数字的基本工具，表达式通常使用_数学符号_和_操作符_写出来

- 操作符：

  - yield x                                          生成器函数发送协议
    - 返回生成器中的send(...)参数
  - lambda  args: expression         生成匿名函数
  - x if y else z                                  三元选择表达式
  - x   or  y                                         逻辑或（只有x为假，才会计算y）
  - x   and  y                                      逻辑与（只有x为真，才会计算y)
  - not  x                                            逻辑非
  - in， not  in                                   成员关系
  - is,  is not                                       对象实体测试
  - <,<=,>,>=，==，！=                     大小比较，相等性
  - x | y                                               位或，并集
  - x ^ y                                               位异或，集合对称差
  - x & y                                              位与，交集
  - x << y , x>> y                                 左移/右移y位
  - +，-，*，/                                     加减乘除
  - x % y                                              余数/格式化
  - x // y                                               floor 除法（整除）
  - -x,+x                                                一元操作
  - ~x                                                    按位取反
  - x**y                                                幂运算
  - x[i]                                                  索引
  - x[i:j:k]                                             分片
    - 等同于 x[slice(I,J,K)]
  - x(...)                                                 调用函数、方法、其他可调用类型
  - x.attr                                               属性引用
  - （...）                                              元组，表达式，生成器表达式
  - [...]                                                   列表，列表解析
  - {...}                                                   字典、集合、集合和字典解析

- 操作符优先级

  - 上表中越靠后的优先级越高
  - 比较运算和表达式通常从左到右组合，幂运算是从右到左组合
  - 如果用用括号对表达式的各部分进行分组，就可以忽略优先级的事情了
    - 使用括号划分子表达式的时候，python总是会先计算括号中的表达式，然后将结果用于整个表达式中
  - 混合类型自动升级
    - 表达式中能混合数字类型（整数和浮点数相加）
    - 混合类型中，python首先==将操作对象转换为其中最复杂的操作对象类型==，然后运算
    - python中：整数比浮点数简单，浮点数比复数简单
    - 混合操作类型仅仅在数字类型混合到一个表达式中适用

- 变量和基本表达式

  - 变量在第一次赋值时创建
  - 变量在表达式中使用将会被替换为它的值
  - 变量在表达式中使用前必须已赋值
  - 变量不需要预先声明，但要赋值一次

- 数字显示的格式

  - 由于浮点数的硬件限制，无法准确显示一些值

  - ```python
    num = 1/3
    '%e' % num		# string formatting expression
    >>> 3.333333e-01
    '%4.2f' %num
    >>> 0.33
    '0:4.2f'.format(num)
    >>> 0.33
    ```

  - str 和repr 的显示格式

    - 默认的交互模式回显和打印的区别相当于repr和str函数的区别
      - repr:产生的结果看起来像代码（__额外细节__）
      - str:用户友好模式(__一般用途__)
        - 除了为任意对象打印字符串，str内置函数也是字符串类型的名字

- 比较

  - 一般的和连续的

  - 除了正常的大小值比较，python允许我们把多个比较连续起来执行==范围测试==

    - 例：

    - ```python
      # 测试B是否在A和C之间
      A < B < C			
      # 等同于
      A < B and B < C
      
      # 第一个简单便于使用，并且B值计算一次，速度要快一些
      ```

- 除法：

  - x/y	真除法

  - x//y       整除法（floor）

    - 截断除法：真正结果之下的最近整数

  - ```python
    >>> 10//4
    2
    >>> 10//4.0
    2.0
    # 操作数中有一个是浮点数，结果就是浮点数，否则结果是整数
    ```

- 整数精度

  - python3支持整数的无穷大小，实际中，长整数的运算比正常整数慢，以性能换精度

- 复数

  - 表示为两个浮点数（实部和虚部）并在虚部增加了J/j的后缀
  - 复数允许我们分解它的是实部和虚部作为属性
  - 可通过标准的cmath模块处理

- 十六进制/八进制/二进制

  - oct()

  - hex()

  - bin()

  - int(str,base)     将数字的字符串变换为整数

  - eval()                 将字符串作为python代码

    - ```python
      eval('0b1000000')
      eval('0x40')
      ```

    - 

  - ```python
    # 字符串格式化方法调用和表达式将一个整数转为八、十六、二进制
    '{0:o},{1:x},{2:b}'.format(64,64,64)
    ```

- 位操作

  ```
  x = 1
  x << 2
  # 表达式中二进制数1（0001）左移了两位（0100）成为4
  ```

  - python支持C语言中大多数数学表达式
    - 包括把整数当作二进制位串的操作
    - 二进制与 &
    - 二进制或 |

- 其他内置数学工具

  - pow
  - abs
  - math 模块
    - math.pi
    - math.e
    - sin、sqrt、pow、abs、min、floor、trunc、round、
      - 求解sqrt
        - math.sqrt
        - 144**0.5
        - pow(144,0.5)
  - random模块

- 其他数字类型

  ---

  - 小数数字
    - 浮点数学缺乏精确性，因为用来存储数值的空间有限
    - 与硬件相关的浮点数运算在精度方面有内在缺陷

  - decimal 模块

  - 设置全局精度

    - ```python
      import decimal
      decimal.getcontext().prec = 4
      ```

  - 小数上下文管理

    - 使用上下文管理语句来设置临时精度,语句退出后恢复初始值

      - ```python
        import decimal
        with decimal.localcontext() as ctx:
        	ctx.prec = 2
            # expression
        ```

---

- 分数

  - python引入了数字类型——分数，实现了一个有理数对象，避免了浮点数的不精确性和局限性

  - 分数是小数的近亲，都可以通过固定小数位和指定舍入或截断来控制精度

  - fractions模块

  - ```python
    from fractions import Fraction
    x = Fraction(1,3)
    print(x)    # Fraction(1,3)
    ```

    - 一旦创建了分数，就可以用于数学表达式

    - 也可以从小数来创建分数

    - ```python
      Fraction('025')
      ```

  - 数值精度

    - 分数和小数提供了精确的结果，付出了速度的代价

    - 分数和小数能提供比浮点数直观准确的结果

      - 分数保持精确性，并自动简化结果

        - ```python
          from fractions import Fraction
          >>> Fraction(6/12)
          Fraction(1, 2)
          ```

  - 转换和混合类型

    - 浮点数有一个方法，能够产生他们的分子分母比

    - 分数有一个from_float方法，并且接受一个Fraction作为参数

      - ```
        >>> (2.5).as_integer_ratio()
        (5, 2)
        ```


#### 5.3 集合

- set : 唯一的、不可变的对象的无序集合，一个项只能出现一次

- 可迭代的，可增长和缩短，能包含各种对象类型

- 既不是序列也不是映射类型

- python 中{}是一个字典，空的集合必须由set来创建

- 集合只能包含不可变的（可散列的）对象

  - 列表和字典不能嵌入到集合中
  - 需要存储符合值的话，元祖是可以嵌入的
  - 集合本身是可变的，不能嵌入到其他集合中

- 需要在另外一个集合中存储一个集合，可以调用frozenset,它创建一个不可变的集合，不可修改且可嵌入其他集合

- 集合解析

  - ```python
    {x**2 for x in [1,2,3,4]}
    # 循环在右边，集合表达式在左边
    ```

- 为什么使用集合

  - 集合中项只能存在一次，可用来去重（转换为set,在转换回来）

    - ```
      L = [1,2,3,1,2,4,5]
      L = list(set(L))
      ```

  - 在遍历或循环结构中可用来记录已经访问过的位置

  - 集合的交集包含了共有对象，并集包含所有项目

- 布尔型

  - bool原本是一个数字，有True和False，不过是整数1和0以不同形式显示后的定制版而已

  - True和False的行为与1和0 的是一样的，有特定的显示逻辑

  - 可将True和False看作预定义的设置为1和0的变量

    - True是定制了显示格式的整数1

    

### 第六章_动态类型简介

动态类型的多态性是其语言简洁灵活的基础

- python中类型是在运行过程中自动决定的，而不是通过代码声明

- 变量、对象、引用

  - 变量创建：给一个变量赋值，之后的赋值会改变已经创建变量名的值（__最初的赋值创建变量__）
  - 变量类型：类型的概念存在与对象中而不是变量名中，变量是通用的，只是在特定的时间点引用了特定的对象而已
  - 变量使用
    - 变量出现在表达式中，马上会被替换成其引用的对象
    - 变量必须在使用前明确的赋值，使用未赋值的变量会产生错误

  ==变量在赋值的时候创建，可以引用任何类型对象，必须在引用前赋值==

```
a = 3
# 1.创建一个对象来代表3
# 2.创建一个变量a,如果还没创建的话
# 3.将变量与对象3相连接
```

- 运行a=3后，变量a变成对象3的引用，事实上在内部==变量是到内存空间的一个指针==

- 总结

  - 变量是一个系统表的元素，拥有指向对象的连接空间
  - 对象是分配的一块内存，有足够的空间表示所代表的值
  - 引用是自动形成的从变量到对象的指针

- 对象的垃圾回收

  ```
  a = 3
  a = 'spam'
  # 给a第二次赋值时，对象3发生了什么变化
  ```

  - 每当一个变量名被赋予一个新的对象，之前那个对象占用的空间会被回收（如果它没有被其他变量名或对象引用的话）---这种自动回收对象空间的技术叫垃圾收集
  - 在内部，python为每个对象保持了一个计数器，用于记录当前指向该对象的引用的数目，一旦这个计数器被设置为0，这个对象的内存空间就会自动回收

- 共享引用

  ```python
  a = 3
  b = a
  # 运行b=a后，b成为对象3的一个引用
  ```

  ![001](D:\project\pycon\Python_学习手册\img\000.JPG)
  ```
  a = 3
  b = a
  a = 'spam'
  # b仍然引用原始的对象 3
  ```

  ![002](D:\project\pycon\Python_学习手册\img\002.JPG)
  ==给一个变量赋一个新的值，并不是替换了原始的对象，而是让变量引用不同的对象==

- 共享引用和原处修改

  - 有些对象操作会在原处改变对象，而不是生成一个新的对象

  - 对于这种支持原处修改的对象，共享引用时需小心（__因为对一个变量名的修改会影响其他变量__）

    - ```
      L1 = [1,2,3]
      L2 = L1
      # L1和L2都引用了相同的对象
      L1[0] = 11
      >>>L2 = [11,2,3]
      # 改变了L1引用对象的一个元素，修改会覆盖列表
      ```

  - 如果==不想原处修改==，需要python的拷贝对象

    - 内置列表函数和copy模块

      - 列表从头到尾的切片

      - ```
        L1 = [2,3,4]
        L2 = L1[:]
        # L1的修改不会影响L2
        ```

        - L2引用的是L1的拷贝，两个变量指向了不同的对象（内存区域）
        - 分片技术不会应用到集合和字典，他们不是序列

      - 复制一个字典和集合应使用X.copy()

        - copy模块有一个通用的复制任意对象的调用

        - 也有一个拷贝嵌套对象结构的调用

          - ```
            import copy
            x = copy.copy()
            x = copy.deepcopy()
            ```

- 共享引用和相等

  - ==：测试两个被引用的对象是否有相同的值

  - is : 检查对象的同一性

    - 事实上is只是比较引用的指针（也等价与是代码检测共享的一种方式）

    ```python
    L = [1,2,3]
    M = [1,2,3]
    a = '123'
    b = '123'
    i = 123
    j = 123
    
    print(L==M,a==b,i==j)
    >>>True True True
    print(L is M,a is b, i is j)
    >>False True True
    ```

    - ==因为小的整数和字符串被复用了，所以is告诉我们a is b 和 i is j 是True(是相同的对象)==

  - 查询对象的引用次数

    - 在sys模块中的getrefcount函数会返回对象的引用次数

      ```
      import sys
      sys.getrefcount(1)
      # 绝大多数idle系统代码所使用
      >>> 2035
      ```

      

### 第七章_字符串

字符串为不可变序列，意味着字符串所包含的字符存在从左至右的位置顺序，不可以再原处修改

![003](D:\project\pycon\Python_学习手册\img\003.JPG)

- 字符串常量

  - 单引号：'spam'
  - 双引号：'spa'm'
  - 三引号：'''...spam...''',"""...spam..."""
  - 转义字符：“s\tp\na\0m”
  - Raw字符串：r"c:\new\test.spm"
  - Byte字符串：b'sp\x01am'

- python自动再任意的表达式中合并相邻的字符串常量

  ```python 
  title = "Meaning" 'of' "Life"
  tiele
  >>>'Meaningoflife'
  ```

- 用转义序列代表特殊字节

  - 反斜杠用来引入特殊的字节编码，是转义序列

  - 交互模式下是以转义字符的形式回显，但print会将其解释出来

  - len()可用来了解字符串中__有多少个字节__

  - 转义字符

    ```
    \newline 				忽视（连续）
    \\						反斜杠本身
    \'						单引号
    \"						双引号
    \a						响铃
    \b						倒退
    \f						换页
    \n						换行
    \r						返回
    \t						水平制表符
    \v						垂直制表符
    \xhh					十六进制
    \ooo					八进制
    \0						Null(不是字符串结尾)
    \other					不转义（保留）
    ```

    - python没有一个字符会结束一个字符串

    - python以十六进制显示非打印字符

      ```
      s = '\001\002\x03'
      s
      >>>'\x01\x02\x03'
      ```

    - 如果python没有作为一个合法的转义编码识别出\后的字符，他就直接保留反斜杠

      ```
      s = '\dd\n\cc'
      s
      >>> '\\dd\n\\cc'
      ```

- raw字符串抑制转义

  - 转义用来处理再字符串中嵌入特殊字节码，有时候引入转义字符而使用的反斜杠会引来一些麻烦

    - 如`my_file= open('c:\new\text.dat','w')`,\n和\t会导致错误

  - 方法一：raw字符串用来解决此问题

    - 大写或小写（r\R）出现在字符串的第一个引号前面，就会关闭转义机制

  - 方法二：两个反斜杠是一个反斜杠的转义序列

    - `my_file = open('c:\\new\\text.dat','w')`

  - 当打印嵌入反斜杠的字符串时候，python自己也会使用转义斜杠的方法(交互模式下)

    ```
    a = r'c:\new\text.dat'
    print(repr(a))
    print(a)
    >>>'c:\\new\\text.dat'
    >>> c:\new\text.dat
    ```

  - window下使用__斜杠__表示字符串路径

  - raw字符串不能以单个的反斜杠结尾，因为反斜杠会转义后续引用的字符

    - `r'...\'`不是一个有效的字符常量
    - 一个raw字符串不能以奇数个反斜杠结尾，如果需要单个的反斜杠结束一个rawz字符串
      - 使用两个反斜杠并分片掉最后一个反斜杠    `r'1\nb\tc\\'[:-1]`
      - 手动添加反斜杠   `r'1\nb\tc'+'\\'`
      - 使用常规的字符转义 `'1\\nb\\tc\\'`

- 三重引号编写多行字符串块
  - 到目前已经学习了单引号、双引号、转义字符、raw字符，python还提供了一种三引号的块字符串
  - 用于输入多行文本
  - 常用于文档字符串
  - 用于注释代码

- 字符串应用

  - \+ 号合并字符串

    - 不允许混用字符和数字

      ```
      'abc'+9
      # 会出错
      ```

      

  - \* 号重复字符串

    - 打印包含80个横线的一行

      ````
      print('-'*80)
      ````

  - for循环迭代字符串

  - in对字符串和子字符串进行成员关系测试

  - 索引和分片

    - 从左到右0为第一个元素，从右到左是 -1为第一个元素
    - s[:-1]  不包括最后一个元素
    - s[:] 所有元素（顶层拷贝）

  - 扩展分片（步长）

    - X[I:J:k]

      - 前两个参数默认值为零,步长K默认为1

    - 可以用负数作为步进

    - k = -1是反转

    - 分片等同于用一个分片对象进行索引

      ```python
      'spam'[1:3]
      # 等同于
      'spam'[slice(1,3)]
      
      print('spam'[::-1])
      # 等价于
      print('spam'[slice(None,None,-1)])
      ```

  - 字符串转换工具

    - int() 将字符串转换为数字
    - repr() 将对象转换为其字符串形式
    - str()转换为字符串

  - 字符串代码转换

    - ord()  将单个字符转换为ascii码（字符再内存中的二进制）

    - chr()  将ascii转换为对应的字符

      - 基于字符串的数学运算

        ```
        num = '9'
        chr(ord(s)+10)
        >>> 19
        ```

  - 字符串方法

    ![008](D:\project\pycon\web scrapy\img\008.PNG)

    ![009](D:\project\pycon\web scrapy\img\009.PNG)

  - 字符串方法实例

    - find()方法返回 字符串出现处的索引，__未找到时返回-1__

    - replace

      - 每次返回一个新的字符串

      - 如果不得对一个超长字符串进行许多的修改，为了优化脚本性能，需要将字符串转换为一个支持原处修改的对象

        ```
        # 可用list函数将其转换为列表，然后进行修改
        # 之后用字符串的join方法将列表合并成一个字符
        ```

    - split

      - 默认空格为分隔符，将字符串分割为多个子字符串（分隔符不会出现在子字符串中）

    - % 格式化

      - 格式化总是返回新的字符串，而不是对左侧的字符串修改

      ```
      'that is %d %s bird' % (1,'big')
      ```

      - 更高级的格式化

        ![004](D:\project\pycon\Python_学习手册\img\004.JPG)

        - `%[(name)][flags][width][.precision]typecode`

          ```python
          x = 1234
          # 默认格式化、6位左对齐、6位补零
          res = 'integers:...%d...%-6d...%06d' %(x,x,x)
          ```

        - 如果在运行时才知道大小，可以在字符串中使用*来指定通过计算得出width和precision

          ```python
          # * 位需要传入整数
          '%f, %.2f, %.*f' % (1/3.0 ,1/3.0, 4, 1/3.0)
          >>> '0.333333,0.33,0.3333'
          ```

      - 基于字典的格式化

        - `"%(n)d %(s)s" % {'n':1,'s':'spam'}`

          

### 第八章_列表字典

都可以在原处修改，也可以增长或缩短，可以包含任何种类的对象

#### 列表

有序集合对象类型，可以包含任何种类的对象，是 可变对象

1. 任意对象的有序集合

2. 通过偏移读取

3. 可变长度、异构、任意嵌套
   1. 异构：可以包含任何类型的对象而不仅仅是包含有单个字符的字符串
4. 可变序列分类
5. 索引、切片、合并

help(list) 或 dir(list) 查看list的方法

- 常用操作

  ![005](D:\project\pycon\Python_学习手册\img\005.JPG)
  - l.insert(i,item)

  - l.index(item)   只返回第一次出现位置

  - l.sort()

  - l.reverse()

  - del l[k]

  - l.pop()   最后一个

  - l.remove(item)    第一个

  - l[i] = j   分片赋值

  - ```
    list(map(ord,'spam'))
    >>>[115, 112, 97, 109]
    ```

  - l = [x**2 for x in range(5)]

#### 实际应用中的列表

- 基本操作

  - \+  合并操作
  - \* 重复操作

- 列表解析和迭代

  - 成员操作
    - `3 in [1, 2, 3]`
  - 迭代
    - `for i in [1,2,3]:`
  - 列表解析
    - res = [c*4 for c in 'spam']

- 索引、分片、矩阵

- 原处修改

  - 原处修改一个 对象时，可能会影响其他指向它的引用

  - 对索引和分片赋值

    - 用一个新值取代指向索引的引用

  - 分片理解

    1. 先删除
    2. 再插入

    ```python
    L = [1,2,3]
    L[1:2] = [4,5]
    L
    >>>[1, 4, 5, 3]
    L[1:2] = []
    L
    >>>[1, 5, 3]
    ```

    - 当分片重叠时`L[2:5]=L[3:6]`是可行的，这是因为要被插入的值会再左侧删除前取出

- 方法调用

  ==方法是特定类型的工具==

  - append:将一个__单项__加至末端，允许传入单一对象

    - L.append(x) 与 L + [X] 结果类似，但后者会生成新的列表

  - `sort(self, /, *, key=None, reverse=False)`

    - 使用标准的python比较检验（字符串比较）递增排序
    - key是针对传入的每个元素生成一个排序id然后排序

  - reversed内置函数，必须包含在list中调用

    ```
    L = [1,2,3,4]
    list(reversed(L))
    >>>[4, 3, 2, 1]
    ```

#### 字典

除了列表外，字典是python中最灵活的内置数据结构类型，列表是有序的对象集合，字典是无序的集合

1. 通过键而不是索引读取
2. 任意对象的无序集合
3. 可变长、异构、任意嵌套
4. 可变映射类型
   1. 字典是唯一内置的映射类型
5. 对象引用表
   1. 字典存储的是对象引用

##### 常用操作

![006](D:\project\pycon\Python_学习手册\img\006.JPG)

​			![007](D:\project\pycon\Python_学习手册\img\007.JPG)

- 对字典赋值（不存在的键）会生成一个新的元素
- 当键不存在时，get能返回默认值（None或者自定义值），这是__为了避免missing_key__错误
- update:把一个字典的值合并到另外一个字典，盲目的覆盖相同的键
- dict.setdefault()   添加默认值，存在就返回,不存在就添加
- dict.popitem()    随机删除键值对
- dict.copy()   浅复制

> 对任何字典而言，写成`for key in D ` 和完整的`for key in D.keys()`效果是一样的
>
> 迭代器允许in成员关系操作符用于字典的另一个实例

- 注意事项

  - 序列运算无效，字典是映射机制，不是序列
  - 对新索引赋值会添加项
  - 键不一定总是字符串，任何不可变对象都可以

  ```
  D = {}
  D[99] = 'spam'
  >>> {99:'spam'}
  ```

  - 字典用于稀疏数据结构

    ```
    matrix = {}
    matrix[(2,3,4)] = 88
    matrix[(7,8,9)] = 99
    >>>{(2,3,4):88,(7,8,9):99}
    ```

  - 避免missing-key错误

    读取不存在的键的错误很常见，常用避免方法:if语句中预先测试，try语句明确的捕获并修复，get方法为不存的键提供默认值

    ```python
    # 方法一：
    if (2,3,6) in Matrix:
        print(Matrix[(2,3,6)])
    else:
        print(0)
    # 方法二：
    try:
        print(Matrix[(2,3,6)])
    except KeyError:
        print(0)
    # 方法三：
    Matrix.get((2,3,6),0)
    ```

  - 创建字典的方法

    ```python
    # traditional
    {'name':'mel','age':45}
    # 键赋值
    D= {}
    D['name'] = 'mel'
    # 键值对
    dict(name = 'mel', age=45)
    # 键值元祖
    dict([('name','mel'),('age',40)])
    ```

- 字典解析

  ```python
  list(zip(['a','b','c'],[1,2,3]))
  D = dict(zip(['a','b','c'],[1,2,3]))
  # 字典解析表达式
  D = {key:value for key,value in zip(['a','b','c'],[1,2,3])}
  
  # 其他例子
  D = {c:c*4 for c in 'spam'}
  >>>{'s':'ssss','p':'pppp','a':'aaaa','m':'mmmm'}
  
  # 初始化字典
      # 一般方法
      D = dict.fromkeys(['a','b','c'],0)
      # 字典解析
      D = {i:0 for i in ['a','b','c']}
  ```

- 字典视图

  - python3中keys、values、items返回视图对象，保持了字典成分的最初顺序

    ```
    D = dict(a=1,b=2,c=3)
    k = D.keys()
    k
    >>>dict_keys(['a', 'b', 'c'])
    ```

  - 字典有自己的迭代器

    ```python
    for key in D:
        print(key)
    ```

- 字典视图和几何

  > keys方法返回的对象类似与集合，支持交集并集等集合操作，values视图不是这样的，因为他们不是唯一的，items的对象也是的，如果（key,value）对是唯一并且可散列的话

  ```python
  D = dict(a=1,b=2,c=3)
  k = D.keys()
  # keys and dict
  k | {'x':3}
  >>>{'a', 'b', 'c', 'x'}
  # keys and set
  k & {'b'}
  >>>{'b'}
  # items and set
  D.items() & {('b', 2)}
  >>>{('b', 2)}
  ```

- 排序字典键

  - keys不会返回列表，必须手动转换为列表或使用sorted函数

    ```python
    D = dict(a=1,b=2,c=3)
    k = D.keys()
    a = list(k)
    a.sort(reverse=True)
    a
    >>>['c', 'b', 'a']
    
    k = D.keys()
    # sorted 把keys对象直接生成列表
    sorted(k,reverse=True)
    >>>['c', 'b', 'a']
    ```

- in 成员测试

  - 使用in或者get方法

    ```python
    D = dict(a=1,b=2,c=3)
    'c' in D
    >>>True
    
    D.get('c','None')
    >>>3
    ```

### 第九章_元祖、文件及其他

#### 元祖

>  元祖与列表相似，不能在原位修改

- 任意对象的有序集合
- 通过偏移存取
  - 支持分片和索引
- 不可变序列类型
- 固定长度、异构、任意嵌套
- 对象引用数组

> 生成一个元祖，将元素用逗号隔开，用圆括号括起来，空括号就是空元祖

- 常见元祖及运算

​	（）					    空元祖

​	T = （0，）				单个元素的元祖

​	T = （0，‘NI’，1.2，3）	   四个元素

​	T = 0，‘NI’，1.2，3		   与前列相同

​	T = （‘abc',('def','ghi')）	   嵌套元祖

​	T = tuple('spam')			可迭代对象

​	T[i]

​	T[i]\[j\]

​	T[i:j]

​	len(T)

​	T1 + T2				合并、重复

​	T * 3	

​	for i in T :

​	    print(i)

​	'spam' in T			 成员关系

​	[x ** 2 for x in T ]	

​	T.index('NI')			搜索

​	T.count('Ni')			计数

- 实际应用

  ```python
  a = (5)		# an integer
  a = (5,)	# a tuple	
  # 多个元素时，没有括号也能识别出元祖
  ```

- 转换、方法及不可变性

  - \+ 、 \* 及分片操作会返回新的元组

  - 对元组排序需要将其转换为列表（可变对象），或者使用sorted方法，它接受任何序列

    - 元组使用sorted排序后返回列表

    ```python
    a = 21,14,3
    b = sorted(a)
    print(b,type(b))
    >>>[3, 14, 21] <class 'list'>
    ```

  - 列表解析可用于元组转换

  - 列表解析可用在某些并非实际存储的序列上，任何遍历对象都可以（包括逐行读取的文件）

  - 元组方法index、count

    ```
    T = (1,2,3,2,4,2)
    T.index(2,2)
    >>>3
    T.index(2)
    >>>1
    T.count(2)
    >>>3
    
    ```

  - 元组的不可变性只适用于元组顶层，而非其内容，内部的列表可以修改

- 为什么需要元组

  元组的不可变性提供了完整性，可以保证在程序中不会被另一个引用修改

- 文件

  - open函数会创建一个python对象

  - 操作方法

    - output = open(r'c:\spam', 'w')

    - input = open('data', 'r')

    - input = open('data')                                        r 是默认

    - aString = input.read()                                     把整个文件读入字符串

    - aString = input.read(N)                                  读取之后的N个字节

    - aString = input.readline()                              读取下一行（包括行末标识符）

    - aList = input.readlines()                                  读取整个文件到字符串列表

    - output.write(aString)                                      写入字节字符串到文件

    - output.writelines(alist)                                   把列表中的所有字符串写入文件

    - output.close()                                                   手动关闭

    - output.flush()                                                    把输出缓冲区刷到硬盘中，但不关闭文件

    - anyFile.seek(N)                                                 修改指针位置到偏移量N处，以便进行下一个操作

    - for line in open('data'):

      ​        use line

- 使用文件

  > Python 中的文本文件都采用字符串的形式，读取文件会返回字符串形式的文本

  - 文件迭代器是最好的读取行工具
  - 内容是字符串，不是对象
    - 从文件读取的数据回到脚本是字符串，需要将其转换为python对象以便使用
  - close是通常选项
    - 当文件对象被回收的时候，如果需要的话，python也会自动关闭该文件
  - 文件时缓冲的并且时可查找的
    - 关闭一个文件或者运行flush方法，迫使缓存的数据进入硬盘

- 实际使用

  - 文件迭代器

    ```python
    for line in open('myfile'):
        print(line,end='')
    ```

  - 使用 line.rstrip() 来移除行的终止符

    - lien[:-1] 也可以

  - 使用eval()可以把字符串转换为对象

- 用pickle存储python的原生对象

  > 能在文件存储python对象，并不需要把字符串转来转去，就像超级通用的数据格式化和解析工具

  ```python
  # 存储字典
  import pickle
  D = {'a': 1, 'b': 2}
  f = open(r'.\datafile.pkl','wb')
  pickle.dump(D,f)
  f.close()
  
  # 读取原生数据
  f = open(r'.\datafile.pkl','rb')
  d = pickle.load(f)
  print(d)
  ```

- 文件中打包二进制数据的存储与解析

  > 有些高级应用中需要处理打包的二进制数据，struct模块能够构造并解析打包的二进制数据

  - pickle用于把python对象储存在文件中，而不用可以转为字符串，struct需要把数据打包为二进制格式,之后保存在文件中

- 文件上下文管理器

  > with允许我们把文件处理代码包装到一个逻辑层中，以确保在退出后可以自动关闭文件，而不依赖垃圾回收的自动关闭

  ```python
  with open(r'c:\data.txt') as myfile:
      for line in myfile:
          # use line
          
  # 等价于
  myfile = open(r'c:\data.txt')
  try:
      for line in myfile:
          # use line
  finally:
      myfile.close()
  ```

- sys、os

- 重访类型分类

  - 对象根据分类来共享操作

  - 只有可变对象可以原处修改，不能修改数字，字符串或元组

  - 集合类似于一个无值的字典键，但是不能映射为值，并且没有顺序，集合不是映射类型或者序列类型，frozenset是集合的不可变版本

  - 分类：

    ![008](D:\project\pycon\Python_学习手册\img\008.JPG)

-  引用VS拷贝

  > 赋值操作总是存储对象的引用，而不是拷贝
  >
  > 赋值操作会产生相同对象的多个引用，在原处修改会影响其他地方对相同对象的引用

  ```python
  X = [1,2,3]
  L = ['a',X,'b']
  D = {'x':X,'y':2}
  X[1] = 'surprise'
  print(L)
  print(D)
  >>>'a', [1, 'surprise', 3], 'b']
  {'x': [1, 'surprise', 3], 'y': 2}
  ```

  - 当确实需要拷贝时，可以明确要求

    - 没有限制的分片表达式（L[:]）能复制序列
    - 字典的copy方法（X.copy()）嫩复制字典
    - 内置函数list,`list(L)` 能生成拷贝
    - copy标准库模块能生成完整拷贝

    > 分片表达式 和 字典的copy方法只能做到顶层复制，不能复制嵌套的数据结构

    - 深层拷贝需要引入copy模块

      ```
      import copy
      # 可完成对任意嵌套对象的完整复制
      x = copy.deepcopy(Y)
      ```

- 比较、相等性和真值

  ```python
  # 两列表虽然相等，但却时不同的对象
  X = [1,2,3]
  Y = [1,2,3]
  print(X == Y,X is Y)
  >>> True False
  ```

  - 相等性

    - '==' 操作符测试值的相等性（递归的比较所有内嵌对象）

    - 'is'  测试对象的一致性 （测试是否为同一对象，也就是是否为同一个内存地址）

      ```python
      a = 'adam'
      b = 'adam'
      print(a==b,a is b)
      >>> True True
      
      # 为了得到更一般的结果我们使用长字符串
      a = 'adam love hh'
      b = 'adam love hh'
      print(a==b,a is b)
      >>> True False
      ```

    - 对于字符串，python 在内部==暂时存储并重复使用段字符串作为最佳化==，字符串较短时，字符串共享内存，

    - ‘==’几乎是所有等值检验会用的操作符， 而 is 则保留了极为特殊的角色

    - 大小比较也能递归的应用于嵌套的数据结构

    - 不同类型比较方法：

      - 数字比较相对大小
      - 字符串安装字典顺序，一个字符接一个字符比较
      - 列表和元组从左到右对每部分比较
      - 字典通过排序后的（键：值）进行比较（3.0不支持）
      - 数字混合类型比较是错误的

    - python3.0的字典比较

      > 当期望相等的时候会导致很多负担

      - 编写循环来比较键值

      - 手动比较排序的（键：值）列表

        - items字典方法
        - 内置的sorted

        ```python
        D1 = {'a':1,'b':2}
        D2 = {'a':1,'b':3}
        D1 == D2
        >>> True
        D1 < D2
        >>> TypeError: '<' not supported between instances of 'dict' and 'dict'
        sorted(D1.items()) < sorted(D2.items())
        >>> True
        ```

    - 真假的含义

      > 真和假时python对象的固有属性，==每个对象不是真就是假==

      - 数字如果非零，则为真
      - 其他对象如果非空，则为真

      > 对象真值的例子

      - ‘spam'      True
      - ''                True
      - []               False
      - {}               False
      - 1                True
      - 0.0             False
      - None         False

      > None 对象

      - None总被认为是假，这是python中一种特殊数据类型的唯一值，是函数的默认返回值
      - None不是未定义，None是某些内容——是一个真正的对象，并且有一块内存

      > boo类型

      - bool扩展了真假的概念，True和False是1和0的定制版本而已
      - bool()函数用来测试一个对象的布尔值

- Python类型层次

  > python系统中的任何东西都是对象类型，可以由python程序来处理

  - type对象

    > 即使是类型本身在python 中也是对象

    - type(x) 返回对象的类型对象

    - 任何对象的类型都是类型为’type‘的对象

    - 按类别组织的python的内置对象类型

      ![009](D:\project\pycon\Python_学习手册\img\009.JPG)

- python中的其他类型

  > 正则表达式、DBM文件、GUI组件、网络套接字等
  >
  > > 这些附带工具和内置类型的区别：内置类型有针对他们的对象的特殊语言生成语法，而在内置模块中使用其他工具则必须先导入才能使用

  - 赋值生成引用而不是拷贝

  - 重复能够增加层次深度

  - 留意循环数据结构

    ```
    a = ['abc']
    a.append(a)
    >>>['abc', [...]]
    ```

    python在对象中检测到循环，都会打印称为 [...] ,而不会陷入无限循环

  - 不可变类型不可在原处改变

  

## 第三部分_语法和语句_

### _第十章_python语句简介

==程序由模块构成，模块由语句构成，语句包含表达式，表达式建立并处理对象==

#### python语句

- python语句集：

| 语句                           | 角色       | 例子                        |
| ------------------------------ | ---------- | --------------------------- |
| 赋值                           | 创建引用值 | a,b,c = 'good','bad','ugly' |
| 调用                           | 执行函数   | log.write('spam')           |
| 打印调用                       | 打印对象   | print('The killer')         |
| if  /  elif  /  else           | 选择动作   | if ’python' in text:        |
| for   /   else                 | 序列循环   |                             |
| while   /   else               | 一般循环   |                             |
| pass                           | 空占位符   |                             |
| break                          | 循环退出   |                             |
| continue                       | 循环继续   |                             |
| def                            | 函数和方法 |                             |
| return                         | 函数结果   |                             |
| yield                          | 生成器函数 |                             |
| global                         | 命名空间   |                             |
| nonlocal                       | 命名空间   |                             |
| import                         | 模块访问   |                             |
| from                           | 属性访问   |                             |
| class                          | 创建对象   |                             |
| try   /   except   /   finally | 捕捉异常   |                             |
| raise                          | 触发异常   |                             |
| assert                         | 调试检查   |                             |
| with   /   as                  | 环境管理器 |                             |
| del                            | 删除引用   |                             |

- 冒号，首行以冒号结尾，下一行嵌套的代码需要缩进

- 括号是可选的

  ```python
  if (x<y):
      pass
  if x<y:
      pass
  ```

- 终止行就是终止语句

- 缩进的结束就是代码块的结束

  - 所谓缩进是指两个嵌套语句至左侧空白的所有空白，python不在乎你怎么缩进，你可以使用任意多个空格或者制表符

- 缩进使得代码统一、整齐并具有可读性，具备了重用性和维护性

- 特殊实例：

  - 语句一般时一行一个，但python也有可能出现某一行挤进多个语句的情况，这时由分号隔开

    ```python
    a = 1；b = 2;print(a+b)
    ```

    - 这是python唯一需要分号的地方——作为语句界定符，放在一起的语句不是 复合语句才行，只能把简单的句子放在一起，例如赋值操作、打印、函数调用

  - ==括号（（）），方括号（[]）,大括号({})==可以让一个语句的范围横跨多行,任何括在符号里的程序代码可以横跨几行

    ```python
    # 连续列表常量
    mlist = [111，
            222，
            333]
    ```

    - 大括号处理字典，圆括号处理元组、函数调用、表达式

    - 连续行的缩进是无所谓的

    - 括号是可以包含一切的（适用复合语句）

      ```python
      if(A == 1 and
        B == 2 and
        C == 3):
          print('spam'*3)
          
      X = (A + B +
          C + D)
      ```

    - 一条老规则允许跨行——当上一行以反斜线结束时，可以在下一行继续(不提倡)

      ```python
      X = A + B +\
          + C + D
      ```

  - 代码块规则特殊实例

    > 嵌套代码块的语句一般都与向右缩进的量有关

    - 特殊实例

      > 复合语句的主体可以出现在python的首行冒号之后
      >
      > - 只有简单的语句可以跟在冒号之后：赋值、打印、函数调用等
      > - 复合语句的附带部分必须放在自己的行里（例如if的else部分，使用逗号分开）

      ```
      if x > y: print(x)
      ```

- 简单实例

  ```python
  # 简单的交互循环
  while True:
      reply = input('Enter text:')
      if reply == 'stop': break
      print(reply.upper())
      
  # python 会执行首次测试为真所匹配的代码块
  while True:
      reply = input('enter text:')
      if reply == 'stop':
          break
      elif not reply.isdigit():
          print('bad' * 8)
      else:
          print(int(reply) * 2)
  print('Bye')
  ```

  - python 会先执行try
    - 如果有异常发生就执行except部分
    - 如果没有异常发生就执行else部分
  - 多层嵌套



### 第十一章_赋值、表达式和打印

#### 赋值语句

- 赋值语句建立对象引用值
- 变量名在首次赋值时会被创建
- 变量名在引用前必须先赋值
  - 使用尚未赋值的变量会引发异常
- 执行隐式赋值的操作
  - 模块导入、函数和类的定义、for循环变量、函数参数（在运行时将把变量名和对象引用值绑定起来）

#### 赋值语句形式

- spam = 'spam'                             基本形式

- spam,ham = 'yum','YUM'           元组赋值运算

- [spam,ham] = ['yum','YUM']      列表赋值运算

- a,b,c,d = 'spam'                            序列赋值

- a,*b = 'spam'                                序列解包

- spam = ham = 'lunch'                 多目标赋值

- spams += 11                                增强赋值运算

  

- 高级赋值

  ```python
  ((a,b),c) = ('sp','am')
  a,b,c
  >>>('s','p','am)
  
  # 循环赋值
  for (a,b,c) in [(1,2,3),(4,5,6)]:
      pass
      
  # 序列解包赋值语句(赋值一系列整数给一组变量)
  red,green,blue = range(3)
  
  L= [1,2,3,4]
  while L:
      front,L = L[0],L[1:]
      print(front,L)
  >>>1 [2, 3, 4]
  2 [3, 4]
  3 [4]
  4 []
  ```

- 扩展序列解包

  > 一个带有单个星号的名称，可以在赋值目标中使用，以指定对于序列的一个更为通用的匹配

  > 序列赋值通常要求左边的目标名称数目与右边主体的项数对应，长度不同，将会报错

  > 我们可以在目标中使用带单个星号的名称来更通用的匹配
  >
  > - 不管星号出现在哪里，包含该位置的每个未赋值元素列表都会赋给它

  ```python
  # 正确操作
  a,b,c,d = [1,2,3,4]
  # 错误操作
  a,b = [1,2,3,4]
  # 星号操作
  a,*b = [1,2,3,4]
  ```

- 边界情况

  - 带星号的名称可能只匹配带个项，但总时赋值一个列表

  - 如果没有内容匹配带星号的名称，会赋值一个空列表

  - 有多个带星号的名称、值少了而没有带星号的名称、带星号的名称没有编写到列表中 都会报错

    ```
    # 错误用法
    a,*b,c,*d = [1,2,3,4]
    a,b = [1,2,3,4]
    *a = sep
    # 正确用法
    *a, = [1,2,3,4]
    ```

    ==*a，= [1,2,3,4]== 生成一个列表，等价于`a = [1,2,3,4]`

- for循环

  ```python
  for (a,*b,c) in [(1,2,3,4),(5,6,7,8)]:
      pass
  ```

- 多目标赋值语句

  ```
  a = b = c = 'spam'
  ```

  - 多目标赋值和共享引用

    > 一个对象由多个变量共享，

    ```
    # 修改b只会对b修改，数字不支持原处修改
    a = b = 0
    b = b + 1
    a,b
    >>>(0,1)
    # 当把变量初始值设为可变对象时,由于引用相同对象，两个变量都会改变
    a = b = []
    b.append(1)
    a,b
    >>>([1],[1])
    ```

- 增强赋值语句

  - x += y
  - x -= y
  - x *= y
  - x /= y
  - x %= y
  - x $= y
  - x ^= y
  - x <<= y
  - x >>= y
  - x **= y
  - x //= y
  - x |= y

  > 优势：
  >
  > - 输入减少
  >
  > - x可以是复杂对象表达式，增强形式中，则只需==计算一次==（x = x + y中，x出现两次，必须执行两次），增强赋值执行更快
  >
  > - 优化技术自动选择，对于支持原处修改的对象而言，增强赋值会自动执行原处修改，而不是相比慢速的复制
  >
  > - 使用增强语句来扩展列表，python会自动调用较快的extend而不是较慢的  + 操作
  >
  >   ```
  >   L += [9,10]     # mapped to L.extend([9.10])
  >   ```

- 增强赋值及共享引用

  > - += 对列表是原处修改
  >
  > - \+ 对列表生成新对象
  >
  >   ```
  >   # + 操作，生成新对象
  >   L = [1,2]
  >   M = L
  >   L = L + [3,4]
  >   L,M
  >   >>>([1, 2, 3, 4], [1, 2])
  >   # +=对列表是原处修改
  >   L = [1,2]
  >   M = L
  >   L += [3,4]
  >   L,M
  >   >>>([1, 2, 3, 4], [1, 2, 3, 4])
  >   ```

  - 这种对于列表和字典这类可变对象才重要

- 变量命名规则

  > python中，为变量名赋值时，变量名就会存在，程序选择变量名时，要遵循如下规则：
  >
  > - 语法：下划线或字母 +任意数据的字母、数字、下划线
  >   - 变量名必须以==下划线或字母开头==，后面接任意数目==字母、数字或下划线==
  >   - 区分大小写
  >   - 禁止使用保留字

  - python保留字

    ```
    False、class、finally、is、return、None、continue、for、lambda、try、True、def、from、nonlocal、while、and、del、global、not、with、as、elif、if、or、yield、assert、else、import、pass、break、except、in、raise
    ```

  - import 语句中的模块变量名会变成脚本中的变量，这种限制也会扩展到模块的文件名

    > 你可以写and.py 和 my-code.py这类文件，但是你无法将其导入
    >
    > - 保留字是禁区
    > - 破折号不行

    ```
    improt my-code.py
      File "<stdin>", line 1
        import my-coce
                 ^
    SyntaxError: invalid syntax
    ```

- 命名惯例

  > 非必要规则，一般都会遵守

  - 以单一下划线开头的变量名（_X）不会被from module import * 导入
  - 前后由下划线的变量名（\_X\_）是系统定义的变量名，对解释器有特殊意义
  - 以两个下划线开头（__X）
  - 通过交互模式与运行时，只有单个下划线的变量名（_）会保存最后表达式的结果
  - 类变量名通常以一个大写字母开头，模块变量名以小写字母开头

- 变量名没有类型，但对象有

#### 表达式语句

> 表达式的结果不会存储

- spam(eggs, ham)       函数调用
- spam.ham(eggs)        方法调用
- spam                           交互模式打印变量
- print(a,b,c)                  打印
- yield x**2                   产生表达式语句

#### 表达式语句和原处修改

```
L = [1,2]
L.append(3)
L
>>>[1,2,3]
L = L.append(3)
L
>>>None
```

- 对列表调用append,sort,reverse 这类原处修改的运算，使用这些方法修改后不会把列表返回，事实上返回None对象
- 如果赋值这类运算的结果给该变量的变量名，只会丢失该列表（可能被当成垃圾回收）

#### 打印操作

- print是对程序员友好的标准输出接口

- python3中，打印是一个函数

  - print(obj,sep='',end='',file=sys.stdout)

  - file指定了文本将要发送的文件，标准流或者其他类似的文件对象

    - 带有一个类似文件的write(string)方法的任何对象都可传递，但真正的文件应该已经为输出而打开

    ```python
    # C:\Users\Dell\Desktop>python
    print('hello',file=open('test.txt','w'))
    # 输出 hello 的txt文件到桌面
    ```

#### 打印流重定向

> 打印都默认的发送到标准输出流，发送到其他地方也是有用的，例如文本文件，可以保存结果，供以后测试使用
>
> - 重定向也可以在shell中实现

```python
print('hello world')           # python3
print 'hello world'            # python2.6
```

- print 语句是python 人性化的特性，提供 sys.stdout的接口

- 使用sys.stdout

  ```python
  import sys
  sys.stdout.write('hello world\n')
  ```

- 重定向输出流

  - print和stdout的关系

    ```python
    print(x,y) 
    # 等价于
    import sys
    sys.stdout.write(str(x)+''+str(y)+'\n')
    
    # 这里强调打印的友好性
    ```

  - 这种等效的方式提供了一种方法，让print语句将文字传送到其他地方

    ```python
    import sys
    sys.stdout = open('log.txt','a')
    print('hello world')
    ```

    - 这里我们把sys.stdout重设为打开的文件（采用附加模式），程序中的任何打印都会写至文件末尾
    - 可以将sys.stdout设为非文件对象，只要对象有预期的write协议

- 自动化流重定向

  - sys.stdout是一个普通的文件对象，你可以存储它，需要时恢复

    ```python
    import sys
    temp = sys.stdout
    print(temp)
    >>> <_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>
    sys.stdout = open('log.txt','a')
    print('haha')
    sys.stdout = temp
    print('haha')
    >>>haha
    ```

    - python3中，file关键字允许一个单个的print调用将文本发送到文件的write方法，这种重定向是暂时的

      

### 第十二章_if测试和语法规则

- if语句用于选取要执行的操作，python中主要的选择工具

- 后面跟着多个可选的elif以及一个最终可选的else

- python会执行第一个结果为真的代码块，或者所有的测试为假，就执行else块

  ```python
  if test:
      <statements1>
  elif test2:
      <statements2>
  else:
      <statements3>
  ```

语法规则：

- 语句是逐个运行的
- 块和语句的边界会自动检测
- 复合语句=首行+“：”+缩进语句
- 空白行、空格以及注释都会忽略
- 文档字符串会忽略，但会保存并由工具显示
  - docstring,和#注释不同，文档字符串会在运行时保留下来以便查看，

代码块分隔符：

- 自动以缩进检测块的边界，快内的语句会垂直对齐，遇到缩进量少的行退出

语句分隔符：

- 使用语法括号对，语句就可以横跨数行——（）[] {} 这类配对中

- 语句以反斜线结束，可以横跨数行

  > 比较过时的功能，如果需要横跨数行，就在前一行末尾加上反斜线  \

- 三重引号可以横跨多行

- 可以用分号终止语句：这种惯例有时用于把一个简单的语句挤进单个行中

- 注释可以出现在任意地方

特殊情况：

```python
# 括号让行保持连续
L = ['good',
    'bad',
    'ugly']
# \
if a == b and c == d and \
    d == e and e == f:
        pass
# 括号
if (a == b and c == d and 
   d == e and e == f):
    pass

```

- 同一行编写多个非复合语句，以分号隔开

  ```
  x = 1; y = 2; print(x)
  ```

- 三重引号

  ```python
  s = '''
  aaaa
  bbbb
  cccc'''
  # 相邻的字符串常量时隐式的连接起来的
  s = ('aaaa'
      'bbbb'
      'cccc')
  ```

- 真值测试

  - 任何非零数字和非空对象都为真

  - 数字零、空对象以及特殊对象None都被认为是假

  - 比较和相等测试会递归的应用在数据结构中

  - 比较和相等测试会返回True或False(0\1的特殊版本)

  - 布尔and \or会返回真或假的操作对象

    - and
    - or
    - not

    > 比较会返回True\False作为结果
    >
    > and \or 返回对象（每个对象本质上不是真就是假）

    > 对于or测试，python从左至右求算，返回第一个为真的对象（python会在其找到第一个真值操作数的地方停止——短路计算）

    ```python
    2 or 3, 3 or 2
    >>>(2,3)
    [] or 3
    >>> 3
    # 左边的为假，python只会计算右边的数并将其返回（可能为真或假）
    [] or {}
    >>>{}
    ```

  - 在结果知道时，and也会停止,从左至右计算，停在第一个为假的对象上

    ```
    []  and {}
    >>>[]
    2 and 3
    >>> 3
    3 and 2
    >>>2
    ```

if /else 三元表达式

```python
if X:
    A = Y
else:
    A = Z

# 等价于
A = Y if X else Z

# bool函数会把X转换为对应的0或1
A = [Y,Z][bool(X)]
```



### 第十三章_while和for循环

> while 提供了编写通用循环的一种方法，for语句用来遍历序列对象内的元素
>
> break、Continue
>
> 常用内置函数range、zip、map
>
> 重复操作的主要语法:while、for、迭代、列表解析
>
> 奇特迭代工具：生成器、filter、reduce

- while 循环

  > 只要顶端测试一直为真，就会重复执行一个语句块，控制权会持续返回到语句的开头部分，直到测试为假，控制权会传给while块后的语句

  ```python
  while test:
      <statements1>
  else:
      <statements2>
  ```

  - break、continue、pass、else

    > 只有嵌套在循环中才起作用，break和continue
    >
    > else和break关联在一起
    >
    > pass空占位语句

    - break:跳出最近循环（整个循环语句）
    - continue：跳到最近循环的开头，来到循环的首行
    - pass:空占位语句
    - else块：只有当循环正常离开时才会执行（也就是没碰到break语句）

  - 一般循环格式

    ```
    while test1:
        <statements1>               
        if test2:break              # exit loop now,skip else
        if test3:continue           # go to top of loop now,to test
    else:
        <statements2>               # run if we didn't hit a 'break'
    ```

    - pass

      > 语法需要语句还没有任何实用的语句时就用pass

      ```
      while Ture : pass
      def fun():
          pass
      ```

      - python 3允许使用 ... (三个连续点来省略代码)，可以当作是pass的一种替代方案

        ```:
        def fun(): ...
        
        def fun():
            ...
        
        # 省略号可以和语句出现在同一行，可以用来初始化变量名
        a = ...
        >>> a
        Ellipsis
        ```

    - continue

      > 语句会立即跳到循环的顶端

    - break

      > 语句会立刻离开循环，位于其后的循环代码都不会执行

    - 循环else

      > 如果==主体从没有执行过，else分句会执行==，while循环中，如果首行的测试一开始就为假，就会 出现这种问题

      ```
      a = 1
      while a> 10:
          if a  == 9:
              print(a)
              break
          a += 1
      else:
          print('a')
      >a
      ```

- for 循环

  - for循环中的元组赋值

    > 如果迭代元组序列，循环目标本身可以是元组，这是元组解包的赋值运算

    ```
    T = [(1,2), (3, 4), (5, 6)]
    for (a,b) in T:
        print(a,b)
    ```

  - for循环中的元组使得用items方法来遍历字典中的键和值和方便

    ```
    D = {'a': 1, 'b': 2, 'c': 3}
    for key in D:
        print(key, '==>', D[key])
    
    for (key, value) in D.items():
        print(key, '==>', value)
    
    # for 之后的任何赋值目标在语法上都是有效的
    for both in T:
        a,b = both
        print(a,b)
    
    for ((a, b), c) in [((1, 2), 3),((4, 5), 6)]:
        print(a,b,c)
    ```

  - python3在for循环中扩展的序列赋值

    - 一个序列可以赋值给一组更为通用的名称（一个带有星号的名称收集多个元素），我们可以在for循环中使用同样的语法提取嵌套的序列

      ```
      for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
          print(a, b, c)
      >1 [2, 3] 4
       5 [6, 7] 8
      ```

  - 文件扫描

    - 文件包含了很多字符和行，是循环常见的案例，要把文件中的内容一次加载至字符串可以用ｒｅａｄ

      

  - 编写循环技巧

    - for比while容易写，执行快速
    - python提供了两个内置函数，在循环内定制迭代
      - range返回一系列连续增加的数，可以作为for中的索引
      - 内置==zip==函数返回并行元素的==元组的列表==，可用于在for中遍历数个序列

  - 循环计数器whlie和range

    - python3中==range是一个迭代器==，我们需要将其包含到一个list调用中以一次性的显示其结果

      ```
      list(range(5))
      >[0, 1, 2, 3, 4]
      ```

  - 修改列表

    ```python
    L = [1,2,3,4,5]
    for x in L:
        x += 1
    # 运行后得到 
    L
    >[1,2,3,4,5]
    x
    >6
    
    # 这样并不行，因为修改的是循环变量x,而不是列表L
    
    # 要在遍历的时候修改列表，我们需要索引，让我们在遍历时替每一个位置赋一个已更新的值，range和len组合可以替我们产生所需要的索引
    L = [1,2,3,4,5]
    for i in range(len(L)):
        L[i] += 1
    L
    > [2,3,4,5,6]
    # for i in L 这种循环会遍历实际的元素，而不是列表的位置
    
    # 等效的while循环
    i = 0
    while i < len(L):
        L[i] += 1
        i += 1
    L
    >[3,4,5,6,7]
    
    # 列表解析也能做类似的工作，但对最初的列表没有进行原处修改
    [x + 1 for x in L]
    ```

  - 并行遍历：zip 和 map

    > zip:会取得一个或多个序列为参数，然会元组的列表（将序列中并排的元素配对）
    >
    > - zip是一个可迭代对象，包含在list中调用会一次性显示所有结果

    ```
    l1 = [1,2,3,4]
    l2 = [5,6,7,8]
    zip(l1, l2)
    ><zip at 0x1f0112655c8>
    list(zip(l1, l2))
    >  [(1, 5), (2, 6), (3, 7), (4, 8)]
    ```

    - zip可以接受任何类型的序列（可迭代对象，包括文件）可以有多个参数，

      ```python
      a,b,c = (1,2,3),(4,5,6),(7,8,9)
      list(zip(a,b,c))
      >[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
      ```

      - 长度不同时，zip会以==最短==序列的长度为准类截断所得的元组

    > map: 会带一个函数，以及一个或多个序列参数，然后用从序列中取得的元素调用函数并收集结果

    - 使用zip构造字典

      ```python
      keys = ['spam', 'eggs', 'toast']
      vals = [1, 3, 5]
      list(zip(keys, vals))
      >[('spam', 1), ('eggs', 3), ('toast', 5)]
      D = {}
      for k,v in zip(keys, vals): D[k] = v
      D
      >  {'spam': 1, 'eggs': 3, 'toast': 5}
      ```

  - 索引和元素：enumerate

    > 有些程序中我们需要索引和元素，这是一个简单的for循环

    ```python
    S = 'spam'
    offset = 0
    for i in S：
       print(i, offset)
       offset += 1
    ```

    - 有一个新的内置函数，可以为我们做这件事

    ```
    S = 'spam'
    for (index, item) in enumerate(S):
        print(index,item)
    >0 s
    1 p
    2 a
    3 m
    ```

    - enumerate函数返回一个生成器对象，这个对象有一个\_\_next\_\_的方法，每次迭代它会返回一个（index, value）的元组，我们可以在for循环中通过元组赋值运算将元组解包

      - 我们一般不会看其作用机制，因为迭代环境（包括列表解析）会自动执行迭代协议

        ```
        [c * i for (i,c) in enumerate(S)]
        ```


- 总结：

  探索了python 的循环语法，深入学习while和for循环，学习其else分句.也研究了break和continue,他们只有在循环中才有意义，介绍了几个在for循环中常用的内置工具，包括range、zip、map、enumerate.下一章将介绍迭代器的概念，



### 第十四章_迭代器和解析（第一部分）

#### 迭代器：初探

python中for循环、列表解析、in成员测试、以及map内置函数等都可用于可迭代对象

- 可迭代对象，是序列观念的通用化，包括实际序列和按照需求而计算的虚拟序列

#### 文件迭代器

文件对象有个readline的方法，可以一次从一个文件中读取一行，到达文件末尾时，会返回空字符串，我们通过它来检测并跳出循环

```
f = open('test.txt')
f.readline()
f.readline()
```

还有另外一个方法，名为\_\_next\_\_,每次调用会返回下一行，唯一的区别，==\_\_next\_\_会引发内置的stopIteration异常，==而不是返回空字符串

- 可迭代的——指的是支持iter的对象
- 迭代器——指的是iter返回的一个支持next的对象

这个接口就是 python中的迭代协议：有\_\_next\_\_方法的对象会前进得到下一个结果，而在末尾时，会引发Stop Iteration。**python中，任何这类对象都是可迭代的**

- 任何这类对象也能以for循环或其他迭代工具遍历，因为迭代工具内部工作起来都是在每次迭代中调用\_\_next\_\_,并且捕捉到StopIteration异常来确定何时离开

  - 逐行读取文本最佳的方式就是不去读取，让for循环每轮自动调用next而自动到下一行

    ```python
    for line in open('test.txt'):
        print(line.strip(),end='')
    # 相同效果的原始方式
    for line in open('test.txt').readlines():
        print(line.strip(), end='')
    ```

  - readlines不是最好的方式，它是把整个文件一次性加载到内存，如果文件太大会导致计算机内存空间不够，甚至不能工作

  - while循环逐行读取文件

    ```python
    f = open('test.txt')
    while True:
        line = f.readline()
        if not line: break
        print(line.upper(), end='')
    ```

    尽管这样，比起迭代器for循环版本，这可能运行的更慢一些，因为迭代器在==python中是C语言的速度==运行的，而==while循环则是通过python虚拟机运行==python字节码

#### 手动迭代：iter和next

内置函数next,会自动调用对象的\_\_next\_\_方法，`next(X)`等价于`X.__next__()` ,前者简单很多

- for循环开始时，会 通过它传给iter内置函数，从**可迭代对象**中获得一个**迭代器**

自动和手动迭代之间的对等性：

```python
# 自动迭代
L = [1, 2, 3]
for i in L:
    print(i ** 2, end=' ')
    
# 手动迭代
L = [1, 2, 3]
I = iter(L)
while True:
    try:
        i = next(I)
    except StopIteration:
        break
    print(i ** 2, end = ' ')
```

#### 其他内置类型的迭代器

- 遍历字典键的方法是明确的获取键的列表

  ```python
  D = {'a':1, 'b':2, 'c':3}
  for key in D:
      print(key, D[key])
  > a 1
  b 2
  c 3
  ```

  - 我们不需要调用keys方法来遍历字典键——for循环将使用迭代协议在每次迭代的时候获取一个键

- 迭代协议让我们必须把某些结果包装到一个list调用中一次性看到他们的值：

  ```python
  list(range(5))
  >[0, 1, 2, 3, 4]
  
  # enumerate的工作方式
  E = enumerate('spam')
  I = iter(E)
  next(I)
  > (0, 's')
  list(enumerate('spam'))
  >[(0, 's'), (1, 'p'), (2, 'a'), (3, 'm')]
  ```

#### 列表解析基础知识

列表解析写在一个方括号中，最终构建了一个新的列表

```
# 等价实现
res = []
for x in L:
    res.append(x + 10)
```

列表解析在技术上并非必要，但编写起来更简单，比直接编写for循环运行的更快（快一倍），因为他们的迭代在解释器内部是以C语言的速度执行，而不是以手动python代码实现，特别是对于较大的数据集合，这是使用列表解析的一个主要性能优点

#### 文件上使用列表解析

文件对象的readlines方法，能一次性的==把文件载入到行字符串的一个列表中==

列表解析像for循环是个迭代环境，我们甚至不必提前打开文件，如果我们在表达式中打开，列表解析将自动调用文件的next方法，

```
lines = [line.rstrip() for line in open('script.py')]
```

表达式做了很多隐式的工作，扫描文件自动构建列表

- 高效，速度快

#### 扩展的列表解析

表达式中嵌套的for循环可以有一个相关的if子句

```python
lines = [line.rstrip() for lien in open('script.py') if line[0] == 'p']

# for的等价实现
res = []
for line in open('script.py'):
    if line[0] == 'p':
        res.append(line.rstrip())
```

- for的形式实现复杂，运行慢

列表解析可以变得更复杂，可以包含嵌套的循环，可被编写为一系列的for子句

```python
# 构建一个x+y连接的列表，把一个字符串中的每个x和另外一个字符串中的每个y连接起来
[x + y for x in 'abc' for y in 'lmn']
> ['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
```

#### 其他迭代环境

> 后面我们将会看到用户定义的类也可以实现迭代协议

可对对象从左到右扫描的工具都实现了迭代协议，包括for循环，列表解析，in成员关系测试，map,sorted,zip

- map：把一个函数调用应用于传入的可迭代对象的每一项，可用于列表解析，但有局限性，因为它需要传入一个函数而不是一个表达式，返回一个可迭代对象，必须使用list来查看所有的值
- sorted==排序==可迭代对象中的项
  - 和其他不同的是，sorted返回一个列表而不是可迭代对象
- zip==组合==可迭代的对象中的项
- enumerate根据相对位置来配对可迭代的对象中的项
- filter选择一个函数为真的项
- reduce针对可迭代的对象中==成对的项==运行一个函数

其他内置函数也支持可迭代协议，但很难用在和文件相关的实例中，可以接受任何可迭代对象作为一个参数，并使用迭代协议扫描，但==返回单个结果==：

- sum计算对象总和
- any和 all分布返回True或False
- max和min分别返回最大最小值（也可以 作用于文件，选择具有最高和最低字符串值的行）

python内置工具集中，list,tuple,join都将一个打开的文件上工作，并且自动一次读一行

```
list(open('script.py'))
tuple(open('script.py'))
'$$'.join(open('script.py'))
```

函数调用中有一个特殊的*arg形式，它会把一个集合的值解包为单个的参数，他也会接受任何可迭代对象，包括文件

- zip可用来unzip 已经zip过的元组

  ```python
  a = (1, 2)
  b = (3, 4)
  list(zip(a,b))
  >[(1, 3), (2, 4)]
  
  x,y = zip(*zip(a,b))
  x
  >(1, 2)
  y
  > (3, 4)
  ```

#### python3中新的可迭代对象

像zip这样的函数返回可迭代对象，根据需求产生结果，交互环境中需要额外的录入才能看到结果，但对大型程序来说，这样延迟计算会节约内存并避免暂停

- range

  > range返回一个迭代器，如果需要显示结果，必须使用list()来强制生成一个真正的范围列表

- map、zip、filter迭代器

  > 和range类似，将结果转变成迭代器以节约内存空间，而不是在内存中一次性生成一个结果列表，和range不同的是，他们都是自己的迭代器——在遍历结果一次后就用尽了

  ```python
  M = map(abs,(-1, 0, 1))
  M
  ><map at 0x1f01141c320>
  next(M)
  > 1
   for i in M:
       print(i)
  ```

#### 多个迭代器VS单个迭代器

> range迭代器，支持索引，不是自己的迭代器，支持结果有多个迭代器，这些迭代器会记住他们的位置

```python
R = range(3)
next(R)
> 'range' object is not an iterator
I1 = iter(R)
next(I1)
>  0
I2 = iter(R)
next(I2)
>  0
next(I1)
>  1
```

相反zip,map,filter 不支持相同结果上的多个活跃迭代器

```python
Z = zip((1,2,4),(10,11,12))
I1 = iter(Z)
I2 = iter(Z)
next(I1)
>(1, 10)
next(I1)
>(2, 11)
next(I2)
>(4, 12)
I1 ==  I2
>True
```

```
M = map(abs,(-1, 0, 1))
I1 = iter(M); I2 = iter(M)
I1 == I2
>True
next(I1)
> 1
next(I2)
> 0
next(I1)
> 1
```

可以用类来编写自己的可迭代对象，通过iter调用返回一个新的对象来支持多个迭代器，单个迭代器一般意味着一个对象返回其本身，生成器函数和表达式的行为就像map和zip一样，支持单个的活跃迭代器

#### 字典试图迭代器

> 字典的keys,values,items方法返回可迭代的试图对象，他们一次产生一个结果项，而不是在内存中一次产生7全部结果列表

```python
D = dict(a = 1, b =2, c =3)
D
>{'a': 1, 'b': 2, 'c': 3}
k = D.keys()
k
> dict_keys(['a', 'b', 'c'])
# 键的视图不是可迭代对象
next(k)         
> 'dict_keys' object is not an iterator
# 转换为可迭代对象
I = iter(K) 
```

```python
for k,v in D.items(): print(k,v,end=' ')
> a 1 b 2 c 3
```

- python字典有自己的迭代器，它返回连续的键，无需调用keys

  ```python
  I = iter(D)
  next(I)
  > 'a'
  next(I)
  > 'b'
  
  for k in D: print(k,end = ' ')
  > a b c
  
  D = dict(a = 1, c =3, b =2)
  D
  >{'a': 1, 'c': 3, 'b': 2}
  for k in sorted(D.keys()):print(k,D[k],end=' ')
  >a 1 b 2 c 3
  # 等价方式
  for k in sorted(D):print(k,D[k],end=' ')
  >a 1 b 2 c 3
  ```

#### 其他迭代器主题

-  yield语句：用户定义的函数，可以转换为可迭代的生成器函数
- 当编写在圆括号中的时候，列表解析可以变为生成器表达式
- 用户定义的类，通过\_\_iter\_\_和\_\_getitem\_\_运算符重载变得可迭代



### 第十五章_文档

文档涉及python的语法模型，也是想了解python工具集的读者的资源

#### python文档资源

> 内置工具信息
>
> 文档字符串——docstring
>
> PyDos系统

| 形式                    | 角色                       |
| ----------------------- | -------------------------- |
| \# 注释                 | 文件中的文档               |
| dir函数                 | 对象中可用属性的列表       |
| 文档字符串：\_\_doc\_\_ | 附加在对象上的文件中的文档 |
| PyDoc: help(函数)       | 对象的交互帮助             |
| PyDoc: HTML报表         | 浏览器中的模块文档         |
| 标准手册                | 正式的语言和库的说明       |
| 网站资源                | 在线教材，例子             |
| 出版的书籍              | 商业参考书籍               |

#### # 注释

井号注释是最基本的方式，python会忽略#之后的所有文字（只要井号不是位于字符串常量中），这类注释只能从源代码中看到，要编写能更广泛使用的注释，请使用文档字符串

文档字符串适用于大型功能的文档，#注释适用于较小功能的文档

#### dir函数

抓取对象内可用属性列表的方式（例如对象的方法和简单是数据项）

可用来查看内置对象类型提供了哪些属性，可运行dir并传入所需要类型的常量

```
dir([])
dir('')
# 也可将类型的名称传给dir
dir(str) == dir('')
dir(list) == dir([])
```

- 可作为记忆提醒器，提供属性名称的列表，但并没有告诉你名称的意义

#### 文档字符串：\_\_doc\_\_

python 支持可自动附加在对象上的文档，在运行时可保存查看

从语法上来说，这类注释时写成字符串，放在模块文件、函数以及类语句的顶端，就在任何可执行程序代码前（#注释在其前也没关系），python会自动封装这个字符串，也就是所谓的文档字符串，使其成为相应对象的\_\_doc\_\_属性

#### 用户定义的文档字符串

考虑下面的文件——docstring.py

```python
"""
Module documentation
Words Go Here
"""

spam = 40

def square(x):
    """
    function documentation
    can we have your liver then?
    """
    return x**2              # square

class Employee:
    'class documentation'
    pass
print(square(4))
print(square.__doc__)
```

文档协议的重点在于，注释会保留在_\_doc\_\_属性中以供查看（文件导入后）

因此要显示模块以及其打算关联的文档字符串，我们只需导入这个文件，打印其_\_doc\_\_属性

```python
import docstring
print(docstring.__doc__)
print(docstring.square.__doc__)
print(docstring.Employee.__doc__)

>Module documentation
Words Go Here


    function documentation
    can we have your liver then?
    
class documentation
```

- 要取出模块中类的方法函数字符串，可访问`module.class.method.__doc__`

#### 文档字符串标准

该有什么内容，并没有标准，有些公司有内部标准，现已经有各种标记语言和模板协议(例如HTML，XML)

目前文档字符串没有标准，想用就别犹豫

#### 内置文档字符串

python中内置模块和对象都使用该技术，在dir返回的属性列表前后加上文档

要查看内置模块的可读说明时，可将其导入，并打印其\_\_doc\_\_字符串

内置模块内的函数、类、方法在其\_\_doc\_\_属性内也有附加的说明信息

```
import sys
print(sys.__doc__)

# 也可用于读取内置函数的说明
print(int.__doc__)
```

这种方式可以查看内置工具的大量信息，但不必这样做，help函数会自动做这件事

#### PyDoc：help函数

有很多的方式可启用PyDoc,包括命令行脚本选项，最主要的PyDoc接口是内置的help函数和PyDoc GUI/HTML接口。help函数会启用PyDoc从而产生简单的文字报表

- help() 期待有个对象的引用值传入，对于较大对象，help显示会分为几段
  - class、function、data、file等
- help也能用在模块上

#### 常见编写代码的陷阱

- if\while\for复合语句末尾要加冒号

- 从第一行开始，确定顶层程序从代码第一行开始，包括在模块文件中输入的无嵌套的代码

- 空百行在交互模式提示符下很重要，空白行用来结束语句

- 缩进要一致

- 不要在python中写C代码

- 使用简单的for而不是while和range,for总是容易写并且运行起来更快

- 注意赋值语句中的可变对象

- 不要期待在原处修改对象的函数会返回结果,调用时不要对其结果赋值，

  - list.append()

  - list.sort()

    ```python
    # 结果把列表指定为None
    mylist = mylist.append(x)
    ```

- 一定要使用括号调用函数

- 不要在导入和重载中使用扩展名或路径,因为模块可能有.py以外的其他后缀（如 .pyc）

  ```
  # 在import语句中省略目录路径和文件字尾
  # 导入mod.py
  import mod
  ```

  

## 第四部分_函数

### 第十六章_函数基础

一个函数就是将一些语句集合在一起的部件，能够不止一次的在程序中运行，函数还能计算出一个返回值，能够改变作为函数输入的参数

函数是在编程过程中剪剪贴贴的替代——我们不再有一个操作代码的冗余副本，而是将代码包含到一个单独的函数，大大减少了以后的工作

==函数是python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构==

- 函数相关的表达式
  - calls    myfun(args)
  - def
  - return
  - global
  - nonlocal
  - yield
  - lambda

#### 为何使用函数

- 最大化代码重用和最小化代码冗余

  便于多次使用和维护

- 流程的分解

  将一个系统分割为不同部分

> 函数基本概念、作用域、参数传递、生成器、函数式工具、多态

#### 编写函数

- def是可执行代码——函数并不存在，直到python运行了def后才存在
  - 在if语句、while循环、甚至是其他的def中嵌套是合法的
  - 典型操作中，def语句在模块文件中编写，并自然而然的在模块文件第一次导入的时候生成定义的函数
- def创建了一个对象并将其赋值给某一变量
- lambda创建一个对象但将其作为结果返回
- return将一个结果对象发送给调用者
- yield向调用者发回一个结果对象，但记住它离开的地方
  - 生成器函数通过yield语句返回值，并挂起他们的状态以便稍后能够恢复状态
- global声明了一个模块级别的变量并被赋值
  - 默认情况下在一个函数中被赋值的对象，是函数的本地变量，仅在函数运行过程中存在
  - 为了分配一个可以在整个模块中都可以使用的变量名，函数需要在global语句将它列举出来
  - 变量名需要关注它的作用域（变量存储的地方），并且是通过实现赋值语句将其绑定至作用域的
- nonlocal声明了将要赋值的一个封闭的函数变量
- 函数通过赋值传递
- 参数，返回值以及变量并不是声明
  - 可以传递任意类型的参数，也可以返回任意类型的对象

##### def语句

```python
def name(args):
    ...
    return value
```

return可出现在任何地方，return是可选的，如果没有出现，函数将在控制流执行完成后结束

没有返回值的函数自动返回了None,这个值往往被忽略

##### def语句是实时执行的

def语句运行时创建一个新的函数对象，并将其赋值给一个变量名

def可出现在任何语句可出现的地方，甚至嵌套在其他语句

def在运行时才进行评估，在def之中的代码在函数调用后才会评估

```python
if test:
    def func():
        ...
else:
    def func():
        ...
```

```python
def func(): ...   # create function object
func()            # call object
func.attr = value # attach attributes
```

##### 调用

通过在函数名后加括号调用（运行）这个函数

##### 多态

有时函数的意义取决于输入的参数类型，* 可以执行乘法，也可以执行字符串赋值，它针对被处理的对象做了随机应变——这种依赖类型的行为称为多态（操作的意义取决于被操作的对象的类型）

python是动态语言，多态随处可见

如果传给函数的对象有预期的方法和表达式操作符，他们对于函数的逻辑来说有着即插即用的兼容性

多态的编程模型意味着必须测试 代码取检测错误，而不是 采用编辑器用来检测类型错误的类型声明，以初步测试为代价，减少了我们必须编写的代码

```python
def intersect(seq1, seq2):
    res = []
    for x in seq1:
        if x in seq2:
            res.append(x)
    return res
```

##### 本地变量

本地变量只是在def内的函数中是可见的，并且仅在运行时是存在的

所有的在函数内部进行赋值的变量名都默认为本地变量



### 第十七章_作用域

当在一个程序中使用变量名时，python创建、改变、或查找变量都是在所谓的命名空间中进行的，也就是说代码中的变量名被赋值的位置决定了能被访问到的范围

函数为程序增加了一个命名空间层：

- 在def内定义的变量名能够被def内的代码使用，不能在函数的外部引用这样的变量名
- def之中的变量名和def之外的变量名并不冲突，一个在def之外被赋值的变量X和在这个def之中赋值的变量X是完全不同的变量

变量可以在3个不同的地方分配，分别对应3种不同的作用域：

- 如果一个变量在def内赋值，它被定位在函数之内
- 如果一个变量在一个嵌套的def种赋值，对嵌套的函数来说，它是非本地的
- 如果在def之外赋值，它就是整个文件全局的

我们将其称为语义作用域，函数作用域有助于防止程序之中变量名的冲突，有助于函数成为更加独立的程序单元

#### 作用域法则

- 内嵌的模块是全局作用域，每一个模块都是一个全局作用域，对于外部的全局变量就成为一个模块对象的属性，

- 全局作用域的作用范围仅限于单个文件

  > 在一个文件的顶层的变量名仅对于这个文件内部的代码而言是全局的

- 每次对函数的调用都创建了一个新的本地作用域

- 赋值的变量名除非声明为全局变量或非本地变量，否则均为本地变量

  > 默认在函数内部的变量名是本地作用域内的

  - 如果需要给一个在函数内部却位于模块文件顶层的变量名赋值，需要在函数内部通过global语句声明
  - 如果需要给位于一个嵌套的def中的名称赋值，可以通过nonlocal语句来声明

- 所有其他的变量名都可以归纳为本地、全局或内置变量



交互模式运行的代码实际上是输入到一个叫做\_\_main\_\_的内置模块中

一个函数内部的任何赋值都会把一个名称划为本地的：包括 =语句、import中的模块名称、def中的函数名称、函数参数名等

- 原处修改不会把变量划分为本地变量

#### 变量名解析：LEGB原则

对于一个def语句：

- 变量名引用分为三个作用域进行查找：首先是本地，之后是函数内、之后是全局最后是内置
- 默认 情况下，变量名赋值会创建或者改变本地变量
- 全局声明和非本地声明将赋值的变量名映射到模块文件内部的作用域

#### 作用域实例

```python
# global scope
X = 99
def fun(Y):
    # local scope
    Z = X + Y
    return Z
    
# 全局变量名：X,fun
# 本地变量名：Z，Y
```

本地变量是作为临时变量名，只有在函数运行时才需要他们

- 函数使用的绝大多数变量只会在函数自身内部出现，而不是模块文件的任意其他地方
- 本地变量名不会改变程序其他程序，易于调试

#### 内置作用域

内置作用域通过一个名为__builtins__的标准库模块来实现，这个变量名自身并没有放入内置作用域，所以必须导入才能使用：`import builtins`

```python
import builtins
dir(builtins)
>['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
```

前一半是内置异常，后一半是内置函数，两种方式引用一个内置函数：

```
>>> zip
<class 'zip'>
>>> builtins.zip
<class 'zip'>
```

第二种方式在更复杂的任务中是很有用的，

由于LEGB查找流程，会使它找到第一处变量名的地方生效

同时低层的作用域变量名会覆盖高层的作用域变量，全局变量有可能覆盖内置的变量名

#### global语句

__把函数内部的变量变为全局变量，不管这个变量是否在之前出现__

```python
def test():
    global aaa
    aaa = 9
    print('ok',aaa)
test()
> ok 9

aaa = 0
def test():
    global aaa
    aaa = 9
    print('ok',aaa)
test()
> ok 9
```



命名空间的声明：告诉python打算生成一个或多个全局变量名

- 位于模块文件内部的顶层的变量名
- 如果在函数内被赋值的话，必须经过声明
- 全局变量在函数内部可以被引用

global允许我们修改一个模块文件顶层的def之外的名称

global语句包含了关键字global,其后跟着一个或多个由逗号分开的变量名，当函数主体被赋值或引用时，所有列出来的变量名将被映射到整个模块的作用域内

```python
X = 88
def fun():
    global X
    X = 99
fun()
print(X)
>99
```

##### 最小化全局变量

将本地变量变为全局变量会引发一些软件工程问题：

```
X = 99
def fun1():
    global X
    X = 88

def fun2():
    global X
    X = 77
```

如果不确定引用的时间，X的值是多少是个毫无意义的问题

在不熟悉编程的情况下，最好避免使用全局变量

##### 最小化文件间的修改

尽管跨文件变量在python中是可以修改的，这会让两个文件有过强的相关性，会导致代码不灵活，容易出bug

```python
# first.py
X = 99
# second.py
import first
first.X = 88
```

##### 其他访问全局变量的方法

由于全局变量构成了一个被导入的对象的属性，我们能够通过使用导入嵌入的模块，并对其属性进行赋值来仿造出一个global语句

```python
var = 99

def local():
	var = 0

def glob1():
	global var
	# change global var
	var += 1

def glob2():
	var = 0
	import thismod
	thismod.var += 1

def glob3():
	var = 0
	import sys
	glob = sys.modules['thismod']
	glob.var += 1
	return var

def test():
	print(var)
	local();glob1();glob2();glob3()
	print(var)
```

全局变量于模块的属性是等效的，global 允许我们修改模块中的名称

##### 作用域和嵌套函数

LEGB中给Ｅ包含了任意嵌套函数内部的本地作用域（静态嵌套作用域）

> 一个引用首先在本地（函数内）作用域查找变量，之后会在嵌套了的函数中的本地作用域，由内到外，之后查找当前的全局作用域(模块文件)，最后再内置作用域，__全局声明将会直接从全局作用域进行搜索__

```python
x = 99

def f1():
	x = 88
	def f2():
		print(x)
	# f2是f1本地作用域中的变量，f2是一个临时函数
	f2()

f1()
> 88

# 嵌套作用域的查找在嵌套函数已经返回后也是有效的
def f1():
	x = 88
	def f2():
		print(x)
	return f2
action= f1()
action()
>88
```

f2的函数的调用是在f1运行后发生的，f2记住了在f1中嵌套作用域中的x,尽管f1已经不处于激活状态

##### 工厂函数

闭包（closure）有时也叫工厂函数——==一个能记住嵌套作用域的变量值的函数==，尽管那个作用域或许已经不存在了。

尽管类是最适合用作记忆状态的，因为它通过属性赋值让这个过程变得很明了，工厂函数也提供了替代方案

```python
def maker(N):
    def action(x):
        return x**N
    return action
f = maker(2)
f
><function __main__.maker.<locals>.action(x)>
f(3)
>9
f(4)
>16
```

内嵌函数记住了整数2，即变量N的值，尽管调用执行f时maker已经返回退出，实际上本地作用域内的N被==作为执行的状态信息保留了下来==

```python
g = maker(3)
g(3)
>27
```

对一个工厂函数的每次调用，都得到了自己的状态信息的集合，我们赋给g的函数记住了3，f记住了2，每个函数都有自己的状态信息由maker中的变量N保持

嵌套的作用域常常被lambda函数创建表达式使用

嵌套作用域和lambda

lambda是一个表达式

尽管对于def本身来说，嵌套作用域很少用，但是当开始编写lambda表达式时，就要注意了，lambda引入了新的本地作用域

```python
def fun():
    x = 4
    action = (lambda n:x ** n)
    return action

a = fun()
a(2)
>16
```

##### 作用域与带有循环变量的默认参数相比较

```python
def makeAction():
    acts = []
    for i in range(5):
        acts.append(lambda x: i ** x)
    return acts
acts = makeAction()
acts
>[<function __main__.makeAction.<locals>.<lambda>(x)>,
 <function __main__.makeAction.<locals>.<lambda>(x)>,
 <function __main__.makeAction.<locals>.<lambda>(x)>,
 <function __main__.makeAction.<locals>.<lambda>(x)>,
 <function __main__.makeAction.<locals>.<lambda>(x)>]

acts[0](2)
>16
acts[3](2)
>16
```

如果lambda或def在函数中定义，嵌套在一个循环中，并且嵌套的函数引用了一个上层作用域的变量，该变量被循环所改变，所有在这个循环中产生的函数将会有相同的值——==在最后一次循环完成时被引用的变量==

这是在嵌套作用域的值和默认参数方面遗留的一种仍需解释清楚的情况，而不是引用所在嵌套作用域的值

也就是说，为了让这类代码能==工作==，必须==使用默认参数把当前的值传递给嵌套作用域的变量==，==默认参数是在嵌套函数创建时评估的（而不是在调用时），每个函数记住了自己的变量i的值==

```python
def makeAction():
    acts = []
    for i in range(5):
        acts.append(lambda x, i=i: i ** x)
    return acts

f = makeAction()
f[0](2)
>0
f[4](2)
>16
```

##### 任意作用域的嵌套

作用域可以做任意的嵌套，但是只有内嵌的函数（而不是类）会被搜索

```python
def f1():
    x = 99
    def f2():
        def f3():
            print(x)
        f3()
    f2()
f1()
>99
```

python 将会在所有内嵌的def中搜索本地作用域，从内至外，在引用过函数的本地作用域之后，并在搜索模块的全局作用域之前进行这一过程

#### nonlocal 语句

nonlocal时global的近亲，声明了将要在嵌套作用域中修改的名称，nonlocal 应用于==一个嵌套的函数作用域中的一个名称==，而不是所有def之外的全局模块作用域

声明nonlocal的时候，它必须已经存在于该嵌套函数作用域中——它可能只存在于一个嵌套的函数中，并且不能由一个嵌套的def中的第一次赋值创建

##### nonlocal 基础

python3新引入的，它只在一个函数内由意义

```
def fun():
    nonlocal name1,name2,...
```

##### nonlocal 应用

```python
# tester构建并返回nested函数，以便随后使用
def tester(start):
    state = start
    def nested(label):
        print(label, state)
    return nested

F = tester(0)
F('spam')
```

默认情况下，不允许修改嵌套的def作用域中的名称，修改会报错

```python
def tester(start):
    state = start
    def nested(label):
        print(label,state)
        # 尝试修改嵌套作用域变量
        state += 1
    return nested
F = tester(0)
F('spam')
>UnboundLocalError: local variable 'state' referenced before assignment(在赋值前引用)
```

##### 使用nonlocal修改

我们在nested中把tester作用域中的state声明为一个nonlocal,我们就可以在nested函数中修改它了，尽管我们调用返回的nested函数时tester已经返回退出，这也是有效的

```python
def tester(start):
    state = start
    def nested(label):
        nonlocal state
        print(label,state)
        # 修改嵌套作用域变量
        state += 1
    return nested
F = tester(0)
F('spam')
> spam 0
F('adam')
> adam 1
```

##### 边界情况

当执行nonlocal语句时，==nonlocal名称必须已经在一个嵌套的def作用域中赋值过==，否则会报错

```python
def tester(start):
    def nested(label):
        nonlocal state
        print(label,state)
        # 修改嵌套作用域变量
        state += 1
    return nested
F = tester(0)
F('spam')
> SyntaxError: no binding for nonlocal 'state' found
```

nonlocal限制作用域查找仅为嵌套的def,nonlocal不会在嵌套的模块的全局作用域或所有def之外的内置作用域中查找（即使已经有了这些作用域）

```python
state = 11
def tester(start):
    def nested(label):
        nonlocal state
        print(label,state)
        # 修改嵌套作用域变量
        state += 1
    return nested
F = tester(0)
F('spam')
> SyntaxError: no binding for nonlocal 'state' found
```

##### 为什么使用nonlocal

python中有不同的方法来“记住”跨函数和方法的信息，尽管都有利有弊，对于嵌套的作用域引用，nonlocal起到了改进作用——nonlocal语句允许在内存中保持可变状态的多个副本，并且解决了在类无法保证的情况下的简单状态保持

每次调用都创建了可变信息的一个小小的自包含包，可变信息的名称不会与程序的其他部分产生冲突

##### 与全局共享状态

python2.6中实现nonlocal效果的一种通常做法是直接把状态移出全局作用域（模块的嵌套）

```python
def tester(start):
    global state
    state = start
    def nested(label):
        global state
        print(label, state)
        state += 1
    return nested

F = tester(0)
F('spam')
> spam 0
F('abc')
>abc 1
F('eee')
>eee 2

FF = tester(10)
FF('adam')
>adam 10
F('ham')
>ham 11
```

代码是有效的，需要在两个函数中都有global声明，问题是只考虑了模块作用域中状态信息的单个共享副本，如果我们再次调用terster,将会重置模块的状态变量，以至于前面的调用状态被覆盖



























































































### 

### 第十八章_参数

### 第十九章_函数的高级话题

### 第二十章_迭代和解析（第二部分）

## 第五部分_模块

### 第二十一章_模块：宏伟蓝图

### 第二十二章_模块代码编写基础

### 第二十三章_模块包

### 第二十四章_高级模块话题

## 第六部分_类和OOP

### 第二十五章_OOP:宏伟蓝图

### 第二十六章_类代码编写基础

### 第二十七章_更多实例

### 第二十八章_类代码编写细节

### 第二十九章_运算符重载

### 第三十章_类的设计

### 第三十一章_类的高级主题

## 第七章_异常和工具

### 第三十二章_异常基础

### 第三十三章_异常编码细节

### 第三十四章_异常对象

### 第三十五章_异常的设计


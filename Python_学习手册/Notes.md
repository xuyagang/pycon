[TOC]

# 《Python学习手册》

本书覆盖python3.0和2.6，实例中使用3.0的print,介绍2.6语法，我的练习中使用3.0语法。

每章节和每部分后面都用练习题，解答在书的附录B中。



## 第一部分_使用入门

### 第一章_Python 如何运行

#### 1.1 为什么用python

- python注重可读性、一致性和软件质量
- 提高了效率，是c++或者Java的1/5~1/3，无需编译，可立即运行
- 可在所有主流计算机平台上快速移植代码
- 内置多种预编译并可移植模块
- 可以与应用程序的其他部分通信，是产品定制和扩展的工具

#### 1.2 python可定义为面对对象的脚本语言

- 脚本：倾向描述简单的顶层代码
  - 脚本语言可以理解为应用于快速编程任务的简单语言
- 程序：描述相对复杂的多文件应用

#### 1.3 python 的缺点

- 执行速度不够快
- python标准格式-->字节码--->解释字节码
  - 字节码是一种无关平台的格式，具有可移植性
  - 因为没有将代码编译成二进制码，python程序会比像C这样的完全编译语言慢

#### 1.4 python可以做什么？

- 从网站和游戏开发到航天飞机的控制
  - 系统编程
  - 用户图形接口
    - 内置了TKinter
  - internet脚本
  - 组件集成
  - 数据库编程
  - 数值计算和科学计算
  - 游戏、图像、人工智能、XML、机器人

#### 1.5 谁在用？

- youtube视频分享服务
- EVE Online大型多人游戏
- Maya提供了python编程API
- ...



### 第二章_python如何运行程序

- 解释器是代码与机器硬件之间的软件逻辑层
  - 解释器是_让python程序运行起来的程序_
- __.pyc__文件就是编译过的__.py__文件
  - 如果python在机器上有写入权限，程序运行后会在源码同目录下看到.pyc文件
  - 如果运行后源码未修改，下次运行直接加载.pyc文件，跳过编译步骤
  - 必须重新编译时，python会检查源文件和字节码文件的时间戳
- 程序编译为字节码后会发送到python虚拟机（PVM）
  - PVM是python的运行引擎，不是程序，无需安装，是所谓“python解释器”的最后一步

![000](D:\project\pycon\Python_学习手册\img\001.JPG)

- python语言三种主要的实现方式
  - Cpython:标准的的python实现方式
  - Jython：为了与Java集成，包含了java类
    - 让python代码能够脚本化java程序
  - IronPython：让python可以与win平台上的.NET框架和Linux上开源的Mono编写成的应用集成
- 冻结二进制文件/__Frozen Binary__
  - 用python程序生成的__独立的可执行二进制代码__
  - 简单来说就是：将python程序转为可执行程序
    - Frozen Binary 将程序的字节码，PVM以及任何程序所需要的python支持文件捆绑在一起，形成一个单独的文件包---可执行二进制程序（类似win平台的 .exe文件）
- 生成方式：
  - py2exe——win下使用
  - PyInstaller——在Linux和UNIX上使用



### 第三章_如何运行程序

- 交互提示模式运行代码

  - 在for循环和if中，用一个空行结束多行符合语句，需要按下两次Enter

- python file.py             运行file文件，在命令窗口输出结果

- python file.py > result.txt     输出结果到result.txt文件中，命令窗口不显示
  - 叫做__流重定向__(stream redirection),用于文本的输入和输出，保存起来以备查看使用
  - shell重定向方法，与python无关，只是python支持而已
    - C:\Users\Dell\Desktop>python aa.py > d:\aa.txt         （在桌面运行并输出结果到d盘）

- 模块导入和重载

  - 每一个.py文件都是 一个模块，可以导入一个模块来读取模块的内容

  - 模块通过这样的属性被外部使用

  - 大型程序有多个模块文件组成，其中一个文件设计成主文件（==顶层文件==：就是启动后运行整个程序的文件）

  - 导入工作只在第一次运行，第一次导入后，之后的导入都不会再工作，甚至改变并保存了模块源代码也不行

  - 导入开销很大，每个文件和程序运行不能重复多于一次

  - 导入必须找到文件并将其编译成字节码之后运行

  - 如果非要在同一会话（不停止和重启会话）再次运行文件，需要调用imp模块中的reload函数

    - ```python
      #  the imp module is deprecated in favour of importlib
      from imp import reload
      reload(script1)
      ```

  - reload函数希望获得的参数是一个已经加载了的模块对象名称

  - reload需要加括号，import 不需要（reload是被调用的函数，import是语句）

- 模块的属性

  - 模块是变量名的封装，被认为是命名空间，包中的变量就是所谓的属性

  - 属性就是绑定在特定对象（比如模块）上的变量名

  - 模块变量名可通过一下语句读取：

    - import
    - from
    - reload调用

  - ```python
    # 我们已有文件test.py
    	# 内容：content = ‘The Meaning of Life'
    # 方式一：grab the whole module
    import test
    test.content
    # 方式二：copy myltiple names
    from test import content
    content
    ```

  - 以上结果相同，from和import类似，from增加了对载入组件的额外赋值（content=test.content）

    - 使用from会获取文件变量的==复本==,可使用__dir()__函数查看
    - 使用import会把文件生成到一个单独的模块名称空间中，所付出的代价就是代码修改后运行需要__重载__

  - 每个模块是一个独立完备的变量包，即一个命名空间，一个模块看不到其他文件的变量名（除非显示的导入），模块在代码文件中起到了==最小化命名冲突==的作用

  - from把变量从一个文件复制到另外文件中，可能会导致相同名称的变量被覆盖（不会给出警告）

  - reload 不可传递，重载一个模块不会重载该模块导入的任何模块，因此有时需要reload多个文件

- 使用exec()运行模块文件

  - ```python
    exec(open('test.py').read())
    ```

- IDLE用户界面

  - 提供了python开发的图形界面，是使用TKinter GUI开发出来，可以在几乎任何python平台使用。

- 嵌入式调用

  - 在一些特定的领域，python代码会在一个封闭的系统中运行
  - 这样的嵌入式执行模式一般支持终端用户定制，用户可修改python代码（==python代码是解释性的，不必重新编译==）

- 总结：

  - 在系统平台终端命令行的地方运行一个脚本文件，也可通过导入、重载、exec()、IDLE的run等运行脚本



## 第二部分_类型和运算

### 第四章_python对象类型

python程序：==程序==由模块组成，==模块==包含语句，==语句==包含表达式，==表达==式建立并处理对象

#### 4.1 为什么使用内置类型

- 内置类型使程序容易编写
- 内置类型是扩展的组件
- 内置比定制的更有效率
- 内置对象是语言标准的一部分

#### 4.2 核心数据类型

- 数字
- 字符串
- 列表
- 元组
- 字典
- 集合
- 文件
- 其他：None、Bool
- 编程单元：函数、模块、类

以上并不完整，python章每样东西都是一种对象

- python中没有类型声明，运行表达式的语法决定了对象的类型，对象一旦创建就和操作集合绑定了（对字符串只可进行字符串相关操作）
  - 动态语言：自动跟踪类型而不是要求声明
  - 强类型语言：只能对一个对象进行适合该类型的语言
- 寻求帮助：
  - dir()
  - help()

___

- python核心数据名称：数字，字符串，列表，元祖，姐，字典，文件，
  - 多种数字类型：整数，浮点，复数，分数，十进制数
  - “核心”是因为他们是python语言的一部分，大多数都有特定的语法去生成他们，
- 一个具有不可变性的对象是一个__创建后不能够改变的对象__，python中的__数字、字符串和元祖__属于这个分类，尽管无法就地改变，但总可以通过运行一个表达式创建一个 新的对象
- 一个__序列__是一个_对位置进行排序的对象的集合_,字符串、列表、元祖是python中的所有的序列，他们拥有一般的序列操作（索引、切片、合并），但又有自己类型的特定方法
- __映射__表示将键和相关值相互关联的对象，字典是核心类型中唯一的映射类型。映射没有从左至右的位置顺序，支持通过键获取数据，并包含了特定的方法
- __多态__是指一个操作符（如 +）的意义取决于被操作的对象，这是python的关键思想：==不要把代码限制在特定的类型上，是代码自动适用于多种类型==



### 第五章_数字

在python中数据采用了对象的形式，无论是内置对象还是用python的工具创建的对象。

- 在python中，数字并不是一个真正的对象类型，而是__一组类似类型的分类__，数字类型完整工具包括：
  - 整数和浮点数
  - 复数
  - 固定精度的十进制
  - 有理分数
  - 集合
  - 布尔类型
  - 无穷的整数精度
  - 各种内置的函数和模块

#### 5.1 数字常量

- python提供整数（正整数和负整数）和浮点数，允许使用十六进制，八进制和二进制常量表示整数，提供复数类型，允许整数具有无穷的精度
  - 十六进制：以ox或OX开头，后接16进制数0-9，A-F
  - 八进制：0o或0O，后接0-7数
  - 二进制：0b或0B开头，后接0-1
  - 整数转为对象字符串
    - hex(int)
    - oct(int)
    - bin(int）
  - 给定进制字符串转为整数
    - int(str,base)
  - 复数
    - 复数写成实部+虚部，虚部以J或j结尾
    - 也可用内置的complex(real,imag)创建复数

#### 5.2 表达式操作符

- 表达式是处理数字的基本工具，表达式通常使用_数学符号_和_操作符_写出来

- 操作符：

  - yield x                                          生成器函数发送协议
    - 返回生成器中的send(...)参数
  - lambda  args: expression         生成匿名函数
  - x if y else z                                  三元选择表达式
  - x   or  y                                         逻辑或（只有x为假，才会计算y）
  - x   and  y                                      逻辑与（只有x为真，才会计算y)
  - not  x                                            逻辑非
  - in， not  in                                   成员关系
  - is,  is not                                       对象实体测试
  - <,<=,>,>=，==，！=                     大小比较，相等性
  - x | y                                               位或，并集
  - x ^ y                                               位异或，集合对称差
  - x & y                                              位与，交集
  - x << y , x>> y                                 左移/右移y位
  - +，-，*，/                                     加减乘除
  - x % y                                              余数/格式化
  - x // y                                               floor 除法（整除）
  - -x,+x                                                一元操作
  - ~x                                                    按位取反
  - x**y                                                幂运算
  - x[i]                                                  索引
  - x[i:j:k]                                             分片
    - 等同于 x[slice(I,J,K)]
  - x(...)                                                 调用函数、方法、其他可调用类型
  - x.attr                                               属性引用
  - （...）                                              元组，表达式，生成器表达式
  - [...]                                                   列表，列表解析
  - {...}                                                   字典、集合、集合和字典解析

- 操作符优先级

  - 上表中越靠后的优先级越高
  - 比较运算和表达式通常从左到右组合，幂运算是从右到左组合
  - 如果用用括号对表达式的各部分进行分组，就可以忽略优先级的事情了
    - 使用括号划分子表达式的时候，python总是会先计算括号中的表达式，然后将结果用于整个表达式中
  - 混合类型自动升级
    - 表达式中能混合数字类型（整数和浮点数相加）
    - 混合类型中，python首先==将操作对象转换为其中最复杂的操作对象类型==，然后运算
    - python中：整数比浮点数简单，浮点数比复数简单
    - 混合操作类型仅仅在数字类型混合到一个表达式中适用

- 变量和基本表达式

  - 变量在第一次赋值时创建
  - 变量在表达式中使用将会被替换为它的值
  - 变量在表达式中使用前必须已赋值
  - 变量不需要预先声明，但要赋值一次

- 数字显示的格式

  - 由于浮点数的硬件限制，无法准确显示一些值

  - ```python
    num = 1/3
    '%e' % num		# string formatting expression
    >>> 3.333333e-01
    '%4.2f' %num
    >>> 0.33
    '0:4.2f'.format(num)
    >>> 0.33
    ```

  - str 和repr 的显示格式

    - 默认的交互模式回显和打印的区别相当于repr和str函数的区别
      - repr:产生的结果看起来像代码（__额外细节__）
      - str:用户友好模式(__一般用途__)
        - 除了为任意对象打印字符串，str内置函数也是字符串类型的名字

- 比较

  - 一般的和连续的

  - 除了正常的大小值比较，python允许我们把多个比较连续起来执行==范围测试==

    - 例：

    - ```python
      # 测试B是否在A和C之间
      A < B < C			
      # 等同于
      A < B and B < C
      
      # 第一个简单便于使用，并且B值计算一次，速度要快一些
      ```

- 除法：

  - x/y	真除法

  - x//y       整除法（floor）

    - 截断除法：真正结果之下的最近整数

  - ```python
    >>> 10//4
    2
    >>> 10//4.0
    2.0
    # 操作数中有一个是浮点数，结果就是浮点数，否则结果是整数
    ```

- 整数精度

  - python3支持整数的无穷大小，实际中，长整数的运算比正常整数慢，以性能换精度

- 复数

  - 表示为两个浮点数（实部和虚部）并在虚部增加了J/j的后缀
  - 复数允许我们分解它的是实部和虚部作为属性
  - 可通过标准的cmath模块处理

- 十六进制/八进制/二进制

  - oct()

  - hex()

  - bin()

  - int(str,base)     将数字的字符串变换为整数

  - eval()                 将字符串作为python代码

    - ```python
      eval('0b1000000')
      eval('0x40')
      ```

    - 

  - ```python
    # 字符串格式化方法调用和表达式将一个整数转为八、十六、二进制
    '{0:o},{1:x},{2:b}'.format(64,64,64)
    ```

- 位操作

  ```
  x = 1
  x << 2
  # 表达式中二进制数1（0001）左移了两位（0100）成为4
  ```

  - python支持C语言中大多数数学表达式
    - 包括把整数当作二进制位串的操作
    - 二进制与 &
    - 二进制或 |

- 其他内置数学工具

  - pow
  - abs
  - math 模块
    - math.pi
    - math.e
    - sin、sqrt、pow、abs、min、floor、trunc、round、
      - 求解sqrt
        - math.sqrt
        - 144**0.5
        - pow(144,0.5)
  - random模块

- 其他数字类型

  ---

  - 小数数字
    - 浮点数学缺乏精确性，因为用来存储数值的空间有限
    - 与硬件相关的浮点数运算在精度方面有内在缺陷

  - decimal 模块

  - 设置全局精度

    - ```python
      import decimal
      decimal.getcontext().prec = 4
      ```

  - 小数上下文管理

    - 使用上下文管理语句来设置临时精度,语句退出后恢复初始值

      - ```python
        import decimal
        with decimal.localcontext() as ctx:
        	ctx.prec = 2
            # expression
        ```

---

- 分数

  - python引入了数字类型——分数，实现了一个有理数对象，避免了浮点数的不精确性和局限性

  - 分数是小数的近亲，都可以通过固定小数位和指定舍入或截断来控制精度

  - fractions模块

  - ```python
    from fractions import Fraction
    x = Fraction(1,3)
    print(x)    # Fraction(1,3)
    ```

    - 一旦创建了分数，就可以用于数学表达式

    - 也可以从小数来创建分数

    - ```python
      Fraction('025')
      ```

  - 数值精度

    - 分数和小数提供了精确的结果，付出了速度的代价

    - 分数和小数能提供比浮点数直观准确的结果

      - 分数保持精确性，并自动简化结果

        - ```python
          from fractions import Fraction
          >>> Fraction(6/12)
          Fraction(1, 2)
          ```

  - 转换和混合类型

    - 浮点数有一个方法，能够产生他们的分子分母比

    - 分数有一个from_float方法，并且接受一个Fraction作为参数

      - ```
        >>> (2.5).as_integer_ratio()
        (5, 2)
        ```


#### 5.3 集合

- set : 唯一的、不可变的对象的无序集合，一个项只能出现一次

- 可迭代的，可增长和缩短，能包含各种对象类型

- 既不是序列也不是映射类型

- python 中{}是一个字典，空的集合必须由set来创建

- 集合只能包含不可变的（可散列的）对象

  - 列表和字典不能嵌入到集合中
  - 需要存储符合值的话，元祖是可以嵌入的
  - 集合本身是可变的，不能嵌入到其他集合中

- 需要在另外一个集合中存储一个集合，可以调用frozenset,它创建一个不可变的集合，不可修改且可嵌入其他集合

- 集合解析

  - ```python
    {x**2 for x in [1,2,3,4]}
    # 循环在右边，集合表达式在左边
    ```

- 为什么使用集合

  - 集合中项只能存在一次，可用来去重（转换为set,在转换回来）

    - ```
      L = [1,2,3,1,2,4,5]
      L = list(set(L))
      ```

  - 在遍历或循环结构中可用来记录已经访问过的位置

  - 集合的交集包含了共有对象，并集包含所有项目

- 布尔型

  - bool原本是一个数字，有True和False，不过是整数1和0以不同形式显示后的定制版而已

  - True和False的行为与1和0 的是一样的，有特定的显示逻辑

  - 可将True和False看作预定义的设置为1和0的变量

    - True是定制了显示格式的整数1

    

### 第六章_动态类型简介

动态类型的多态性是其语言简洁灵活的基础

- python中类型是在运行过程中自动决定的，而不是通过代码声明

- 变量、对象、引用

  - 变量创建：给一个变量赋值，之后的赋值会改变已经创建变量名的值（__最初的赋值创建变量__）
  - 变量类型：类型的概念存在与对象中而不是变量名中，变量是通用的，只是在特定的时间点引用了特定的对象而已
  - 变量使用
    - 变量出现在表达式中，马上会被替换成其引用的对象
    - 变量必须在使用前明确的赋值，使用未赋值的变量会产生错误

  ==变量在赋值的时候创建，可以引用任何类型对象，必须在引用前赋值==

```
a = 3
# 1.创建一个对象来代表3
# 2.创建一个变量a,如果还没创建的话
# 3.将变量与对象3相连接
```

- 运行a=3后，变量a变成对象3的引用，事实上在内部==变量是到内存空间的一个指针==

- 总结

  - 变量是一个系统表的元素，拥有指向对象的连接空间
  - 对象是分配的一块内存，有足够的空间表示所代表的值
  - 引用是自动形成的从变量到对象的指针

- 对象的垃圾回收

  ```
  a = 3
  a = 'spam'
  # 给a第二次赋值时，对象3发生了什么变化
  ```

  - 每当一个变量名被赋予一个新的对象，之前那个对象占用的空间会被回收（如果它没有被其他变量名或对象引用的话）---这种自动回收对象空间的技术叫垃圾收集
  - 在内部，python为每个对象保持了一个计数器，用于记录当前指向该对象的引用的数目，一旦这个计数器被设置为0，这个对象的内存空间就会自动回收

- 共享引用

  ```python
  a = 3
  b = a
  # 运行b=a后，b成为对象3的一个引用
  ```

  ![001](D:\project\pycon\Python_学习手册\img\000.JPG)
  ```
  a = 3
  b = a
  a = 'spam'
  # b仍然引用原始的对象 3
  ```

  ![002](D:\project\pycon\Python_学习手册\img\002.JPG)
  ==给一个变量赋一个新的值，并不是替换了原始的对象，而是让变量引用不同的对象==

- 共享引用和原处修改

  - 有些对象操作会在原处改变对象，而不是生成一个新的对象

  - 对于这种支持原处修改的对象，共享引用时需小心（__因为对一个变量名的修改会影响其他变量__）

    - ```
      L1 = [1,2,3]
      L2 = L1
      # L1和L2都引用了相同的对象
      L1[0] = 11
      >>>L2 = [11,2,3]
      # 改变了L1引用对象的一个元素，修改会覆盖列表
      ```

  - 如果不想原处修改，需要python的拷贝对象

    - 内置列表函数和copy模块

      - 列表从头到尾的切片

      - ```
        L1 = [2,3,4]
        L2 = L1[:]
        # L1的修改不会影响L2
        ```

        - L2引用的是L1的拷贝，两个变量指向了不同的对象（内存区域）
        - 分片技术不会应用到集合和字典，他们不是序列

      - 复制一个字典和集合应使用X.copy()

        - copy模块有一个通用的复制任意对象的调用

        - 也有一个拷贝嵌套对象结构的调用

          - ```
            import copy
            x = copy.copy()
            x = copy.deepcopy()
            ```

- 共享引用和相等

  - ==：测试两个被引用的对象是否有相同的值

  - is : 检查对象的同一性

    - 事实上is只是比较引用的指针（也等价与是代码检测共享的一种方式）

    ```python
    L = [1,2,3]
    M = [1,2,3]
    a = '123'
    b = '123'
    i = 123
    j = 123
    
    print(L==M,a==b,i==j)
    >>>True True True
    print(L is M,a is b, i is j)
    >>False True True
    ```

    - ==因为小的整数和字符串被复用了，所以is告诉我们a is b he i is j 是True(是相同的对象)==

  - 



















































### 第七章_字符串

### 第八章_列表字典

### 第九章_元祖、文件及其他

## 第三部分_语法和语句

### 第十章_python语句简介

### 第十一章_赋值、表达式和打印

### 第十二章_if测试和语法规则

### 第十三章_while和for循环

### 第十四章_迭代器和解析（第一部分）

### 第十五章_文档

## 第四部分_函数

### 第十六章_函数基础

### 第十七章_作用域

### 第十八章_参数

### 第十九章_函数的高级话题

### 第二十章_迭代和解析（第二部分）

## 第五部分_模块

### 第二十一章_模块：宏伟蓝图

### 第二十二章_模块代码编写基础

### 第二十三章_模块包

### 第二十四章_高级模块话题

## 第六部分_类和OOP

### 第二十五章_OOP:宏伟蓝图

### 第二十六章_类代码编写基础

### 第二十七章_更多实例

### 第二十八章_类代码编写细节

### 第二十九章_运算符重载

### 第三十章_类的设计

### 第三十一章_类的高级主题

## 第七章_异常和工具

### 第三十二章_异常基础

### 第三十三章_异常编码细节

### 第三十四章_异常对象

### 第三十五章_异常的设计


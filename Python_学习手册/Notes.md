[TOC]

# 《Python学习手册》

本书覆盖python3.0和2.6，实例中使用3.0的print,介绍2.6语法，我的练习中使用3.0语法。

每章节和每部分后面都用练习题，解答在书的附录B中。



## 第一部分_使用入门

### 第一章_Python 如何运行

#### 1.1 为什么用python

- python注重可读性、一致性和软件质量
- 提高了效率，是c++或者Java的1/5~1/3，无需编译，可立即运行
- 可在所有主流计算机平台上快速移植代码
- 内置多种预编译并可移植模块
- 可以与应用程序的其他部分通信，是产品定制和扩展的工具

#### 1.2 python可定义为面对对象的脚本语言

- 脚本：倾向描述简单的顶层代码
  - 脚本语言可以理解为应用于快速编程任务的简单语言
- 程序：描述相对复杂的多文件应用

#### 1.3 python 的缺点

- 执行速度不够快
- python标准格式-->字节码--->解释字节码
  - 字节码是一种无关平台的格式，具有可移植性
  - 因为没有将代码编译成二进制码，python程序会比像C这样的完全编译语言慢

#### 1.4 python可以做什么？

- 从网站和游戏开发到航天飞机的控制
  - 系统编程
  - 用户图形接口
    - 内置了TKinter
  - internet脚本
  - 组件集成
  - 数据库编程
  - 数值计算和科学计算
  - 游戏、图像、人工智能、XML、机器人

#### 1.5 谁在用？

- youtube视频分享服务
- EVE Online大型多人游戏
- Maya提供了python编程API
- ...



### 第二章_python如何运行程序

- 解释器是代码与机器硬件之间的软件逻辑层
  - 解释器是_让python程序运行起来的程序_
- __.pyc__文件就是编译过的__.py__文件
  - 如果python在机器上有写入权限，程序运行后会在源码同目录下看到.pyc文件
  - 如果运行后源码未修改，下次运行直接加载.pyc文件，跳过编译步骤
  - 必须重新编译时，python会检查源文件和字节码文件的时间戳
- 程序编译为字节码后会发送到python虚拟机（PVM）
  - PVM是python的运行引擎，不是程序，无需安装，是所谓“python解释器”的最后一步

![000](D:\project\pycon\Python_学习手册\img\001.JPG)

- python语言三种主要的实现方式
  - Cpython:标准的的python实现方式
  - Jython：为了与Java集成，包含了java类
    - 让python代码能够脚本化java程序
  - IronPython：让python可以与win平台上的.NET框架和Linux上开源的Mono编写成的应用集成
- 冻结二进制文件/__Frozen Binary__
  - 用python程序生成的__独立的可执行二进制代码__
  - 简单来说就是：将python程序转为可执行程序
    - Frozen Binary 将程序的字节码，PVM以及任何程序所需要的python支持文件捆绑在一起，形成一个单独的文件包---可执行二进制程序（类似win平台的 .exe文件）
- 生成方式：
  - py2exe——win下使用
  - PyInstaller——在Linux和UNIX上使用



### 第三章_如何运行程序

- 交互提示模式运行代码

  - 在for循环和if中，用一个空行结束多行符合语句，需要按下两次Enter

- python file.py             运行file文件，在命令窗口输出结果

- python file.py > result.txt     输出结果到result.txt文件中，命令窗口不显示
  - 叫做__流重定向__(stream redirection),用于文本的输入和输出，保存起来以备查看使用
  - shell重定向方法，与python无关，只是python支持而已
    - C:\Users\Dell\Desktop>python aa.py > d:\aa.txt         （在桌面运行并输出结果到d盘）

- 模块导入和重载

  - 每一个.py文件都是 一个模块，可以导入一个模块来读取模块的内容

  - 模块通过这样的属性被外部使用

  - 大型程序有多个模块文件组成，其中一个文件设计成主文件（==顶层文件==：就是启动后运行整个程序的文件）

  - 导入工作只在第一次运行，第一次导入后，之后的导入都不会再工作，甚至改变并保存了模块源代码也不行

  - 导入开销很大，每个文件和程序运行不能重复多于一次

  - 导入必须找到文件并将其编译成字节码之后运行

  - 如果非要在同一会话（不停止和重启会话）再次运行文件，需要调用imp模块中的reload函数

    - ```python
      #  the imp module is deprecated in favour of importlib
      from imp import reload
      reload(script1)
      ```

  - reload函数希望获得的参数是一个已经加载了的模块对象名称

  - reload需要加括号，import 不需要（reload是被调用的函数，import是语句）

- 模块的属性

  - 模块是变量名的封装，被认为是命名空间，包中的变量就是所谓的属性

  - 属性就是绑定在特定对象（比如模块）上的变量名

  - 模块变量名可通过一下语句读取：

    - import
    - from
    - reload调用

  - ```python
    # 我们已有文件test.py
    	# 内容：content = ‘The Meaning of Life'
    # 方式一：grab the whole module
    import test
    test.content
    # 方式二：copy myltiple names
    from test import content
    content
    ```

  - 以上结果相同，from和import类似，from增加了对载入组件的额外赋值（content=test.content）

    - 使用from会获取文件变量的==复本==,可使用__dir()__函数查看
    - 使用import会把文件生成到一个单独的模块名称空间中，所付出的代价就是代码修改后运行需要__重载__

  - 每个模块是一个独立完备的变量包，即一个命名空间，一个模块看不到其他文件的变量名（除非显示的导入），模块在代码文件中起到了==最小化命名冲突==的作用

  - from把变量从一个文件复制到另外文件中，可能会导致相同名称的变量被覆盖（不会给出警告）

  - reload 不可传递，重载一个模块不会重载该模块导入的任何模块，因此有时需要reload多个文件

- 使用exec()运行模块文件

  - ```python
    exec(open('test.py').read())
    ```

- IDLE用户界面

  - 提供了python开发的图形界面，是使用TKinter GUI开发出来，可以在几乎任何python平台使用。

- 嵌入式调用

  - 在一些特定的领域，python代码会在一个封闭的系统中运行
  - 这样的嵌入式执行模式一般支持终端用户定制，用户可修改python代码（==python代码是解释性的，不必重新编译==）

- 总结：

  - 在系统平台终端命令行的地方运行一个脚本文件，也可通过导入、重载、exec()、IDLE的run等运行脚本



## 第二部分_类型和运算

### 第四章_python对象类型

python程序：==程序==由模块组成，==模块==包含语句，==语句==包含表达式，==表达==式建立并处理对象

#### 4.1 为什么使用内置类型

- 内置类型使程序容易编写
- 内置类型是扩展的组件
- 内置比定制的更有效率
- 内置对象是语言标准的一部分

#### 4.2 核心数据类型

- 数字
- 字符串
- 列表
- 元组
- 字典
- 集合
- 文件
- 其他：None、Bool
- 编程单元：函数、模块、类

以上并不完整，python章每样东西都是一种对象

- python中没有类型声明，运行表达式的语法决定了对象的类型，对象一旦创建就和操作集合绑定了（对字符串只可进行字符串相关操作）
  - 动态语言：自动跟踪类型而不是要求声明
  - 强类型语言：只能对一个对象进行适合该类型的语言
- 寻求帮助：
  - dir()
  - help()

___

- python核心数据名称：数字，字符串，列表，元祖，姐，字典，文件，
  - 多种数字类型：整数，浮点，复数，分数，十进制数
  - “核心”是因为他们是python语言的一部分，大多数都有特定的语法去生成他们，
- 一个具有不可变性的对象是一个__创建后不能够改变的对象__，python中的__数字、字符串和元祖__属于这个分类，尽管无法就地改变，但总可以通过运行一个表达式创建一个 新的对象
- 一个__序列__是一个_对位置进行排序的对象的集合_,字符串、列表、元祖是python中的所有的序列，他们拥有一般的序列操作（索引、切片、合并），但又有自己类型的特定方法
- __映射__表示将键和相关值相互关联的对象，字典是核心类型中唯一的映射类型。映射没有从左至右的位置顺序，支持通过键获取数据，并包含了特定的方法
- __多态__是指一个操作符（如 +）的意义取决于被操作的对象，这是python的关键思想：==不要把代码限制在特定的类型上，是代码自动适用于多种类型==



### 第五章_数字

在python中数据采用了对象的形式，无论是内置对象还是用python的工具创建的对象。

- 在python中，数字并不是一个真正的对象类型，而是__一组类似类型的分类__，数字类型完整工具包括：
  - 整数和浮点数
  - 复数
  - 固定精度的十进制
  - 有理分数
  - 集合
  - 布尔类型
  - 无穷的整数精度
  - 各种内置的函数和模块

#### 5.1 数字常量

- python提供整数（正整数和负整数）和浮点数，允许使用十六进制，八进制和二进制常量表示整数，提供复数类型，允许整数具有无穷的精度
  - 十六进制：以ox或OX开头，后接16进制数0-9，A-F
  - 八进制：0o或0O，后接0-7数
  - 二进制：0b或0B开头，后接0-1
  - 整数转为对象字符串
    - hex(int)
    - oct(int)
    - bin(int）
  - 给定进制字符串转为整数
    - int(str,base)
  - 复数
    - 复数写成实部+虚部，虚部以J或j结尾
    - 也可用内置的complex(real,imag)创建复数

#### 5.2 表达式操作符

- 表达式是处理数字的基本工具，表达式通常使用_数学符号_和_操作符_写出来

- 操作符：

  - yield x                                          生成器函数发送协议
    - 返回生成器中的send(...)参数
  - lambda  args: expression         生成匿名函数
  - x if y else z                                  三元选择表达式
  - x   or  y                                         逻辑或（只有x为假，才会计算y）
  - x   and  y                                      逻辑与（只有x为真，才会计算y)
  - not  x                                            逻辑非
  - in， not  in                                   成员关系
  - is,  is not                                       对象实体测试
  - <,<=,>,>=，==，！=                     大小比较，相等性
  - x | y                                               位或，并集
  - x ^ y                                               位异或，集合对称差
  - x & y                                              位与，交集
  - x << y , x>> y                                 左移/右移y位
  - +，-，*，/                                     加减乘除
  - x % y                                              余数/格式化
  - x // y                                               floor 除法（整除）
  - -x,+x                                                一元操作
  - ~x                                                    按位取反
  - x**y                                                幂运算
  - x[i]                                                  索引
  - x[i:j:k]                                             分片
    - 等同于 x[slice(I,J,K)]
  - x(...)                                                 调用函数、方法、其他可调用类型
  - x.attr                                               属性引用
  - （...）                                              元组，表达式，生成器表达式
  - [...]                                                   列表，列表解析
  - {...}                                                   字典、集合、集合和字典解析

- 操作符优先级

  - 上表中越靠后的优先级越高
  - 比较运算和表达式通常从左到右组合，幂运算是从右到左组合
  - 如果用用括号对表达式的各部分进行分组，就可以忽略优先级的事情了
    - 使用括号划分子表达式的时候，python总是会先计算括号中的表达式，然后将结果用于整个表达式中
  - 混合类型自动升级
    - 表达式中能混合数字类型（整数和浮点数相加）
    - 混合类型中，python首先==将操作对象转换为其中最复杂的操作对象类型==，然后运算
    - python中：整数比浮点数简单，浮点数比复数简单
    - 混合操作类型仅仅在数字类型混合到一个表达式中适用

- 变量和基本表达式

  - 变量在第一次赋值时创建
  - 变量在表达式中使用将会被替换为它的值
  - 变量在表达式中使用前必须已赋值
  - 变量不需要预先声明，但要赋值一次

- 数字显示的格式

  - 由于浮点数的硬件限制，无法准确显示一些值

  - ```python
    num = 1/3
    '%e' % num		# string formatting expression
    >>> 3.333333e-01
    '%4.2f' %num
    >>> 0.33
    '0:4.2f'.format(num)
    >>> 0.33
    ```

  - str 和repr 的显示格式

    - 默认的交互模式回显和打印的区别相当于repr和str函数的区别
      - repr:产生的结果看起来像代码（__额外细节__）
      - str:用户友好模式(__一般用途__)
        - 除了为任意对象打印字符串，str内置函数也是字符串类型的名字

- 比较

  - 一般的和连续的

  - 除了正常的大小值比较，python允许我们把多个比较连续起来执行==范围测试==

    - 例：

    - ```python
      # 测试B是否在A和C之间
      A < B < C			
      # 等同于
      A < B and B < C
      
      # 第一个简单便于使用，并且B值计算一次，速度要快一些
      ```

- 除法：

  - x/y	真除法

  - x//y       整除法（floor）

    - 截断除法：真正结果之下的最近整数

  - ```python
    >>> 10//4
    2
    >>> 10//4.0
    2.0
    # 操作数中有一个是浮点数，结果就是浮点数，否则结果是整数
    ```

- 整数精度

  - python3支持整数的无穷大小，实际中，长整数的运算比正常整数慢，以性能换精度

- 复数

  - 表示为两个浮点数（实部和虚部）并在虚部增加了J/j的后缀
  - 复数允许我们分解它的是实部和虚部作为属性
  - 可通过标准的cmath模块处理

- 十六进制/八进制/二进制

  - oct()

  - hex()

  - bin()

  - int(str,base)     将数字的字符串变换为整数

  - eval()                 将字符串作为python代码

    - ```python
      eval('0b1000000')
      eval('0x40')
      ```

    - 

  - ```python
    # 字符串格式化方法调用和表达式将一个整数转为八、十六、二进制
    '{0:o},{1:x},{2:b}'.format(64,64,64)
    ```

- 位操作

  ```
  x = 1
  x << 2
  # 表达式中二进制数1（0001）左移了两位（0100）成为4
  ```

  - python支持C语言中大多数数学表达式
    - 包括把整数当作二进制位串的操作
    - 二进制与 &
    - 二进制或 |

- 其他内置数学工具

  - pow
  - abs
  - math 模块
    - math.pi
    - math.e
    - sin、sqrt、pow、abs、min、floor、trunc、round、
      - 求解sqrt
        - math.sqrt
        - 144**0.5
        - pow(144,0.5)
  - random模块

- 其他数字类型

  ---

  - 小数数字
    - 浮点数学缺乏精确性，因为用来存储数值的空间有限
    - 与硬件相关的浮点数运算在精度方面有内在缺陷

  - decimal 模块

  - 设置全局精度

    - ```python
      import decimal
      decimal.getcontext().prec = 4
      ```

  - 小数上下文管理

    - 使用上下文管理语句来设置临时精度,语句退出后恢复初始值

      - ```python
        import decimal
        with decimal.localcontext() as ctx:
        	ctx.prec = 2
            # expression
        ```

---

- 分数

  - python引入了数字类型——分数，实现了一个有理数对象，避免了浮点数的不精确性和局限性

  - 分数是小数的近亲，都可以通过固定小数位和指定舍入或截断来控制精度

  - fractions模块

  - ```python
    from fractions import Fraction
    x = Fraction(1,3)
    print(x)    # Fraction(1,3)
    ```

    - 一旦创建了分数，就可以用于数学表达式

    - 也可以从小数来创建分数

    - ```python
      Fraction('025')
      ```

  - 数值精度

    - 分数和小数提供了精确的结果，付出了速度的代价

    - 分数和小数能提供比浮点数直观准确的结果

      - 分数保持精确性，并自动简化结果

        - ```python
          from fractions import Fraction
          >>> Fraction(6/12)
          Fraction(1, 2)
          ```

  - 转换和混合类型

    - 浮点数有一个方法，能够产生他们的分子分母比

    - 分数有一个from_float方法，并且接受一个Fraction作为参数

      - ```
        >>> (2.5).as_integer_ratio()
        (5, 2)
        ```


#### 5.3 集合

- set : 唯一的、不可变的对象的无序集合，一个项只能出现一次

- 可迭代的，可增长和缩短，能包含各种对象类型

- 既不是序列也不是映射类型

- python 中{}是一个字典，空的集合必须由set来创建

- 集合只能包含不可变的（可散列的）对象

  - 列表和字典不能嵌入到集合中
  - 需要存储符合值的话，元祖是可以嵌入的
  - 集合本身是可变的，不能嵌入到其他集合中

- 需要在另外一个集合中存储一个集合，可以调用frozenset,它创建一个不可变的集合，不可修改且可嵌入其他集合

- 集合解析

  - ```python
    {x**2 for x in [1,2,3,4]}
    # 循环在右边，集合表达式在左边
    ```

- 为什么使用集合

  - 集合中项只能存在一次，可用来去重（转换为set,在转换回来）

    - ```
      L = [1,2,3,1,2,4,5]
      L = list(set(L))
      ```

  - 在遍历或循环结构中可用来记录已经访问过的位置

  - 集合的交集包含了共有对象，并集包含所有项目

- 布尔型

  - bool原本是一个数字，有True和False，不过是整数1和0以不同形式显示后的定制版而已

  - True和False的行为与1和0 的是一样的，有特定的显示逻辑

  - 可将True和False看作预定义的设置为1和0的变量

    - True是定制了显示格式的整数1

    

### 第六章_动态类型简介

动态类型的多态性是其语言简洁灵活的基础

- python中类型是在运行过程中自动决定的，而不是通过代码声明

- 变量、对象、引用

  - 变量创建：给一个变量赋值，之后的赋值会改变已经创建变量名的值（__最初的赋值创建变量__）
  - 变量类型：类型的概念存在与对象中而不是变量名中，变量是通用的，只是在特定的时间点引用了特定的对象而已
  - 变量使用
    - 变量出现在表达式中，马上会被替换成其引用的对象
    - 变量必须在使用前明确的赋值，使用未赋值的变量会产生错误

  ==变量在赋值的时候创建，可以引用任何类型对象，必须在引用前赋值==

```
a = 3
# 1.创建一个对象来代表3
# 2.创建一个变量a,如果还没创建的话
# 3.将变量与对象3相连接
```

- 运行a=3后，变量a变成对象3的引用，事实上在内部==变量是到内存空间的一个指针==

- 总结

  - 变量是一个系统表的元素，拥有指向对象的连接空间
  - 对象是分配的一块内存，有足够的空间表示所代表的值
  - 引用是自动形成的从变量到对象的指针

- 对象的垃圾回收

  ```
  a = 3
  a = 'spam'
  # 给a第二次赋值时，对象3发生了什么变化
  ```

  - 每当一个变量名被赋予一个新的对象，之前那个对象占用的空间会被回收（如果它没有被其他变量名或对象引用的话）---这种自动回收对象空间的技术叫垃圾收集
  - 在内部，python为每个对象保持了一个计数器，用于记录当前指向该对象的引用的数目，一旦这个计数器被设置为0，这个对象的内存空间就会自动回收

- 共享引用

  ```python
  a = 3
  b = a
  # 运行b=a后，b成为对象3的一个引用
  ```

  ![001](D:\project\pycon\Python_学习手册\img\000.JPG)
  ```
  a = 3
  b = a
  a = 'spam'
  # b仍然引用原始的对象 3
  ```

  ![002](D:\project\pycon\Python_学习手册\img\002.JPG)
  ==给一个变量赋一个新的值，并不是替换了原始的对象，而是让变量引用不同的对象==

- 共享引用和原处修改

  - 有些对象操作会在原处改变对象，而不是生成一个新的对象

  - 对于这种支持原处修改的对象，共享引用时需小心（__因为对一个变量名的修改会影响其他变量__）

    - ```
      L1 = [1,2,3]
      L2 = L1
      # L1和L2都引用了相同的对象
      L1[0] = 11
      >>>L2 = [11,2,3]
      # 改变了L1引用对象的一个元素，修改会覆盖列表
      ```

  - 如果==不想原处修改==，需要python的拷贝对象

    - 内置列表函数和copy模块

      - 列表从头到尾的切片

      - ```
        L1 = [2,3,4]
        L2 = L1[:]
        # L1的修改不会影响L2
        ```

        - L2引用的是L1的拷贝，两个变量指向了不同的对象（内存区域）
        - 分片技术不会应用到集合和字典，他们不是序列

      - 复制一个字典和集合应使用X.copy()

        - copy模块有一个通用的复制任意对象的调用

        - 也有一个拷贝嵌套对象结构的调用

          - ```
            import copy
            x = copy.copy()
            x = copy.deepcopy()
            ```

- 共享引用和相等

  - ==：测试两个被引用的对象是否有相同的值

  - is : 检查对象的同一性

    - 事实上is只是比较引用的指针（也等价与是代码检测共享的一种方式）

    ```python
    L = [1,2,3]
    M = [1,2,3]
    a = '123'
    b = '123'
    i = 123
    j = 123
    
    print(L==M,a==b,i==j)
    >>>True True True
    print(L is M,a is b, i is j)
    >>False True True
    ```

    - ==因为小的整数和字符串被复用了，所以is告诉我们a is b 和 i is j 是True(是相同的对象)==

  - 查询对象的引用次数

    - 在sys模块中的getrefcount函数会返回对象的引用次数

      ```
      import sys
      sys.getrefcount(1)
      # 绝大多数idle系统代码所使用
      >>> 2035
      ```

      

### 第七章_字符串

字符串为不可变序列，意味着字符串所包含的字符存在从左至右的位置顺序，不可以再原处修改

![003](D:\project\pycon\Python_学习手册\img\003.JPG)

- 字符串常量

  - 单引号：'spam'
  - 双引号：'spa'm'
  - 三引号：'''...spam...''',"""...spam..."""
  - 转义字符：“s\tp\na\0m”
  - Raw字符串：r"c:\new\test.spm"
  - Byte字符串：b'sp\x01am'

- python自动再任意的表达式中合并相邻的字符串常量

  ```python 
  title = "Meaning" 'of' "Life"
  tiele
  >>>'Meaningoflife'
  ```

- 用转义序列代表特殊字节

  - 反斜杠用来引入特殊的字节编码，是转义序列

  - 交互模式下是以转义字符的形式回显，但print会将其解释出来

  - len()可用来了解字符串中__有多少个字节__

  - 转义字符

    ```
    \newline 				忽视（连续）
    \\						反斜杠本身
    \'						单引号
    \"						双引号
    \a						响铃
    \b						倒退
    \f						换页
    \n						换行
    \r						返回
    \t						水平制表符
    \v						垂直制表符
    \xhh					十六进制
    \ooo					八进制
    \0						Null(不是字符串结尾)
    \other					不转义（保留）
    ```

    - python没有一个字符会结束一个字符串

    - python以十六进制显示非打印字符

      ```
      s = '\001\002\x03'
      s
      >>>'\x01\x02\x03'
      ```

    - 如果python没有作为一个合法的转义编码识别出\后的字符，他就直接保留反斜杠

      ```
      s = '\dd\n\cc'
      s
      >>> '\\dd\n\\cc'
      ```

- raw字符串抑制转义

  - 转义用来处理再字符串中嵌入特殊字节码，有时候引入转义字符而使用的反斜杠会引来一些麻烦

    - 如`my_file= open('c:\new\text.dat','w')`,\n和\t会导致错误

  - 方法一：raw字符串用来解决此问题

    - 大写或小写（r\R）出现在字符串的第一个引号前面，就会关闭转义机制

  - 方法二：两个反斜杠是一个反斜杠的转义序列

    - `my_file = open('c:\\new\\text.dat','w')`

  - 当打印嵌入反斜杠的字符串时候，python自己也会使用转义斜杠的方法(交互模式下)

    ```
    a = r'c:\new\text.dat'
    print(repr(a))
    print(a)
    >>>'c:\\new\\text.dat'
    >>> c:\new\text.dat
    ```

  - window下使用__斜杠__表示字符串路径

  - raw字符串不能以单个的反斜杠结尾，因为反斜杠会转义后续引用的字符

    - `r'...\'`不是一个有效的字符常量
    - 一个raw字符串不能以奇数个反斜杠结尾，如果需要单个的反斜杠结束一个rawz字符串
      - 使用两个反斜杠并分片掉最后一个反斜杠    `r'1\nb\tc\\'[:-1]`
      - 手动添加反斜杠   `r'1\nb\tc'+'\\'`
      - 使用常规的字符转义 `'1\\nb\\tc\\'`

- 三重引号编写多行字符串块
  - 到目前已经学习了单引号、双引号、转义字符、raw字符，python还提供了一种三引号的块字符串
  - 用于输入多行文本
  - 常用于文档字符串
  - 用于注释代码

- 字符串应用

  - \+ 号合并字符串

    - 不允许混用字符和数字

      ```
      'abc'+9
      # 会出错
      ```

      

  - \* 号重复字符串

    - 打印包含80个横线的一行

      ````
      print('-'*80)
      ````

  - for循环迭代字符串

  - in对字符串和子字符串进行成员关系测试

  - 索引和分片

    - 从左到右0为第一个元素，从右到左是 -1为第一个元素
    - s[:-1]  不包括最后一个元素
    - s[:] 所有元素（顶层拷贝）

  - 扩展分片（步长）

    - X[I:J:k]

      - 前两个参数默认值为零,步长K默认为1

    - 可以用负数作为步进

    - k = -1是反转

    - 分片等同于用一个分片对象进行索引

      ```python
      'spam'[1:3]
      # 等同于
      'spam'[slice(1,3)]
      
      print('spam'[::-1])
      # 等价于
      print('spam'[slice(None,None,-1)])
      ```

  - 字符串转换工具

    - int() 将字符串转换为数字
    - repr() 将对象转换为其字符串形式
    - str()转换为字符串

  - 字符串代码转换

    - ord()  将单个字符转换为ascii码（字符再内存中的二进制）

    - chr()  将ascii转换为对应的字符

      - 基于字符串的数学运算

        ```
        num = '9'
        chr(ord(s)+10)
        >>> 19
        ```

  - 字符串方法

    ![008](D:\project\pycon\web scrapy\img\008.PNG)

    ![009](D:\project\pycon\web scrapy\img\009.PNG)

  - 字符串方法实例

    - find()方法返回 字符串出现处的索引，__未找到时返回-1__

    - replace

      - 每次返回一个新的字符串

      - 如果不得对一个超长字符串进行许多的修改，为了优化脚本性能，需要将字符串转换为一个支持原处修改的对象

        ```
        # 可用list函数将其转换为列表，然后进行修改
        # 之后用字符串的join方法将列表合并成一个字符
        ```

    - split

      - 默认空格为分隔符，将字符串分割为多个子字符串（分隔符不会出现在子字符串中）

    - % 格式化

      - 格式化总是返回新的字符串，而不是对左侧的字符串修改

      ```
      'that is %d %s bird' % (1,'big')
      ```

      - 更高级的格式化

        ![004](D:\project\pycon\Python_学习手册\img\004.JPG)

        - `%[(name)][flags][width][.precision]typecode`

          ```python
          x = 1234
          # 默认格式化、6位左对齐、6位补零
          res = 'integers:...%d...%-6d...%06d' %(x,x,x)
          ```

        - 如果在运行时才知道大小，可以在字符串中使用*来指定通过计算得出width和precision

          ```python
          # * 位需要传入整数
          '%f, %.2f, %.*f' % (1/3.0 ,1/3.0, 4, 1/3.0)
          >>> '0.333333,0.33,0.3333'
          ```

      - 基于字典的格式化

        - `"%(n)d %(s)s" % {'n':1,'s':'spam'}`

          

### 第八章_列表字典

都可以在原处修改，也可以增长或缩短，可以包含任何种类的对象

#### 列表

有序集合对象类型，可以包含任何种类的对象，是 可变对象

1. 任意对象的有序集合

2. 通过偏移读取

3. 可变长度、异构、任意嵌套
   1. 异构：可以包含任何类型的对象而不仅仅是包含有单个字符的字符串
4. 可变序列分类
5. 索引、切片、合并

help(list) 或 dir(list) 查看list的方法

- 常用操作

  ![005](D:\project\pycon\Python_学习手册\img\005.JPG)
  - l.insert(i,item)

  - l.index(item)   只返回第一次出现位置

  - l.sort()

  - l.reverse()

  - del l[k]

  - l.pop()   最后一个

  - l.remove(item)    第一个

  - l[i] = j   分片赋值

  - ```
    list(map(ord,'spam'))
    >>>[115, 112, 97, 109]
    ```

  - l = [x**2 for x in range(5)]

#### 实际应用中的列表

- 基本操作

  - \+  合并操作
  - \* 重复操作

- 列表解析和迭代

  - 成员操作
    - `3 in [1, 2, 3]`
  - 迭代
    - `for i in [1,2,3]:`
  - 列表解析
    - res = [c*4 for c in 'spam']

- 索引、分片、矩阵

- 原处修改

  - 原处修改一个 对象时，可能会影响其他指向它的引用

  - 对索引和分片赋值

    - 用一个新值取代指向索引的引用

  - 分片理解

    1. 先删除
    2. 再插入

    ```python
    L = [1,2,3]
    L[1:2] = [4,5]
    L
    >>>[1, 4, 5, 3]
    L[1:2] = []
    L
    >>>[1, 5, 3]
    ```

    - 当分片重叠时`L[2:5]=L[3:6]`是可行的，这是因为要被插入的值会再左侧删除前取出

- 方法调用

  ==方法是特定类型的工具==

  - append:将一个__单项__加至末端，允许传入单一对象

    - L.append(x) 与 L + [X] 结果类似，但后者会生成新的列表

  - `sort(self, /, *, key=None, reverse=False)`

    - 使用标准的python比较检验（字符串比较）递增排序
    - key是针对传入的每个元素生成一个排序id然后排序

  - reversed内置函数，必须包含在list中调用

    ```
    L = [1,2,3,4]
    list(reversed(L))
    >>>[4, 3, 2, 1]
    ```

#### 字典

除了列表外，字典是python中最灵活的内置数据结构类型，列表是有序的对象集合，字典是无序的集合

1. 通过键而不是索引读取
2. 任意对象的无序集合
3. 可变长、异构、任意嵌套
4. 可变映射类型
   1. 字典是唯一内置的映射类型
5. 对象引用表
   1. 字典存储的是对象引用

##### 常用操作

![006](D:\project\pycon\Python_学习手册\img\006.JPG)

​			![007](D:\project\pycon\Python_学习手册\img\007.JPG)

- 对字典赋值（不存在的键）会生成一个新的元素
- 当键不存在时，get能返回默认值（None或者自定义值），这是__为了避免missing_key__错误
- update:把一个字典的值合并到另外一个字典，盲目的覆盖相同的键
- dict.setdefault()   添加默认值，存在就返回,不存在就添加
- dict.popitem()    随机删除键值对
- dict.copy()   浅复制

> 对任何字典而言，写成`for key in D ` 和完整的`for key in D.keys()`效果是一样的
>
> 迭代器允许in成员关系操作符用于字典的另一个实例

- 注意事项

  - 序列运算无效，字典是映射机制，不是序列
  - 对新索引赋值会添加项
  - 键不一定总是字符串，任何不可变对象都可以

  ```
  D = {}
  D[99] = 'spam'
  >>> {99:'spam'}
  ```

  - 字典用于稀疏数据结构

    ```
    matrix = {}
    matrix[(2,3,4)] = 88
    matrix[(7,8,9)] = 99
    >>>{(2,3,4):88,(7,8,9):99}
    ```

  - 避免missing-key错误

    读取不存在的键的错误很常见，常用避免方法:if语句中预先测试，try语句明确的捕获并修复，get方法为不存的键提供默认值

    ```python
    # 方法一：
    if (2,3,6) in Matrix:
        print(Matrix[(2,3,6)])
    else:
        print(0)
    # 方法二：
    try:
        print(Matrix[(2,3,6)])
    except KeyError:
        print(0)
    # 方法三：
    Matrix.get((2,3,6),0)
    ```

  - 创建字典的方法

    ```python
    # traditional
    {'name':'mel','age':45}
    # 键赋值
    D= {}
    D['name'] = 'mel'
    # 键值对
    dict(name = 'mel', age=45)
    # 键值元祖
    dict([('name','mel'),('age',40)])
    ```

- 字典解析

  ```python
  list(zip(['a','b','c'],[1,2,3]))
  D = dict(zip(['a','b','c'],[1,2,3]))
  # 字典解析表达式
  D = {key:value for key,value in zip(['a','b','c'],[1,2,3])}
  
  # 其他例子
  D = {c:c*4 for c in 'spam'}
  >>>{'s':'ssss','p':'pppp','a':'aaaa','m':'mmmm'}
  
  # 初始化字典
      # 一般方法
      D = dict.fromkeys(['a','b','c'],0)
      # 字典解析
      D = {i:0 for i in ['a','b','c']}
  ```

- 字典视图

  - python3中keys、values、items返回视图对象，保持了字典成分的最初顺序

    ```
    D = dict(a=1,b=2,c=3)
    k = D.keys()
    k
    >>>dict_keys(['a', 'b', 'c'])
    ```

  - 字典有自己的迭代器

    ```python
    for key in D:
        print(key)
    ```

- 字典视图和几何

  > keys方法返回的对象类似与集合，支持交集并集等集合操作，values视图不是这样的，因为他们不是唯一的，items的对象也是的，如果（key,value）对是唯一并且可散列的话

  ```python
  D = dict(a=1,b=2,c=3)
  k = D.keys()
  # keys and dict
  k | {'x':3}
  >>>{'a', 'b', 'c', 'x'}
  # keys and set
  k & {'b'}
  >>>{'b'}
  # items and set
  D.items() & {('b', 2)}
  >>>{('b', 2)}
  ```

- 排序字典键

  - keys不会返回列表，必须手动转换为列表或使用sorted函数

    ```python
    D = dict(a=1,b=2,c=3)
    k = D.keys()
    a = list(k)
    a.sort(reverse=True)
    a
    >>>['c', 'b', 'a']
    
    k = D.keys()
    # sorted 把keys对象直接生成列表
    sorted(k,reverse=True)
    >>>['c', 'b', 'a']
    ```

- in 成员测试

  - 使用in或者get方法

    ```python
    D = dict(a=1,b=2,c=3)
    'c' in D
    >>>True
    
    D.get('c','None')
    >>>3
    ```

### 第九章_元祖、文件及其他

#### 元祖

>  元祖与列表相似，不能在原位修改

- 任意对象的有序集合
- 通过偏移存取
  - 支持分片和索引
- 不可变序列类型
- 固定长度、异构、任意嵌套
- 对象引用数组

> 生成一个元祖，将元素用逗号隔开，用圆括号括起来，空括号就是空元祖

- 常见元祖及运算

​	（）					    空元祖

​	T = （0，）				单个元素的元祖

​	T = （0，‘NI’，1.2，3）	   四个元素

​	T = 0，‘NI’，1.2，3		   与前列相同

​	T = （‘abc',('def','ghi')）	   嵌套元祖

​	T = tuple('spam')			可迭代对象

​	T[i]

​	T[i]\[j\]

​	T[i:j]

​	len(T)

​	T1 + T2				合并、重复

​	T * 3	

​	for i in T :

​	    print(i)

​	'spam' in T			 成员关系

​	[x ** 2 for x in T ]	

​	T.index('NI')			搜索

​	T.count('Ni')			计数

- 实际应用

  ```python
  a = (5)		# an integer
  a = (5,)	# a tuple	
  # 多个元素时，没有括号也能识别出元祖
  ```

- 转换、方法及不可变性

  - \+ 、 \* 及分片操作会返回新的元组

  - 对元组排序需要将其转换为列表（可变对象），或者使用sorted方法，它接受任何序列

    - 元组使用sorted排序后返回列表

    ```python
    a = 21,14,3
    b = sorted(a)
    print(b,type(b))
    >>>[3, 14, 21] <class 'list'>
    ```

  - 列表解析可用于元组转换

  - 列表解析可用在某些并非实际存储的序列上，任何遍历对象都可以（包括逐行读取的文件）

  - 元组方法index、count

    ```
    T = (1,2,3,2,4,2)
    T.index(2,2)
    >>>3
    T.index(2)
    >>>1
    T.count(2)
    >>>3
    
    ```

  - 元组的不可变性只适用于元组顶层，而非其内容，内部的列表可以修改

- 为什么需要元组

  元组的不可变性提供了完整性，可以保证在程序中不会被另一个引用修改

- 文件

  - open函数会创建一个python对象

  - 操作方法

    - output = open(r'c:\spam', 'w')

    - input = open('data', 'r')

    - input = open('data')                                        r 是默认

    - aString = input.read()                                     把整个文件读入字符串

    - aString = input.read(N)                                  读取之后的N个字节

    - aString = input.readline()                              读取下一行（包括行末标识符）

    - aList = input.readlines()                                  读取整个文件到字符串列表

    - output.write(aString)                                      写入字节字符串到文件

    - output.writelines(alist)                                   把列表中的所有字符串写入文件

    - output.close()                                                   手动关闭

    - output.flush()                                                    把输出缓冲区刷到硬盘中，但不关闭文件

    - anyFile.seek(N)                                                 修改指针位置到偏移量N处，以便进行下一个操作

    - for line in open('data'):

      ​        use line

- 使用文件

  > Python 中的文本文件都采用字符串的形式，读取文件会返回字符串形式的文本

  - 文件迭代器是最好的读取行工具
  - 内容是字符串，不是对象
    - 从文件读取的数据回到脚本是字符串，需要将其转换为python对象以便使用
  - close是通常选项
    - 当文件对象被回收的时候，如果需要的话，python也会自动关闭该文件
  - 文件时缓冲的并且时可查找的
    - 关闭一个文件或者运行flush方法，迫使缓存的数据进入硬盘

- 实际使用

  - 文件迭代器

    ```python
    for line in open('myfile'):
        print(line,end='')
    ```

  - 使用 line.rstrip() 来移除行的终止符

    - lien[:-1] 也可以

  - 使用eval()可以把字符串转换为对象

- 用pickle存储python的原生对象

  > 能在文件存储python对象，并不需要把字符串转来转去，就像超级通用的数据格式化和解析工具

  ```python
  # 存储字典
  import pickle
  D = {'a': 1, 'b': 2}
  f = open(r'.\datafile.pkl','wb')
  pickle.dump(D,f)
  f.close()
  
  # 读取原生数据
  f = open(r'.\datafile.pkl','rb')
  d = pickle.load(f)
  print(d)
  ```

- 文件中打包二进制数据的存储与解析

  > 有些高级应用中需要处理打包的二进制数据，struct模块能够构造并解析打包的二进制数据

  - pickle用于把python对象储存在文件中，而不用可以转为字符串，struct需要把数据打包为二进制格式,之后保存在文件中

- 文件上下文管理器

  > with允许我们把文件处理代码包装到一个逻辑层中，以确保在退出后可以自动关闭文件，而不依赖垃圾回收的自动关闭

  ```python
  with open(r'c:\data.txt') as myfile:
      for line in myfile:
          # use line
          
  # 等价于
  myfile = open(r'c:\data.txt')
  try:
      for line in myfile:
          # use line
  finally:
      myfile.close()
  ```

- sys、os

- 重访类型分类

  - 对象根据分类来共享操作

  - 只有可变对象可以原处修改，不能修改数字，字符串或元组

  - 集合类似于一个无值的字典键，但是不能映射为值，并且没有顺序，集合不是映射类型或者序列类型，frozenset是集合的不可变版本

  - 分类：

    ![008](D:\project\pycon\Python_学习手册\img\008.JPG)

-  引用VS拷贝

  > 赋值操作总是存储对象的引用，而不是拷贝
  >
  > 赋值操作会产生相同对象的多个引用，在原处修改会影响其他地方对相同对象的引用

  ```python
  X = [1,2,3]
  L = ['a',X,'b']
  D = {'x':X,'y':2}
  X[1] = 'surprise'
  print(L)
  print(D)
  >>>'a', [1, 'surprise', 3], 'b']
  {'x': [1, 'surprise', 3], 'y': 2}
  ```

  - 当确实需要拷贝时，可以明确要求

    - 没有限制的分片表达式（L[:]）能复制序列
    - 字典的copy方法（X.copy()）嫩复制字典
    - 内置函数list,`list(L)` 能生成拷贝
    - copy标准库模块能生成完整拷贝

    > 分片表达式 和 字典的copy方法只能做到顶层复制，不能复制嵌套的数据结构

    - 深层拷贝需要引入copy模块

      ```
      import copy
      # 可完成对任意嵌套对象的完整复制
      x = copy.deepcopy(Y)
      ```

- 比较、相等性和真值

  ```python
  # 两列表虽然相等，但却时不同的对象
  X = [1,2,3]
  Y = [1,2,3]
  print(X == Y,X is Y)
  >>> True False
  ```

  - 相等性

    - '==' 操作符测试值的相等性（递归的比较所有内嵌对象）

    - 'is'  测试对象的一致性 （测试是否为同一对象，也就是是否为同一个内存地址）

      ```python
      a = 'adam'
      b = 'adam'
      print(a==b,a is b)
      >>> True True
      
      # 为了得到更一般的结果我们使用长字符串
      a = 'adam love hh'
      b = 'adam love hh'
      print(a==b,a is b)
      >>> True False
      ```

    - 对于字符串，python 在内部==暂时存储并重复使用段字符串作为最佳化==，字符串较短时，字符串共享内存，

    - ‘==’几乎是所有等值检验会用的操作符， 而 is 则保留了极为特殊的角色

    - 大小比较也能递归的应用于嵌套的数据结构

    - 不同类型比较方法：

      - 数字比较相对大小
      - 字符串安装字典顺序，一个字符接一个字符比较
      - 列表和元组从左到右对每部分比较
      - 字典通过排序后的（键：值）进行比较（3.0不支持）
      - 数字混合类型比较是错误的

    - python3.0的字典比较

      > 当期望相等的时候会导致很多负担

      - 编写循环来比较键值

      - 手动比较排序的（键：值）列表

        - items字典方法
        - 内置的sorted

        ```python
        D1 = {'a':1,'b':2}
        D2 = {'a':1,'b':3}
        D1 == D2
        >>> True
        D1 < D2
        >>> TypeError: '<' not supported between instances of 'dict' and 'dict'
        sorted(D1.items()) < sorted(D2.items())
        >>> True
        ```

    - 真假的含义

      > 真和假时python对象的固有属性，==每个对象不是真就是假==

      - 数字如果非零，则为真
      - 其他对象如果非空，则为真

      > 对象真值的例子

      - ‘spam'      True
      - ''                True
      - []               False
      - {}               False
      - 1                True
      - 0.0             False
      - None         False

      > None 对象

      - None总被认为是假，这是python中一种特殊数据类型的唯一值，是函数的默认返回值
      - None不是未定义，None是某些内容——是一个真正的对象，并且有一块内存

      > boo类型

      - bool扩展了真假的概念，True和False是1和0的定制版本而已
      - bool()函数用来测试一个对象的布尔值

- Python类型层次

  > python系统中的任何东西都是对象类型，可以由python程序来处理

  - type对象

    > 即使是类型本身在python 中也是对象

    - type(x) 返回对象的类型对象

    - 任何对象的类型都是类型为’type‘的对象

    - 按类别组织的python的内置对象类型

      ![009](D:\project\pycon\Python_学习手册\img\009.JPG)

- python中的其他类型

  > 正则表达式、DBM文件、GUI组件、网络套接字等
  >
  > > 这些附带工具和内置类型的区别：内置类型有针对他们的对象的特殊语言生成语法，而在内置模块中使用其他工具则必须先导入才能使用

  - 赋值生成引用而不是拷贝

  - 重复能够增加层次深度

  - 留意循环数据结构

    ```
    a = ['abc']
    a.append(a)
    >>>['abc', [...]]
    ```

    python在对象中检测到循环，都会打印称为 [...] ,而不会陷入无限循环

  - 不可变类型不可在原处改变

  

## 第三部分_语法和语句_

### _第十章_python语句简介

==程序由模块构成，模块由语句构成，语句包含表达式，表达式建立并处理对象==

#### python语句

- python语句集：

| 语句                           | 角色       | 例子                        |
| ------------------------------ | ---------- | --------------------------- |
| 赋值                           | 创建引用值 | a,b,c = 'good','bad','ugly' |
| 调用                           | 执行函数   | log.write('spam')           |
| 打印调用                       | 打印对象   | print('The killer')         |
| if  /  elif  /  else           | 选择动作   | if ’python' in text:        |
| for   /   else                 | 序列循环   |                             |
| while   /   else               | 一般循环   |                             |
| pass                           | 空占位符   |                             |
| break                          | 循环退出   |                             |
| continue                       | 循环继续   |                             |
| def                            | 函数和方法 |                             |
| return                         | 函数结果   |                             |
| yield                          | 生成器函数 |                             |
| global                         | 命名空间   |                             |
| nonlocal                       | 命名空间   |                             |
| import                         | 模块访问   |                             |
| from                           | 属性访问   |                             |
| class                          | 创建对象   |                             |
| try   /   except   /   finally | 捕捉异常   |                             |
| raise                          | 触发异常   |                             |
| assert                         | 调试检查   |                             |
| with   /   as                  | 环境管理器 |                             |
| del                            | 删除引用   |                             |

- 冒号，首行以冒号结尾，下一行嵌套的代码需要缩进

- 括号是可选的

  ```python
  if (x<y):
      pass
  if x<y:
      pass
  ```

- 终止行就是终止语句

- 缩进的结束就是代码块的结束

  - 所谓缩进是指两个嵌套语句至左侧空白的所有空白，python不在乎你怎么缩进，你可以使用任意多个空格或者制表符

- 缩进使得代码统一、整齐并具有可读性，具备了重用性和维护性

- 特殊实例：

  - 语句一般时一行一个，但python也有可能出现某一行挤进多个语句的情况，这时由分号隔开

    ```python
    a = 1；b = 2;print(a+b)
    ```

    - 这是python唯一需要分号的地方——作为语句界定符，放在一起的语句不是 复合语句才行，只能把简单的句子放在一起，例如赋值操作、打印、函数调用

  - ==括号（（）），方括号（[]）,大括号({})==可以让一个语句的范围横跨多行,任何括在符号里的程序代码可以横跨几行

    ```python
    # 连续列表常量
    mlist = [111，
            222，
            333]
    ```

    - 大括号处理字典，圆括号处理元组、函数调用、表达式

    - 连续行的缩进是无所谓的

    - 括号是可以包含一切的（适用复合语句）

      ```python
      if(A == 1 and
        B == 2 and
        C == 3):
          print('spam'*3)
          
      X = (A + B +
          C + D)
      ```

    - 一条老规则允许跨行——当上一行以反斜线结束时，可以在下一行继续(不提倡)

      ```python
      X = A + B +\
          + C + D
      ```

  - 代码块规则特殊实例

    > 嵌套代码块的语句一般都与向右缩进的量有关

    - 特殊实例

      > 复合语句的主体可以出现在python的首行冒号之后
      >
      > - 只有简单的语句可以跟在冒号之后：赋值、打印、函数调用等
      > - 复合语句的附带部分必须放在自己的行里（例如if的else部分，使用逗号分开）

      ```
      if x > y: print(x)
      ```

- 简单实例

  ```python
  # 简单的交互循环
  while True:
      reply = input('Enter text:')
      if reply == 'stop': break
      print(reply.upper())
      
  # python 会执行首次测试为真所匹配的代码块
  while True:
      reply = input('enter text:')
      if reply == 'stop':
          break
      elif not reply.isdigit():
          print('bad' * 8)
      else:
          print(int(reply) * 2)
  print('Bye')
  ```

  - python 会先执行try
    - 如果有异常发生就执行except部分
    - 如果没有异常发生就执行else部分
  - 多层嵌套



### 第十一章_赋值、表达式和打印

#### 赋值语句

- 赋值语句建立对象引用值
- 变量名在首次赋值时会被创建
- 变量名在引用前必须先赋值
  - 使用尚未赋值的变量会引发异常
- 执行隐式赋值的操作
  - 模块导入、函数和类的定义、for循环变量、函数参数（在运行时将把变量名和对象引用值绑定起来）

#### 赋值语句形式

- spam = 'spam'                             基本形式

- spam,ham = 'yum','YUM'           元组赋值运算

- [spam,ham] = ['yum','YUM']      列表赋值运算

- a,b,c,d = 'spam'                            序列赋值

- a,*b = 'spam'                                序列解包

- spam = ham = 'lunch'                 多目标赋值

- spams += 11                                增强赋值运算

  

- 高级赋值

  ```python
  ((a,b),c) = ('sp','am')
  a,b,c
  >>>('s','p','am)
  
  # 循环赋值
  for (a,b,c) in [(1,2,3),(4,5,6)]:
      pass
      
  # 序列解包赋值语句(赋值一系列整数给一组变量)
  red,green,blue = range(3)
  
  L= [1,2,3,4]
  while L:
      front,L = L[0],L[1:]
      print(front,L)
  >>>1 [2, 3, 4]
  2 [3, 4]
  3 [4]
  4 []
  ```

- 扩展序列解包

  > 一个带有单个星号的名称，可以在赋值目标中使用，以指定对于序列的一个更为通用的匹配

  > 序列赋值通常要求左边的目标名称数目与右边主体的项数对应，长度不同，将会报错

  > 我们可以在目标中使用带单个星号的名称来更通用的匹配
  >
  > - 不管星号出现在哪里，包含该位置的每个未赋值元素列表都会赋给它

  ```python
  # 正确操作
  a,b,c,d = [1,2,3,4]
  # 错误操作
  a,b = [1,2,3,4]
  # 星号操作
  a,*b = [1,2,3,4]
  ```

- 边界情况

  - 带星号的名称可能只匹配带个项，但总时赋值一个列表

  - 如果没有内容匹配带星号的名称，会赋值一个空列表

  - 有多个带星号的名称、值少了而没有带星号的名称、带星号的名称没有编写到列表中 都会报错

    ```
    # 错误用法
    a,*b,c,*d = [1,2,3,4]
    a,b = [1,2,3,4]
    *a = sep
    # 正确用法
    *a, = [1,2,3,4]
    ```

    ==*a，= [1,2,3,4]== 生成一个列表，等价于`a = [1,2,3,4]`

- for循环

  ```python
  for (a,*b,c) in [(1,2,3,4),(5,6,7,8)]:
      pass
  ```

- 多目标赋值语句

  ```
  a = b = c = 'spam'
  ```

  - 多目标赋值和共享引用

    > 一个对象由多个变量共享，

    ```
    # 修改b只会对b修改，数字不支持原处修改
    a = b = 0
    b = b + 1
    a,b
    >>>(0,1)
    # 当把变量初始值设为可变对象时,由于引用相同对象，两个变量都会改变
    a = b = []
    b.append(1)
    a,b
    >>>([1],[1])
    ```

- 增强赋值语句

  - x += y
  - x -= y
  - x *= y
  - x /= y
  - x %= y
  - x $= y
  - x ^= y
  - x <<= y
  - x >>= y
  - x **= y
  - x //= y
  - x |= y

  > 优势：
  >
  > - 输入减少
  >
  > - x可以是复杂对象表达式，增强形式中，则只需==计算一次==（x = x + y中，x出现两次，必须执行两次），增强赋值执行更快
  >
  > - 优化技术自动选择，对于支持原处修改的对象而言，增强赋值会自动执行原处修改，而不是相比慢速的复制
  >
  > - 使用增强语句来扩展列表，python会自动调用较快的extend而不是较慢的  + 操作
  >
  >   ```
  >   L += [9,10]     # mapped to L.extend([9.10])
  >   ```

- 增强赋值及共享引用

  > - += 对列表是原处修改
  >
  > - \+ 对列表生成新对象
  >
  >   ```
  >   # + 操作，生成新对象
  >   L = [1,2]
  >   M = L
  >   L = L + [3,4]
  >   L,M
  >   >>>([1, 2, 3, 4], [1, 2])
  >   # +=对列表是原处修改
  >   L = [1,2]
  >   M = L
  >   L += [3,4]
  >   L,M
  >   >>>([1, 2, 3, 4], [1, 2, 3, 4])
  >   ```

  - 这种对于列表和字典这类可变对象才重要

- 变量命名规则

  > python中，为变量名赋值时，变量名就会存在，程序选择变量名时，要遵循如下规则：
  >
  > - 语法：下划线或字母 +任意数据的字母、数字、下划线
  >   - 变量名必须以==下划线或字母开头==，后面接任意数目==字母、数字或下划线==
  >   - 区分大小写
  >   - 禁止使用保留字

  - python保留字

    ```
    False、class、finally、is、return、None、continue、for、lambda、try、True、def、from、nonlocal、while、and、del、global、not、with、as、elif、if、or、yield、assert、else、import、pass、break、except、in、raise
    ```

  - import 语句中的模块变量名会变成脚本中的变量，这种限制也会扩展到模块的文件名

    > 你可以写and.py 和 my-code.py这类文件，但是你无法将其导入
    >
    > - 保留字是禁区
    > - 破折号不行

    ```
    improt my-code.py
      File "<stdin>", line 1
        import my-coce
                 ^
    SyntaxError: invalid syntax
    ```

- 命名惯例

  > 非必要规则，一般都会遵守

  - 以单一下划线开头的变量名（_X）不会被from module import * 导入
  - 前后由下划线的变量名（\_X\_）是系统定义的变量名，对解释器有特殊意义
  - 以两个下划线开头（__X）
  - 通过交互模式与运行时，只有单个下划线的变量名（_）会保存最后表达式的结果
  - 类变量名通常以一个大写字母开头，模块变量名以小写字母开头

- 变量名没有类型，但对象有

#### 表达式语句

> 表达式的结果不会存储

- spam(eggs, ham)       函数调用
- spam.ham(eggs)        方法调用
- spam                           交互模式打印变量
- print(a,b,c)                  打印
- yield x**2                   产生表达式语句

#### 表达式语句和原处修改

```
L = [1,2]
L.append(3)
L
>>>[1,2,3]
L = L.append(3)
L
>>>None
```

- 对列表调用append,sort,reverse 这类原处修改的运算，使用这些方法修改后不会把列表返回，事实上返回None对象
- 如果赋值这类运算的结果给该变量的变量名，只会丢失该列表（可能被当成垃圾回收）

#### 打印操作

- print是对程序员友好的标准输出接口

- python3中，打印是一个函数

  - print(obj,sep='',end='',file=sys.stdout)

  - file指定了文本将要发送的文件，标准流或者其他类似的文件对象

    - 带有一个类似文件的write(string)方法的任何对象都可传递，但真正的文件应该已经为输出而打开

    ```python
    # C:\Users\Dell\Desktop>python
    print('hello',file=open('test.txt','w'))
    # 输出 hello 的txt文件到桌面
    ```

#### 打印流重定向

> 打印都默认的发送到标准输出流，发送到其他地方也是有用的，例如文本文件，可以保存结果，供以后测试使用
>
> - 重定向也可以在shell中实现

```python
print('hello world')           # python3
print 'hello world'            # python2.6
```

- print 语句是python 人性化的特性，提供 sys.stdout的接口

- 使用sys.stdout

  ```python
  import sys
  sys.stdout.write('hello world\n')
  ```

- 重定向输出流

  - print和stdout的关系

    ```python
    print(x,y) 
    # 等价于
    import sys
    sys.stdout.write(str(x)+''+str(y)+'\n')
    
    # 这里强调打印的友好性
    ```

  - 这种等效的方式提供了一种方法，让print语句将文字传送到其他地方

    ```python
    import sys
    sys.stdout = open('log.txt','a')
    print('hello world')
    ```

    - 这里我们把sys.stdout重设为打开的文件（采用附加模式），程序中的任何打印都会写至文件末尾
    - 可以将sys.stdout设为非文件对象，只要对象有预期的write协议

- 自动化流重定向

  - sys.stdout是一个普通的文件对象，你可以存储它，需要时恢复

    ```python
    import sys
    temp = sys.stdout
    print(temp)
    >>> <_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>
    sys.stdout = open('log.txt','a')
    print('haha')
    sys.stdout = temp
    print('haha')
    >>>haha
    ```

    - python3中，file关键字允许一个单个的print调用将文本发送到文件的write方法，这种重定向是暂时的

      

### 第十二章_if测试和语法规则

- if语句用于选取要执行的操作，python中主要的选择工具

- 后面跟着多个可选的elif以及一个最终可选的else

- python会执行第一个结果为真的代码块，或者所有的测试为假，就执行else块

  ```python
  if test:
      <statements1>
  elif test2:
      <statements2>
  else:
      <statements3>
  ```

语法规则：

- 语句是逐个运行的
- 块和语句的边界会自动检测
- 复合语句=首行+“：”+缩进语句
- 空白行、空格以及注释都会忽略
- 文档字符串会忽略，但会保存并由工具显示
  - docstring,和#注释不同，文档字符串会在运行时保留下来以便查看，

代码块分隔符：

- 自动以缩进检测块的边界，快内的语句会垂直对齐，遇到缩进量少的行退出

语句分隔符：

- 使用语法括号对，语句就可以横跨数行——（）[] {} 这类配对中

- 语句以反斜线结束，可以横跨数行

  > 比较过时的功能，如果需要横跨数行，就在前一行末尾加上反斜线  \

- 三重引号可以横跨多行

- 可以用分号终止语句：这种惯例有时用于把一个简单的语句挤进单个行中

- 注释可以出现在任意地方

特殊情况：

```python
# 括号让行保持连续
L = ['good',
    'bad',
    'ugly']
# \
if a == b and c == d and \
    d == e and e == f:
        pass
# 括号
if (a == b and c == d and 
   d == e and e == f):
    pass

```

- 同一行编写多个非复合语句，以分号隔开

  ```
  x = 1; y = 2; print(x)
  ```

- 三重引号

  ```python
  s = '''
  aaaa
  bbbb
  cccc'''
  # 相邻的字符串常量时隐式的连接起来的
  s = ('aaaa'
      'bbbb'
      'cccc')
  ```

- 真值测试

  - 任何非零数字和非空对象都为真

  - 数字零、空对象以及特殊对象None都被认为是假

  - 比较和相等测试会递归的应用在数据结构中

  - 比较和相等测试会返回True或False(0\1的特殊版本)

  - 布尔and \or会返回真或假的操作对象

    - and
    - or
    - not

    > 比较会返回True\False作为结果
    >
    > and \or 返回对象（每个对象本质上不是真就是假）

    > 对于or测试，python从左至右求算，返回第一个为真的对象（python会在其找到第一个真值操作数的地方停止——短路计算）

    ```python
    2 or 3, 3 or 2
    >>>(2,3)
    [] or 3
    >>> 3
    # 左边的为假，python只会计算右边的数并将其返回（可能为真或假）
    [] or {}
    >>>{}
    ```

  - 在结果知道时，and也会停止,从左至右计算，停在第一个为假的对象上

    ```
    []  and {}
    >>>[]
    2 and 3
    >>> 3
    3 and 2
    >>>2
    ```

if /else 三元表达式

```python
if X:
    A = Y
else:
    A = Z

# 等价于
A = Y if X else Z

# bool函数会把X转换为对应的0或1
A = [Y,Z][bool(X)]
```



### 第十三章_while和for循环

> while 提供了编写通用循环的一种方法，for语句用来遍历序列对象内的元素
>
> break、Continue
>
> 常用内置函数range、zip、map
>
> 重复操作的主要语法:while、for、迭代、列表解析
>
> 奇特迭代工具：生成器、filter、reduce

- while 循环

  > 只要顶端测试一直为真，就会重复执行一个语句块，控制权会持续返回到语句的开头部分，直到测试为假，控制权会传给while块后的语句

  ```python
  while test:
      <statements1>
  else:
      <statements2>
  ```

  - break、continue、pass、else

    > 只有嵌套在循环中才起作用，break和continue
    >
    > else和break关联在一起
    >
    > pass空占位语句

    - break:跳出最近循环（整个循环语句）
    - continue：跳到最近循环的开头，来到循环的首行
    - pass:空占位语句
    - else块：只有当循环正常离开时才会执行（也就是没碰到break语句）

  - 一般循环格式

    ```
    while test1:
        <statements1>               
        if test2:break              # exit loop now,skip else
        if test3:continue           # go to top of loop now,to test
    else:
        <statements2>               # run if we 
    ```

    - pass

      > 语法需要语句还没有任何实用的语句时就用pass

      ```
      while Ture : pass
      def fun():
          pass
      ```

      - python 3允许使用 ... (三个连续点来省略代码)，可以当作是pass的一种替代方案

        ```:
        def fun(): ...
        
        def fun():
            ...
        
        # 省略号可以和语句出现在同一行，可以用来初始化变量名
        a = ...
        >>> a
        Ellipsis
        ```

    - continue

      > 语句会立即跳到循环的顶端

    - break

      > 语句会立刻离开循环，位于其后的循环代码都不会执行

    - 循环else

      > 如果==主体从没有执行过，else分句会执行==，while循环中，如果首行的测试一开始就为假，就会 出现这种问题

      ```
      a = 1
      while a> 10:
          if a  == 9:
              print(a)
              break
          a += 1
      else:
          print('a')
      >a
      ```

- for 循环

  - for循环中的元组赋值

    > 如果迭代元组序列，循环目标本身可以是元组，这是元组解包的赋值运算

    ```
    T = [(1,2), (3, 4), (5, 6)]
    for (a,b) in T:
        print(a,b)
    ```

  - for循环中的元组使得用items方法来遍历字典中的键和值和方便

    ```
    D = {'a': 1, 'b': 2, 'c': 3}
    for key in D:
        print(key, '==>', D[key])
    
    for (key, value) in D.items():
        print(key, '==>', value)
    
    # for 之后的任何赋值目标在语法上都是有效的
    for both in T:
        a,b = both
        print(a,b)
    
    for ((a, b), c) in [((1, 2), 3),((4, 5), 6)]:
        print(a,b,c)
    ```

  - python3在for循环中扩展的序列赋值

    - 一个序列可以赋值给一组更为通用的名称（一个带有星号的名称收集多个元素），我们可以在for循环中使用同样的语法提取嵌套的序列

      ```
      for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
          print(a, b, c)
      >1 [2, 3] 4
       5 [6, 7] 8
      ```

  - 编写循环技巧
    - for比while容易写，执行快速
    - python提供了两个内置函数，在循环内定制迭代
      - range返回一系列连续增加的数，可以作为for中的索引
      - 内置zip函数返回并行元素的元组的列表，可用于在for中遍历数个序列
  - pg383

  

































































































### 第十四章_迭代器和解析（第一部分）

### 第十五章_文档

## 第四部分_函数

### 第十六章_函数基础

### 第十七章_作用域

### 第十八章_参数

### 第十九章_函数的高级话题

### 第二十章_迭代和解析（第二部分）

## 第五部分_模块

### 第二十一章_模块：宏伟蓝图

### 第二十二章_模块代码编写基础

### 第二十三章_模块包

### 第二十四章_高级模块话题

## 第六部分_类和OOP

### 第二十五章_OOP:宏伟蓝图

### 第二十六章_类代码编写基础

### 第二十七章_更多实例

### 第二十八章_类代码编写细节

### 第二十九章_运算符重载

### 第三十章_类的设计

### 第三十一章_类的高级主题

## 第七章_异常和工具

### 第三十二章_异常基础

### 第三十三章_异常编码细节

### 第三十四章_异常对象

### 第三十五章_异常的设计


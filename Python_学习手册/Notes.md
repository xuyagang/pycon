[TOC]

# 《Python学习手册》

本书覆盖python3.0和2.6，实例中使用3.0的print,介绍2.6语法，我的练习中使用3.0语法。

每章节和每部分后面都用练习题，解答在书的附录B中。



## 第一部分_使用入门

### 第一章_Python 如何运行

#### 1.1 为什么用python

- python注重可读性、一致性和软件质量
- 提高了效率，是c++或者Java的1/5~1/3，无需编译，可立即运行
- 可在所有主流计算机平台上快速移植代码
- 内置多种预编译并可移植模块
- 可以与应用程序的其他部分通信，是产品定制和扩展的工具

#### 1.2 python可定义为面对对象的脚本语言

- 脚本：倾向描述简单的顶层代码
  - 脚本语言可以理解为应用于快速编程任务的简单语言
- 程序：描述相对复杂的多文件应用

#### 1.3 python 的缺点

- 执行速度不够快
- python标准格式-->字节码--->解释字节码
  - 字节码是一种无关平台的格式，具有可移植性
  - 因为没有将代码编译成二进制码，python程序会比像C这样的完全编译语言慢

#### 1.4 python可以做什么？

- 从网站和游戏开发到航天飞机的控制
  - 系统编程
  - 用户图形接口
    - 内置了TKinter
  - internet脚本
  - 组件集成
  - 数据库编程
  - 数值计算和科学计算
  - 游戏、图像、人工智能、XML、机器人

#### 1.5 谁在用？

- youtube视频分享服务
- EVE Online大型多人游戏
- Maya提供了python编程API
- ...



### 第二章_python如何运行程序

- 解释器是代码与机器硬件之间的软件逻辑层
  - 解释器是_让python程序运行起来的程序_
- __.pyc__文件就是编译过的__.py__文件
  - 如果python在机器上有写入权限，程序运行后会在源码同目录下看到.pyc文件
  - 如果运行后源码未修改，下次运行直接加载.pyc文件，跳过编译步骤
  - 必须重新编译时，python会检查源文件和字节码文件的时间戳
- 程序编译为字节码后会发送到python虚拟机（PVM）
  - PVM是python的运行引擎，不是程序，无需安装，是所谓“python解释器”的最后一步

![000](D:\project\pycon\Python_学习手册\img\001.JPG)

- python语言三种主要的实现方式
  - Cpython:标准的的python实现方式
  - Jython：为了与Java集成，包含了java类
    - 让python代码能够脚本化java程序
  - IronPython：让python可以与win平台上的.NET框架和Linux上开源的Mono编写成的应用集成
- 冻结二进制文件/__Frozen Binary__
  - 用python程序生成的__独立的可执行二进制代码__
  - 简单来说就是：将python程序转为可执行程序
    - Frozen Binary 将程序的字节码，PVM以及任何程序所需要的python支持文件捆绑在一起，形成一个单独的文件包---可执行二进制程序（类似win平台的 .exe文件）
- 生成方式：
  - py2exe——win下使用
  - PyInstaller——在Linux和UNIX上使用



### 第三章_如何运行程序

- 交互提示模式运行代码

  - 在for循环和if中，用一个空行结束多行符合语句，需要按下两次Enter

- python file.py             运行file文件，在命令窗口输出结果

- python file.py > result.txt     输出结果到result.txt文件中，命令窗口不显示
  - 叫做__流重定向__(stream redirection),用于文本的输入和输出，保存起来以备查看使用
  - shell重定向方法，与python无关，只是python支持而已
    - C:\Users\Dell\Desktop>python aa.py > d:\aa.txt         （在桌面运行并输出结果到d盘）

- 模块导入和重载

  - 每一个.py文件都是 一个模块，可以导入一个模块来读取模块的内容

  - 模块通过这样的属性被外部使用

  - 大型程序有多个模块文件组成，其中一个文件设计成主文件（==顶层文件==：就是启动后运行整个程序的文件）

  - 导入工作只在第一次运行，第一次导入后，之后的导入都不会再工作，甚至改变并保存了模块源代码也不行

  - 导入开销很大，每个文件和程序运行不能重复多于一次

  - 导入必须找到文件并将其编译成字节码之后运行

  - 如果非要在同一会话（不停止和重启会话）再次运行文件，需要调用imp模块中的reload函数

    - ```python
      #  the imp module is deprecated in favour of importlib
      from imp import reload
      reload(script1)
      ```

  - reload函数希望获得的参数是一个已经加载了的模块对象名称

  - reload需要加括号，import 不需要（reload是被调用的函数，import是语句）

- 模块的属性

  - 模块是变量名的封装，被认为是命名空间，包中的变量就是所谓的属性

  - 属性就是绑定在特定对象（比如模块）上的变量名

  - 模块变量名可通过一下语句读取：

    - import
    - from
    - reload调用

  - ```python
    # 我们已有文件test.py
    	# 内容：content = ‘The Meaning of Life'
    # 方式一：grab the whole module
    import test
    test.content
    # 方式二：copy myltiple names
    from test import content
    content
    ```

  - 以上结果相同，from和import类似，from增加了对载入组件的额外赋值（content=test.content）

    - 使用from会获取文件变量的==复本==,可使用__dir()__函数查看
    - 使用import会把文件生成到一个单独的模块名称空间中，所付出的代价就是代码修改后运行需要__重载__

  - 每个模块是一个独立完备的变量包，即一个命名空间，一个模块看不到其他文件的变量名（除非显示的导入），模块在代码文件中起到了==最小化命名冲突==的作用

  - from把变量从一个文件复制到另外文件中，可能会导致相同名称的变量被覆盖（不会给出警告）

  - reload 不可传递，重载一个模块不会重载该模块导入的任何模块，因此有时需要reload多个文件

- 使用exec()运行模块文件

  - ```python
    exec(open('test.py').read())
    ```

- IDLE用户界面

  - 提供了python开发的图形界面，是使用TKinter GUI开发出来，可以在几乎任何python平台使用。

- 嵌入式调用

  - 在一些特定的领域，python代码会在一个封闭的系统中运行
  - 这样的嵌入式执行模式一般支持终端用户定制，用户可修改python代码（==python代码是解释性的，不必重新编译==）

- 总结：

  - 在系统平台终端命令行的地方运行一个脚本文件，也可通过导入、重载、exec()、IDLE的run等运行脚本



## 第二部分_类型和运算

### 第四章_python对象类型

python程序：==程序==由模块组成，==模块==包含语句，==语句==包含表达式，==表达==式建立并处理对象

#### 4.1 为什么使用内置类型

- 内置类型使程序容易编写
- 内置类型是扩展的组件
- 内置比定制的更有效率
- 内置对象是语言标准的一部分

#### 4.2 核心数据类型

- 数字
- 字符串
- 列表
- 元组
- 字典
- 集合
- 文件
- 其他：None、Bool
- 编程单元：函数、模块、类

以上并不完整，python章每样东西都是一种对象

- python中没有类型声明，运行表达式的语法决定了对象的类型，对象一旦创建就和操作集合绑定了（对字符串只可进行字符串相关操作）
  - 动态语言：自动跟踪类型而不是要求声明
  - 强类型语言：只能对一个对象进行适合该类型的语言
- 寻求帮助：
  - dir()
  - help()

___

- python核心数据名称：数字，字符串，列表，元祖，姐，字典，文件，
  - 多种数字类型：整数，浮点，复数，分数，十进制数
  - “核心”是因为他们是python语言的一部分，大多数都有特定的语法去生成他们，
- 一个具有不可变性的对象是一个__创建后不能够改变的对象__，python中的__数字、字符串和元祖__属于这个分类，尽管无法就地改变，但总可以通过运行一个表达式创建一个 新的对象
- 一个__序列__是一个_对位置进行排序的对象的集合_,字符串、列表、元祖是python中的所有的序列，他们拥有一般的序列操作（索引、切片、合并），但又有自己类型的特定方法
- __映射__表示将键和相关值相互关联的对象，字典是核心类型中唯一的映射类型。映射没有从左至右的位置顺序，支持通过键获取数据，并包含了特定的方法
- __多态__是指一个操作符（如 +）的意义取决于被操作的对象，这是python的关键思想：==不要把代码限制在特定的类型上，是代码自动适用于多种类型==



### 第五章_数字

在python中数据采用了对象的形式，无论是内置对象还是用python的工具创建的对象。

- 在python中，数字并不是一个真正的对象类型，而是__一组类似类型的分类__，数字类型完整工具包括：
  - 整数和浮点数
  - 复数
  - 固定精度的十进制
  - 有理分数
  - 集合
  - 布尔类型
  - 无穷的整数精度
  - 各种内置的函数和模块

#### 5.1 数字常量

- python提供整数（正整数和负整数）和浮点数，允许使用十六进制，八进制和二进制常量表示整数，提供复数类型，允许整数具有无穷的精度
  - 十六进制：以ox或OX开头，后接16进制数0-9，A-F
  - 八进制：0o或0O，后接0-7数
  - 二进制：0b或0B开头，后接0-1
  - 整数转为对象字符串
    - hex(int)
    - oct(int)
    - bin(int）
  - 给定进制字符串转为整数
    - int(str,base)
  - 复数
    - 复数写成实部+虚部，虚部以J或j结尾
    - 也可用内置的complex(real,imag)创建复数

#### 5.2 表达式操作符

- 表达式是处理数字的基本工具，表达式通常使用_数学符号_和_操作符_写出来

- 操作符：

  - yield x                                          生成器函数发送协议
    - 返回生成器中的send(...)参数
  - lambda  args: expression         生成匿名函数
  - x if y else z                                  三元选择表达式
  - x   or  y                                         逻辑或（只有x为假，才会计算y）
  - x   and  y                                      逻辑与（只有x为真，才会计算y)
  - not  x                                            逻辑非
  - in， not  in                                   成员关系
  - is,  is not                                       对象实体测试
  - <,<=,>,>=，==，！=                     大小比较，相等性
  - x | y                                               位或，并集
  - x ^ y                                               位异或，集合对称差
  - x & y                                              位与，交集
  - x << y , x>> y                                 左移/右移y位
  - +，-，*，/                                     加减乘除
  - x % y                                              ==余数==/格式化
  - x // y                                               floor 除法（==整除==）
  - -x,+x                                                一元操作
  - ~x                                                    按位取反
  - x**y                                                幂运算
  - x[i]                                                  索引
  - x[i:j:k]                                             分片
    - 等同于 x[slice(I,J,K)]
  - x(...)                                                 调用函数、方法、其他可调用类型
  - x.attr                                               属性引用
  - （...）                                              元组，表达式，生成器表达式
  - [...]                                                   列表，列表解析
  - {...}                                                   字典、集合、集合和字典解析

- 操作符优先级

  - 上表中越靠后的优先级越高
  - 比较运算和表达式通常从左到右组合，幂运算是从右到左组合
  - 如果用用括号对表达式的各部分进行分组，就可以忽略优先级的事情了
    - 使用括号划分子表达式的时候，python总是会先计算括号中的表达式，然后将结果用于整个表达式中
  - 混合类型自动升级
    - 表达式中能混合数字类型（整数和浮点数相加）
    - 混合类型中，python首先==将操作对象转换为其中最复杂的操作对象类型==，然后运算
    - python中：整数比浮点数简单，浮点数比复数简单
    - 混合操作类型仅仅在数字类型混合到一个表达式中适用

- 变量和基本表达式

  - 变量在第一次赋值时创建
  - 变量在表达式中使用将会被替换为它的值
  - 变量在表达式中使用前必须已赋值
  - 变量不需要预先声明，但要赋值一次

- 数字显示的格式

  - 由于浮点数的硬件限制，无法准确显示一些值

  - ```python
    num = 1/3
    '%e' % num		# string formatting expression
    >>> 3.333333e-01
    '%4.2f' %num
    >>> 0.33
    '0:4.2f'.format(num)
    >>> 0.33
    ```

  - str 和repr 的显示格式

    - 默认的交互模式回显和打印的区别相当于repr和str函数的区别
      - repr:产生的结果看起来像代码（__额外细节__）
      - str:用户友好模式(__一般用途__)
        - 除了为任意对象打印字符串，str内置函数也是字符串类型的名字

- 比较

  - 一般的和连续的

  - 除了正常的大小值比较，python允许我们把多个比较连续起来执行==范围测试==

    - 例：

    - ```python
      # 测试B是否在A和C之间
      A < B < C			
      # 等同于
      A < B and B < C
      
      # 第一个简单便于使用，并且B值计算一次，速度要快一些
      ```

- 除法：

  - x/y	真除法

  - x//y       整除法（floor）

    - 截断除法：真正结果之下的最近整数

  - ```python
    >>> 10//4
    2
    >>> 10//4.0
    2.0
    # 操作数中有一个是浮点数，结果就是浮点数，否则结果是整数
    ```

- 整数精度

  - python3支持整数的无穷大小，实际中，长整数的运算比正常整数慢，以性能换精度

- 复数

  - 表示为两个浮点数（实部和虚部）并在虚部增加了J/j的后缀
  - 复数允许我们分解它的是实部和虚部作为属性
  - 可通过标准的cmath模块处理

- 十六进制/八进制/二进制

  - oct()

  - hex()

  - bin()

  - int(str,base)     将数字的字符串变换为整数

  - eval()                 将字符串作为python代码

    - ```python
      eval('0b1000000')
      eval('0x40')
      ```

    - 

  - ```python
    # 字符串格式化方法调用和表达式将一个整数转为八、十六、二进制
    '{0:o},{1:x},{2:b}'.format(64,64,64)
    ```

- 位操作

  按位运算符是把数字看作二进制来进行计算的

  ```
  x = 1
  x << 2
  # 表达式中二进制数1（0001）左移了两位（0100）成为4
  ```

  - python支持C语言中大多数数学表达式
    - 包括把整数当作二进制位串的操作
    - 二进制与 &：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
    - 二进制或 | ：只要对应的二个二进位有一个为1时，结果位就为1
    - 异或  ^  :当两对应的二进位相异时，结果为1
    - 按位去反 ~ ：对数据的每个二进制位取反,即把1变为0,把0变为1
    - 左移动运算符  <<  ：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0
    - 右移动运算符  >> ：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数

    > a,b两数相差1，转换为二进制数后, a & b会抹去a最右边的1

     

    

- 其他内置数学工具

  - pow
  - abs
  - math 模块
    - math.pi
    - math.e
    - sin、sqrt、pow、abs、min、floor、trunc、round、
      - 求解sqrt
        - math.sqrt
        - 144**0.5
        - pow(144,0.5)
  - random模块

- 其他数字类型

  ---

  - 小数数字
    - 浮点数学缺乏精确性，因为用来存储数值的空间有限
    - 与硬件相关的浮点数运算在精度方面有内在缺陷

  - decimal 模块

  - 设置全局精度

    - ```python
      import decimal
      decimal.getcontext().prec = 4
      ```

  - 小数上下文管理

    - 使用上下文管理语句来设置临时精度,语句退出后恢复初始值

      - ```python
        import decimal
        with decimal.localcontext() as ctx:
        	ctx.prec = 2
            # expression
        ```

---

- 分数

  - python引入了数字类型——分数，实现了一个有理数对象，避免了浮点数的不精确性和局限性

  - 分数是小数的近亲，都可以通过固定小数位和指定舍入或截断来控制精度

  - fractions模块

  - ```python
    from fractions import Fraction
    x = Fraction(1,3)
    print(x)    # Fraction(1,3)
    ```

    - 一旦创建了分数，就可以用于数学表达式

    - 也可以从小数来创建分数

    - ```python
      Fraction('025')
      ```

  - 数值精度

    - 分数和小数提供了精确的结果，付出了速度的代价

    - 分数和小数能提供比浮点数直观准确的结果

      - 分数保持精确性，并自动简化结果

        - ```python
          from fractions import Fraction
          >>> Fraction(6/12)
          Fraction(1, 2)
          ```

  - 转换和混合类型

    - 浮点数有一个方法，能够产生他们的分子分母比

    - 分数有一个from_float方法，并且接受一个Fraction作为参数

      - ```
        >>> (2.5).as_integer_ratio()
        (5, 2)
        ```


#### 5.3 集合

- set : 唯一的、不可变的对象的无序集合，一个项只能出现一次

- 可迭代的，可增长和缩短，能包含各种对象类型

- 既不是序列也不是映射类型

- python 中{}是一个字典，空的集合必须由set来创建

- 集合只能包含不可变的（可散列的）对象

  - 列表和字典不能嵌入到集合中
  - 需要存储符合值的话，元祖是可以嵌入的
  - 集合本身是可变的，不能嵌入到其他集合中

- 需要在另外一个集合中存储一个集合，可以调用frozenset,它创建一个不可变的集合，不可修改且可嵌入其他集合

- 集合解析

  - ```python
    {x**2 for x in [1,2,3,4]}
    # 循环在右边，集合表达式在左边
    ```

- 为什么使用集合

  - 集合中项只能存在一次，可用来去重（转换为set,在转换回来）

    - ```
      L = [1,2,3,1,2,4,5]
      L = list(set(L))
      ```

  - 在遍历或循环结构中可用来记录已经访问过的位置

  - 集合的交集包含了共有对象，并集包含所有项目

- 布尔型

  - bool原本是一个数字，有True和False，不过是整数1和0以不同形式显示后的定制版而已

  - True和False的行为与1和0 的是一样的，有特定的显示逻辑

  - 可将True和False看作预定义的设置为1和0的变量

    - True是定制了显示格式的整数1

    

### 第六章_动态类型简介

动态类型的多态性是其语言简洁灵活的基础

- python中类型是在运行过程中自动决定的，而不是通过代码声明

- 变量、对象、引用

  - 变量创建：给一个变量赋值，之后的赋值会改变已经创建变量名的值（__最初的赋值创建变量__）
  - 变量类型：类型的概念存在与对象中而不是变量名中，变量是通用的，只是在特定的时间点引用了特定的对象而已
  - 变量使用
    - 变量出现在表达式中，马上会被替换成其引用的对象
    - 变量必须在使用前明确的赋值，使用未赋值的变量会产生错误

  ==变量在赋值的时候创建，可以引用任何类型对象，必须在引用前赋值==

```
a = 3
# 1.创建一个对象来代表3
# 2.创建一个变量a,如果还没创建的话
# 3.将变量与对象3相连接
```

- 运行a=3后，变量a变成对象3的引用，事实上在内部==变量是到内存空间的一个指针==

- 总结

  - 变量是一个系统表的元素，拥有指向对象的连接空间
  - 对象是分配的一块内存，有足够的空间表示所代表的值
  - 引用是自动形成的从变量到对象的指针

- 对象的垃圾回收

  ```
  a = 3
  a = 'spam'
  # 给a第二次赋值时，对象3发生了什么变化
  ```

  - 每当一个变量名被赋予一个新的对象，之前那个对象占用的空间会被回收（如果它没有被其他变量名或对象引用的话）---这种自动回收对象空间的技术叫垃圾收集
  - 在内部，python为每个对象保持了一个计数器，用于记录当前指向该对象的引用的数目，一旦这个计数器被设置为0，这个对象的内存空间就会自动回收

- 共享引用

  ```python
  a = 3
  b = a
  # 运行b=a后，b成为对象3的一个引用
  ```

  ![001](D:\project\pycon\Python_学习手册\img\000.JPG)
  ```
  a = 3
  b = a
  a = 'spam'
  # b仍然引用原始的对象 3
  ```

  ![002](D:\project\pycon\Python_学习手册\img\002.JPG)
  ==给一个变量赋一个新的值，并不是替换了原始的对象，而是让变量引用不同的对象==

- 共享引用和原处修改

  - 有些对象操作会在原处改变对象，而不是生成一个新的对象

  - 对于这种支持原处修改的对象，共享引用时需小心（__因为对一个变量名的修改会影响其他变量__）

    - ```
      L1 = [1,2,3]
      L2 = L1
      # L1和L2都引用了相同的对象
      L1[0] = 11
      >>>L2 = [11,2,3]
      # 改变了L1引用对象的一个元素，修改会覆盖列表
      ```

  - 如果==不想原处修改==，需要python的拷贝对象

    - 内置列表函数和copy模块

      - 列表从头到尾的切片

      - ```
        L1 = [2,3,4]
        L2 = L1[:]
        # L1的修改不会影响L2
        ```

        - L2引用的是L1的拷贝，两个变量指向了不同的对象（内存区域）
        - 分片技术不会应用到集合和字典，他们不是序列

      - 复制一个字典和集合应使用X.copy()

        - copy模块有一个通用的复制任意对象的调用

        - 也有一个拷贝嵌套对象结构的调用

          - ```
            import copy
            x = copy.copy()
            x = copy.deepcopy()
            ```

- 共享引用和相等

  - ==：测试两个被引用的对象是否有相同的值

  - is : 检查对象的同一性

    - 事实上is只是比较引用的指针（也等价与是代码检测共享的一种方式）

    ```python
    L = [1,2,3]
    M = [1,2,3]
    a = '123'
    b = '123'
    i = 123
    j = 123
    
    print(L==M,a==b,i==j)
    >>>True True True
    print(L is M,a is b, i is j)
    >>False True True
    ```

    - ==因为小的整数和字符串被复用了，所以is告诉我们a is b 和 i is j 是True(是相同的对象)==

  - 查询对象的引用次数

    - 在sys模块中的getrefcount函数会返回对象的引用次数

      ```
      import sys
      sys.getrefcount(1)
      # 绝大多数idle系统代码所使用
      >>> 2035
      ```

      

### 第七章_字符串

字符串为不可变序列，意味着字符串所包含的字符存在从左至右的位置顺序，不可以再原处修改

![003](D:\project\pycon\Python_学习手册\img\003.JPG)

- 字符串常量

  - 单引号：'spam'
  - 双引号：'spa'm'
  - 三引号：'''...spam...''',"""...spam..."""
  - 转义字符：“s\tp\na\0m”
  - Raw字符串：r"c:\new\test.spm"
  - Byte字符串：b'sp\x01am'

- python自动再任意的表达式中合并相邻的字符串常量

  ```python 
  title = "Meaning" 'of' "Life"
  tiele
  >>>'Meaningoflife'
  ```

- 用转义序列代表特殊字节

  - 反斜杠用来引入特殊的字节编码，是转义序列

  - 交互模式下是以转义字符的形式回显，但print会将其解释出来

  - len()可用来了解字符串中__有多少个字节__

  - 转义字符

    ```
    \newline 				忽视（连续）
    \\						反斜杠本身
    \'						单引号
    \"						双引号
    \a						响铃
    \b						倒退
    \f						换页
    \n						换行
    \r						返回
    \t						水平制表符
    \v						垂直制表符
    \xhh					十六进制
    \ooo					八进制
    \0						Null(不是字符串结尾)
    \other					不转义（保留）
    ```

    - python没有一个字符会结束一个字符串

    - python以十六进制显示非打印字符

      ```
      s = '\001\002\x03'
      s
      >>>'\x01\x02\x03'
      ```

    - 如果python没有作为一个合法的转义编码识别出\后的字符，他就直接保留反斜杠

      ```
      s = '\dd\n\cc'
      s
      >>> '\\dd\n\\cc'
      ```

- raw字符串抑制转义

  - 转义用来处理再字符串中嵌入特殊字节码，有时候引入转义字符而使用的反斜杠会引来一些麻烦

    - 如`my_file= open('c:\new\text.dat','w')`,\n和\t会导致错误

  - 方法一：raw字符串用来解决此问题

    - 大写或小写（r\R）出现在字符串的第一个引号前面，就会关闭转义机制

  - 方法二：两个反斜杠是一个反斜杠的转义序列

    - `my_file = open('c:\\new\\text.dat','w')`

  - 当打印嵌入反斜杠的字符串时候，python自己也会使用转义斜杠的方法(交互模式下)

    ```
    a = r'c:\new\text.dat'
    print(repr(a))
    print(a)
    >>>'c:\\new\\text.dat'
    >>> c:\new\text.dat
    ```

  - window下使用__斜杠__表示字符串路径

  - raw字符串不能以单个的反斜杠结尾，因为反斜杠会转义后续引用的字符

    - `r'...\'`不是一个有效的字符常量
    - 一个raw字符串不能以奇数个反斜杠结尾，如果需要单个的反斜杠结束一个rawz字符串
      - 使用两个反斜杠并分片掉最后一个反斜杠    `r'1\nb\tc\\'[:-1]`
      - 手动添加反斜杠   `r'1\nb\tc'+'\\'`
      - 使用常规的字符转义 `'1\\nb\\tc\\'`

- 三重引号编写多行字符串块
  - 到目前已经学习了单引号、双引号、转义字符、raw字符，python还提供了一种三引号的块字符串
  - 用于输入多行文本
  - 常用于文档字符串
  - 用于注释代码

- 字符串应用

  - \+ 号合并字符串

    - 不允许混用字符和数字

      ```
      'abc'+9
      # 会出错
      ```

      

  - \* 号重复字符串

    - 打印包含80个横线的一行

      ````
      print('-'*80)
      ````

  - for循环迭代字符串

  - in对字符串和子字符串进行成员关系测试

  - 索引和分片

    - 从左到右0为第一个元素，从右到左是 -1为第一个元素
    - s[:-1]  不包括最后一个元素
    - s[:] 所有元素（顶层拷贝）

  - 扩展分片（步长）

    - X[I:J:k]

      - 前两个参数默认值为零,步长K默认为1

    - 可以用负数作为步进

    - k = -1是反转

    - 分片等同于用一个分片对象进行索引

      ```python
      'spam'[1:3]
      # 等同于
      'spam'[slice(1,3)]
      
      print('spam'[::-1])
      # 等价于
      print('spam'[slice(None,None,-1)])
      ```

  - 字符串转换工具

    - int() 将字符串转换为数字
    - repr() 将对象转换为其字符串形式
    - str()转换为字符串

  - 字符串代码转换

    - ord()  将单个字符转换为ascii码（字符再内存中的二进制）

    - chr()  将ascii转换为对应的字符

      - 基于字符串的数学运算

        ```
        num = '9'
        chr(ord(s)+10)
        >>> 19
        ```

  - 字符串方法

    ![008](D:\project\pycon\web scrapy\img\008.PNG)

    ![009](D:\project\pycon\web scrapy\img\009.PNG)

  - 字符串方法实例

    - find()方法返回 字符串出现处的索引，__未找到时返回-1__

    - replace

      - 每次返回一个新的字符串

      - 如果不得对一个超长字符串进行许多的修改，为了优化脚本性能，需要将字符串转换为一个支持原处修改的对象

        ```
        # 可用list函数将其转换为列表，然后进行修改
        # 之后用字符串的join方法将列表合并成一个字符
        ```

    - split

      - 默认空格为分隔符，将字符串分割为多个子字符串（分隔符不会出现在子字符串中）

    - % 格式化

      - 格式化总是返回新的字符串，而不是对左侧的字符串修改

      ```
      'that is %d %s bird' % (1,'big')
      ```

      - 更高级的格式化

        ![004](D:\project\pycon\Python_学习手册\img\004.JPG)

        - `%[(name)][flags][width][.precision]typecode`

          ```python
          x = 1234
          # 默认格式化、6位左对齐、6位补零
          res = 'integers:...%d...%-6d...%06d' %(x,x,x)
          ```

        - 如果在运行时才知道大小，可以在字符串中使用*来指定通过计算得出width和precision

          ```python
          # * 位需要传入整数
          '%f, %.2f, %.*f' % (1/3.0 ,1/3.0, 4, 1/3.0)
          >>> '0.333333,0.33,0.3333'
          ```

      - 基于字典的格式化

        - `"%(n)d %(s)s" % {'n':1,'s':'spam'}`

          

### 第八章_列表字典

都可以在原处修改，也可以增长或缩短，可以包含任何种类的对象

#### 列表

有序集合对象类型，可以包含任何种类的对象，是 可变对象

1. 任意对象的有序集合

2. 通过偏移读取

3. 可变长度、异构、任意嵌套
   1. 异构：可以包含任何类型的对象而不仅仅是包含有单个字符的字符串
4. 可变序列分类
5. 索引、切片、合并

help(list) 或 dir(list) 查看list的方法

- 常用操作

  ![005](D:\project\pycon\Python_学习手册\img\005.JPG)
  - l.insert(i,item)

  - l.index(item)   只返回第一次出现位置

  - l.sort()

  - l.reverse()

  - del l[k]

  - l.pop()   最后一个

  - l.remove(item)    第一个

  - l[i] = j   分片赋值

  - ```
    list(map(ord,'spam'))
    >>>[115, 112, 97, 109]
    ```

  - l = [x**2 for x in range(5)]

#### 实际应用中的列表

- 基本操作

  - \+  合并操作
  - \* 重复操作

- 列表解析和迭代

  - 成员操作
    - `3 in [1, 2, 3]`
  - 迭代
    - `for i in [1,2,3]:`
  - 列表解析
    - res = [c*4 for c in 'spam']

- 索引、分片、矩阵

- 原处修改

  - 原处修改一个 对象时，可能会影响其他指向它的引用

  - 对索引和分片赋值

    - 用一个新值取代指向索引的引用

  - 分片理解

    1. 先删除
    2. 再插入

    ```python
    L = [1,2,3]
    L[1:2] = [4,5]
    L
    >>>[1, 4, 5, 3]
    L[1:2] = []
    L
    >>>[1, 5, 3]
    ```

    - 当分片重叠时`L[2:5]=L[3:6]`是可行的，这是因为要被插入的值会再左侧删除前取出

- 方法调用

  ==方法是特定类型的工具==

  - append:将一个__单项__加至末端，允许传入单一对象

    - L.append(x) 与 L + [X] 结果类似，但后者会生成新的列表

  - `sort(self, /, *, key=None, reverse=False)`

    - 使用标准的python比较检验（字符串比较）递增排序
    - key是针对传入的每个元素生成一个排序id然后排序

  - reversed内置函数，必须包含在list中调用

    ```
    L = [1,2,3,4]
    list(reversed(L))
    >>>[4, 3, 2, 1]
    ```

#### 字典

除了列表外，字典是python中最灵活的内置数据结构类型，列表是有序的对象集合，字典是无序的集合

1. 通过键而不是索引读取
2. 任意对象的无序集合
3. 可变长、异构、任意嵌套
4. 可变映射类型
   1. 字典是唯一内置的映射类型
5. 对象引用表
   1. 字典存储的是对象引用

##### 常用操作

![006](D:\project\pycon\Python_学习手册\img\006.JPG)

​			![007](D:\project\pycon\Python_学习手册\img\007.JPG)

- 对字典赋值（不存在的键）会生成一个新的元素
- 当键不存在时，get能返回默认值（None或者自定义值），这是__为了避免missing_key__错误
- update:把一个字典的值合并到另外一个字典，盲目的覆盖相同的键
- dict.setdefault()   添加默认值，存在就返回,不存在就添加
- dict.popitem()    随机删除键值对
- dict.copy()   浅复制

> 对任何字典而言，写成`for key in D ` 和完整的`for key in D.keys()`效果是一样的
>
> 迭代器允许in成员关系操作符用于字典的另一个实例

- 注意事项

  - 序列运算无效，字典是映射机制，不是序列
  - 对新索引赋值会添加项
  - 键不一定总是字符串，任何不可变对象都可以

  ```
  D = {}
  D[99] = 'spam'
  >>> {99:'spam'}
  ```

  - 字典用于稀疏数据结构

    ```
    matrix = {}
    matrix[(2,3,4)] = 88
    matrix[(7,8,9)] = 99
    >>>{(2,3,4):88,(7,8,9):99}
    ```

  - 避免missing-key错误

    读取不存在的键的错误很常见，常用避免方法:if语句中预先测试，try语句明确的捕获并修复，get方法为不存的键提供默认值

    ```python
    # 方法一：
    if (2,3,6) in Matrix:
        print(Matrix[(2,3,6)])
    else:
        print(0)
    # 方法二：
    try:
        print(Matrix[(2,3,6)])
    except KeyError:
        print(0)
    # 方法三：
    Matrix.get((2,3,6),0)
    ```

  - 创建字典的方法

    ```python
    # traditional
    {'name':'mel','age':45}
    # 键赋值
    D= {}
    D['name'] = 'mel'
    # 键值对
    dict(name = 'mel', age=45)
    # 键值元祖
    dict([('name','mel'),('age',40)])
    ```

- 字典解析

  ```python
  list(zip(['a','b','c'],[1,2,3]))
  D = dict(zip(['a','b','c'],[1,2,3]))
  # 字典解析表达式
  D = {key:value for key,value in zip(['a','b','c'],[1,2,3])}
  
  # 其他例子
  D = {c:c*4 for c in 'spam'}
  >>>{'s':'ssss','p':'pppp','a':'aaaa','m':'mmmm'}
  
  # 初始化字典
      # 一般方法
      D = dict.fromkeys(['a','b','c'],0)
      # 字典解析
      D = {i:0 for i in ['a','b','c']}
  ```

- 字典视图

  - python3中keys、values、items返回视图对象，保持了字典成分的最初顺序

    ```
    D = dict(a=1,b=2,c=3)
    k = D.keys()
    k
    >>>dict_keys(['a', 'b', 'c'])
    ```

  - 字典有自己的迭代器

    ```python
    for key in D:
        print(key)
    ```

- 字典视图和几何

  > keys方法返回的对象类似与集合，支持交集并集等集合操作，values视图不是这样的，因为他们不是唯一的，items的对象也是的，如果（key,value）对是唯一并且可散列的话

  ```python
  D = dict(a=1,b=2,c=3)
  k = D.keys()
  # keys and dict
  k | {'x':3}
  >>>{'a', 'b', 'c', 'x'}
  # keys and set
  k & {'b'}
  >>>{'b'}
  # items and set
  D.items() & {('b', 2)}
  >>>{('b', 2)}
  ```

- 排序字典键

  - keys不会返回列表，必须手动转换为列表或使用sorted函数

    ```python
    D = dict(a=1,b=2,c=3)
    k = D.keys()
    a = list(k)
    a.sort(reverse=True)
    a
    >>>['c', 'b', 'a']
    
    k = D.keys()
    # sorted 把keys对象直接生成列表
    sorted(k,reverse=True)
    >>>['c', 'b', 'a']
    ```

- in 成员测试

  - 使用in或者get方法

    ```python
    D = dict(a=1,b=2,c=3)
    'c' in D
    >>>True
    
    D.get('c','None')
    >>>3
    ```

### 第九章_元祖、文件及其他

#### 元祖

>  元祖与列表相似，不能在原位修改

- 任意对象的有序集合
- 通过偏移存取
  - 支持分片和索引
- 不可变序列类型
- 固定长度、异构、任意嵌套
- 对象引用数组

> 生成一个元祖，将元素用逗号隔开，用圆括号括起来，空括号就是空元祖

- 常见元祖及运算

​	（）					    空元祖

​	T = （0，）				单个元素的元祖

​	T = （0，‘NI’，1.2，3）	   四个元素

​	T = 0，‘NI’，1.2，3		   与前列相同

​	T = （‘abc',('def','ghi')）	   嵌套元祖

​	T = tuple('spam')			可迭代对象

​	T[i]

​	T[i]\[j\]

​	T[i:j]

​	len(T)

​	T1 + T2				合并、重复

​	T * 3	

​	for i in T :

​	    print(i)

​	'spam' in T			 成员关系

​	[x ** 2 for x in T ]	

​	T.index('NI')			搜索

​	T.count('Ni')			计数

- 实际应用

  ```python
  a = (5)		# an integer
  a = (5,)	# a tuple	
  # 多个元素时，没有括号也能识别出元祖
  ```

- 转换、方法及不可变性

  - \+ 、 \* 及分片操作会返回新的元组

  - 对元组排序需要将其转换为列表（可变对象），或者使用sorted方法，它接受任何序列

    - 元组使用sorted排序后返回列表

    ```python
    a = 21,14,3
    b = sorted(a)
    print(b,type(b))
    >>>[3, 14, 21] <class 'list'>
    ```

  - 列表解析可用于元组转换

  - 列表解析可用在某些并非实际存储的序列上，任何遍历对象都可以（包括逐行读取的文件）

  - 元组方法index、count

    ```
    T = (1,2,3,2,4,2)
    T.index(2,2)
    >>>3
    T.index(2)
    >>>1
    T.count(2)
    >>>3
    
    ```

  - 元组的不可变性只适用于元组顶层，而非其内容，内部的列表可以修改

- 为什么需要元组

  元组的不可变性提供了完整性，可以保证在程序中不会被另一个引用修改

- 文件

  - open函数会创建一个python对象

  - 操作方法

    - output = open(r'c:\spam', 'w')

    - input = open('data', 'r')

    - input = open('data')                                        r 是默认

    - aString = input.read()                                     把整个文件读入字符串

    - aString = input.read(N)                                  读取之后的N个字节

    - aString = input.readline()                              读取下一行（包括行末标识符）

    - aList = input.readlines()                                  读取整个文件到字符串列表

    - output.write(aString)                                      写入字节字符串到文件

    - output.writelines(alist)                                   把列表中的所有字符串写入文件

    - output.close()                                                   手动关闭

    - output.flush()                                                    把输出缓冲区刷到硬盘中，但不关闭文件

    - anyFile.seek(N)                                                 修改指针位置到偏移量N处，以便进行下一个操作

    - for line in open('data'):

      ​        use line

- 使用文件

  > Python 中的文本文件都采用字符串的形式，读取文件会返回字符串形式的文本

  - 文件迭代器是最好的读取行工具
  - 内容是字符串，不是对象
    - 从文件读取的数据回到脚本是字符串，需要将其转换为python对象以便使用
  - close是通常选项
    - 当文件对象被回收的时候，如果需要的话，python也会自动关闭该文件
  - 文件时缓冲的并且时可查找的
    - 关闭一个文件或者运行flush方法，迫使缓存的数据进入硬盘

- 实际使用

  - 文件迭代器

    ```python
    for line in open('myfile'):
        print(line,end='')
    ```

  - 使用 line.rstrip() 来移除行的终止符

    - lien[:-1] 也可以

  - 使用eval()可以把字符串转换为对象

- 用pickle存储python的原生对象

  > 能在文件存储python对象，并不需要把字符串转来转去，就像超级通用的数据格式化和解析工具

  ```python
  # 存储字典
  import pickle
  D = {'a': 1, 'b': 2}
  f = open(r'.\datafile.pkl','wb')
  pickle.dump(D,f)
  f.close()
  
  # 读取原生数据
  f = open(r'.\datafile.pkl','rb')
  d = pickle.load(f)
  print(d)
  ```

- 文件中打包二进制数据的存储与解析

  > 有些高级应用中需要处理打包的二进制数据，struct模块能够构造并解析打包的二进制数据

  - pickle用于把python对象储存在文件中，而不用可以转为字符串，struct需要把数据打包为二进制格式,之后保存在文件中

- 文件上下文管理器

  > with允许我们把文件处理代码包装到一个逻辑层中，以确保在退出后可以自动关闭文件，而不依赖垃圾回收的自动关闭

  ```python
  with open(r'c:\data.txt') as myfile:
      for line in myfile:
          # use line
          
  # 等价于
  myfile = open(r'c:\data.txt')
  try:
      for line in myfile:
          # use line
  finally:
      myfile.close()
  ```

- sys、os

- 重访类型分类

  - 对象根据分类来共享操作

  - 只有可变对象可以原处修改，不能修改数字，字符串或元组

  - 集合类似于一个无值的字典键，但是不能映射为值，并且没有顺序，集合不是映射类型或者序列类型，frozenset是集合的不可变版本

  - 分类：

    ![008](D:\project\pycon\Python_学习手册\img\008.JPG)

-  引用VS拷贝

  > 赋值操作总是存储对象的引用，而不是拷贝
  >
  > 赋值操作会产生相同对象的多个引用，在原处修改会影响其他地方对相同对象的引用

  ```python
  X = [1,2,3]
  L = ['a',X,'b']
  D = {'x':X,'y':2}
  X[1] = 'surprise'
  print(L)
  print(D)
  >>>'a', [1, 'surprise', 3], 'b']
  {'x': [1, 'surprise', 3], 'y': 2}
  ```

  - 当确实需要拷贝时，可以明确要求

    - 没有限制的分片表达式（L[:]）能复制序列
    - 字典的copy方法（X.copy()）嫩复制字典
    - 内置函数list,`list(L)` 能生成拷贝
    - copy标准库模块能生成完整拷贝

    > 分片表达式 和 字典的copy方法只能做到顶层复制，不能复制嵌套的数据结构

    - 深层拷贝需要引入copy模块

      ```
      import copy
      # 可完成对任意嵌套对象的完整复制
      x = copy.deepcopy(Y)
      ```

- 比较、相等性和真值

  ```python
  # 两列表虽然相等，但却时不同的对象
  X = [1,2,3]
  Y = [1,2,3]
  print(X == Y,X is Y)
  >>> True False
  ```

  - 相等性

    - '==' 操作符测试值的相等性（递归的比较所有内嵌对象）

    - 'is'  测试对象的一致性 （测试是否为同一对象，也就是是否为同一个内存地址）

      ```python
      a = 'adam'
      b = 'adam'
      print(a==b,a is b)
      >>> True True
      
      # 为了得到更一般的结果我们使用长字符串
      a = 'adam love hh'
      b = 'adam love hh'
      print(a==b,a is b)
      >>> True False
      ```

    - 对于字符串，python 在内部==暂时存储并重复使用段字符串作为最佳化==，字符串较短时，字符串共享内存，

    - ‘==’几乎是所有等值检验会用的操作符， 而 is 则保留了极为特殊的角色

    - 大小比较也能递归的应用于嵌套的数据结构

    - 不同类型比较方法：

      - 数字比较相对大小
      - 字符串安装字典顺序，一个字符接一个字符比较
      - 列表和元组从左到右对每部分比较
      - 字典通过排序后的（键：值）进行比较（3.0不支持）
      - 数字混合类型比较是错误的

    - python3.0的字典比较

      > 当期望相等的时候会导致很多负担

      - 编写循环来比较键值

      - 手动比较排序的（键：值）列表

        - items字典方法
        - 内置的sorted

        ```python
        D1 = {'a':1,'b':2}
        D2 = {'a':1,'b':3}
        D1 == D2
        >>> True
        D1 < D2
        >>> TypeError: '<' not supported between instances of 'dict' and 'dict'
        sorted(D1.items()) < sorted(D2.items())
        >>> True
        ```

    - 真假的含义

      > 真和假时python对象的固有属性，==每个对象不是真就是假==

      - 数字如果非零，则为真
      - 其他对象如果非空，则为真

      > 对象真值的例子

      - ‘spam'      True
      - ''                True
      - []               False
      - {}               False
      - 1                True
      - 0.0             False
      - None         False

      > None 对象

      - None总被认为是假，这是python中一种特殊数据类型的唯一值，是函数的默认返回值
      - None不是未定义，None是某些内容——是一个真正的对象，并且有一块内存

      > boo类型

      - bool扩展了真假的概念，True和False是1和0的定制版本而已
      - bool()函数用来测试一个对象的布尔值

- Python类型层次

  > python系统中的任何东西都是对象类型，可以由python程序来处理

  - type对象

    > 即使是类型本身在python 中也是对象

    - type(x) 返回对象的类型对象

    - 任何对象的类型都是类型为’type‘的对象

    - 按类别组织的python的内置对象类型

      ![009](D:\project\pycon\Python_学习手册\img\009.JPG)

- python中的其他类型

  > 正则表达式、DBM文件、GUI组件、网络套接字等
  >
  > > 这些附带工具和内置类型的区别：内置类型有针对他们的对象的特殊语言生成语法，而在内置模块中使用其他工具则必须先导入才能使用

  - 赋值生成引用而不是拷贝

  - 重复能够增加层次深度

  - 留意循环数据结构

    ```
    a = ['abc']
    a.append(a)
    >>>['abc', [...]]
    ```

    python在对象中检测到循环，都会打印称为 [...] ,而不会陷入无限循环

  - 不可变类型不可在原处改变

  

## 第三部分_语法和语句_

### _第十章_python语句简介

==程序由模块构成，模块由语句构成，语句包含表达式，表达式建立并处理对象==

#### python语句

- python语句集：

| 语句                           | 角色       | 例子                        |
| ------------------------------ | ---------- | --------------------------- |
| 赋值                           | 创建引用值 | a,b,c = 'good','bad','ugly' |
| 调用                           | 执行函数   | log.write('spam')           |
| 打印调用                       | 打印对象   | print('The killer')         |
| if  /  elif  /  else           | 选择动作   | if ’python' in text:        |
| for   /   else                 | 序列循环   |                             |
| while   /   else               | 一般循环   |                             |
| pass                           | 空占位符   |                             |
| break                          | 循环退出   |                             |
| continue                       | 循环继续   |                             |
| def                            | 函数和方法 |                             |
| return                         | 函数结果   |                             |
| yield                          | 生成器函数 |                             |
| global                         | 命名空间   |                             |
| nonlocal                       | 命名空间   |                             |
| import                         | 模块访问   |                             |
| from                           | 属性访问   |                             |
| class                          | 创建对象   |                             |
| try   /   except   /   finally | 捕捉异常   |                             |
| raise                          | 触发异常   |                             |
| assert                         | 调试检查   |                             |
| with   /   as                  | 环境管理器 |                             |
| del                            | 删除引用   |                             |

- 冒号，首行以冒号结尾，下一行嵌套的代码需要缩进

- 括号是可选的

  ```python
  if (x<y):
      pass
  if x<y:
      pass
  ```

- 终止行就是终止语句

- 缩进的结束就是代码块的结束

  - 所谓缩进是指两个嵌套语句至左侧空白的所有空白，python不在乎你怎么缩进，你可以使用任意多个空格或者制表符

- 缩进使得代码统一、整齐并具有可读性，具备了重用性和维护性

- 特殊实例：

  - 语句一般时一行一个，但python也有可能出现某一行挤进多个语句的情况，这时由分号隔开

    ```python
    a = 1；b = 2;print(a+b)
    ```

    - 这是python唯一需要分号的地方——作为语句界定符，放在一起的语句不是 复合语句才行，只能把简单的句子放在一起，例如赋值操作、打印、函数调用

  - ==括号（（）），方括号（[]）,大括号({})==可以让一个语句的范围横跨多行,任何括在符号里的程序代码可以横跨几行

    ```python
    # 连续列表常量
    mlist = [111，
            222，
            333]
    ```

    - 大括号处理字典，圆括号处理元组、函数调用、表达式

    - 连续行的缩进是无所谓的

    - 括号是可以包含一切的（适用复合语句）

      ```python
      if(A == 1 and
        B == 2 and
        C == 3):
          print('spam'*3)
          
      X = (A + B +
          C + D)
      ```

    - 一条老规则允许跨行——当上一行以反斜线结束时，可以在下一行继续(不提倡)

      ```python
      X = A + B +\
          + C + D
      ```

  - 代码块规则特殊实例

    > 嵌套代码块的语句一般都与向右缩进的量有关

    - 特殊实例

      > 复合语句的主体可以出现在python的首行冒号之后
      >
      > - 只有简单的语句可以跟在冒号之后：赋值、打印、函数调用等
      > - 复合语句的附带部分必须放在自己的行里（例如if的else部分，使用逗号分开）

      ```
      if x > y: print(x)
      ```

- 简单实例

  ```python
  # 简单的交互循环
  while True:
      reply = input('Enter text:')
      if reply == 'stop': break
      print(reply.upper())
      
  # python 会执行首次测试为真所匹配的代码块
  while True:
      reply = input('enter text:')
      if reply == 'stop':
          break
      elif not reply.isdigit():
          print('bad' * 8)
      else:
          print(int(reply) * 2)
  print('Bye')
  ```

  - python 会先执行try
    - 如果有异常发生就执行except部分
    - 如果没有异常发生就执行else部分
  - 多层嵌套



### 第十一章_赋值、表达式和打印

#### 赋值语句

- 赋值语句建立对象引用值
- 变量名在首次赋值时会被创建
- 变量名在引用前必须先赋值
  - 使用尚未赋值的变量会引发异常
- 执行隐式赋值的操作
  - 模块导入、函数和类的定义、for循环变量、函数参数（在运行时将把变量名和对象引用值绑定起来）

#### 赋值语句形式

- spam = 'spam'                             基本形式

- spam,ham = 'yum','YUM'           元组赋值运算

- [spam,ham] = ['yum','YUM']      列表赋值运算

- a,b,c,d = 'spam'                            序列赋值

- a,*b = 'spam'                                序列解包

- spam = ham = 'lunch'                 多目标赋值

- spams += 11                                增强赋值运算

  

- 高级赋值

  ```python
  ((a,b),c) = ('sp','am')
  a,b,c
  >>>('s','p','am)
  
  # 循环赋值
  for (a,b,c) in [(1,2,3),(4,5,6)]:
      pass
      
  # 序列解包赋值语句(赋值一系列整数给一组变量)
  red,green,blue = range(3)
  
  L= [1,2,3,4]
  while L:
      front,L = L[0],L[1:]
      print(front,L)
  >>>1 [2, 3, 4]
  2 [3, 4]
  3 [4]
  4 []
  ```

- 扩展序列解包

  > 一个带有单个星号的名称，可以在赋值目标中使用，以指定对于序列的一个更为通用的匹配

  > 序列赋值通常要求左边的目标名称数目与右边主体的项数对应，长度不同，将会报错

  > 我们可以在目标中使用带单个星号的名称来更通用的匹配
  >
  > - 不管星号出现在哪里，包含该位置的每个未赋值元素列表都会赋给它

  ```python
  # 正确操作
  a,b,c,d = [1,2,3,4]
  # 错误操作
  a,b = [1,2,3,4]
  # 星号操作
  a,*b = [1,2,3,4]
  ```

- 边界情况

  - 带星号的名称可能只匹配带个项，但总时赋值一个列表

  - 如果没有内容匹配带星号的名称，会赋值一个空列表

  - 有多个带星号的名称、值少了而没有带星号的名称、带星号的名称没有编写到列表中 都会报错

    ```
    # 错误用法
    a,*b,c,*d = [1,2,3,4]
    a,b = [1,2,3,4]
    *a = sep
    # 正确用法
    *a, = [1,2,3,4]
    ```

    ==*a，= [1,2,3,4]== 生成一个列表，等价于`a = [1,2,3,4]`

- for循环

  ```python
  for (a,*b,c) in [(1,2,3,4),(5,6,7,8)]:
      pass
  ```

- 多目标赋值语句

  ```
  a = b = c = 'spam'
  ```

  - 多目标赋值和共享引用

    > 一个对象由多个变量共享，

    ```
    # 修改b只会对b修改，数字不支持原处修改
    a = b = 0
    b = b + 1
    a,b
    >>>(0,1)
    # 当把变量初始值设为可变对象时,由于引用相同对象，两个变量都会改变
    a = b = []
    b.append(1)
    a,b
    >>>([1],[1])
    ```

- 增强赋值语句

  - x += y
  - x -= y
  - x *= y
  - x /= y
  - x %= y
  - x $= y
  - x ^= y
  - x <<= y
  - x >>= y
  - x **= y
  - x //= y
  - x |= y

  > 优势：
  >
  > - 输入减少
  >
  > - x可以是复杂对象表达式，增强形式中，则只需==计算一次==（x = x + y中，x出现两次，必须执行两次），增强赋值执行更快
  >
  > - 优化技术自动选择，对于支持原处修改的对象而言，增强赋值会自动执行原处修改，而不是相比慢速的复制
  >
  > - 使用增强语句来扩展列表，python会自动调用较快的extend而不是较慢的  + 操作
  >
  >   ```
  >   L += [9,10]     # mapped to L.extend([9.10])
  >   ```

- 增强赋值及共享引用

  > - += 对列表是原处修改
  >
  > - \+ 对列表生成新对象
  >
  >   ```
  >   # + 操作，生成新对象
  >   L = [1,2]
  >   M = L
  >   L = L + [3,4]
  >   L,M
  >   >>>([1, 2, 3, 4], [1, 2])
  >   # +=对列表是原处修改
  >   L = [1,2]
  >   M = L
  >   L += [3,4]
  >   L,M
  >   >>>([1, 2, 3, 4], [1, 2, 3, 4])
  >   ```

  - 这种对于列表和字典这类可变对象才重要

- 变量命名规则

  > python中，为变量名赋值时，变量名就会存在，程序选择变量名时，要遵循如下规则：
  >
  > - 语法：下划线或字母 +任意数据的字母、数字、下划线
  >   - 变量名必须以==下划线或字母开头==，后面接任意数目==字母、数字或下划线==
  >   - 区分大小写
  >   - 禁止使用保留字

  - python保留字

    ```
    False、class、finally、is、return、None、continue、for、lambda、try、True、def、from、nonlocal、while、and、del、global、not、with、as、elif、if、or、yield、assert、else、import、pass、break、except、in、raise
    ```

  - import 语句中的模块变量名会变成脚本中的变量，这种限制也会扩展到模块的文件名

    > 你可以写and.py 和 my-code.py这类文件，但是你无法将其导入
    >
    > - 保留字是禁区
    > - 破折号不行

    ```
    improt my-code.py
      File "<stdin>", line 1
        import my-coce
                 ^
    SyntaxError: invalid syntax
    ```

- 命名惯例

  > 非必要规则，一般都会遵守

  - 以单一下划线开头的变量名（_X）不会被from module import * 导入
  - 前后由下划线的变量名（\_X\_）是系统定义的变量名，对解释器有特殊意义
  - 以两个下划线开头（__X）
  - 通过交互模式与运行时，只有单个下划线的变量名（_）会保存最后表达式的结果
  - 类变量名通常以一个大写字母开头，模块变量名以小写字母开头

- 变量名没有类型，但对象有

#### 表达式语句

> 表达式的结果不会存储

- spam(eggs, ham)       函数调用
- spam.ham(eggs)        方法调用
- spam                           交互模式打印变量
- print(a,b,c)                  打印
- yield x**2                   产生表达式语句

#### 表达式语句和原处修改

```
L = [1,2]
L.append(3)
L
>>>[1,2,3]
L = L.append(3)
L
>>>None
```

- 对列表调用append,sort,reverse 这类原处修改的运算，使用这些方法修改后不会把列表返回，事实上返回None对象
- 如果赋值这类运算的结果给该变量的变量名，只会丢失该列表（可能被当成垃圾回收）

#### 打印操作

- print是对程序员友好的标准输出接口

- python3中，打印是一个函数

  - print(obj,sep='',end='',file=sys.stdout)

  - file指定了文本将要发送的文件，标准流或者其他类似的文件对象

    - 带有一个类似文件的write(string)方法的任何对象都可传递，但真正的文件应该已经为输出而打开

    ```python
    # C:\Users\Dell\Desktop>python
    print('hello',file=open('test.txt','w'))
    # 输出 hello 的txt文件到桌面
    ```

#### 打印流重定向

> 打印都默认的发送到标准输出流，发送到其他地方也是有用的，例如文本文件，可以保存结果，供以后测试使用
>
> - 重定向也可以在shell中实现

```python
print('hello world')           # python3
print 'hello world'            # python2.6
```

- print 语句是python 人性化的特性，提供 sys.stdout的接口

- 使用sys.stdout

  ```python
  import sys
  sys.stdout.write('hello world\n')
  ```

- 重定向输出流

  - print和stdout的关系

    ```python
    print(x,y) 
    # 等价于
    import sys
    sys.stdout.write(str(x)+''+str(y)+'\n')
    
    # 这里强调打印的友好性
    ```

  - 这种等效的方式提供了一种方法，让print语句将文字传送到其他地方

    ```python
    import sys
    sys.stdout = open('log.txt','a')
    print('hello world')
    ```

    - 这里我们把sys.stdout重设为打开的文件（采用附加模式），程序中的任何打印都会写至文件末尾
    - 可以将sys.stdout设为非文件对象，只要对象有预期的write协议

- 自动化流重定向

  - sys.stdout是一个普通的文件对象，你可以存储它，需要时恢复

    ```python
    import sys
    temp = sys.stdout
    print(temp)
    >>> <_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>
    sys.stdout = open('log.txt','a')
    print('haha')
    sys.stdout = temp
    print('haha')
    >>>haha
    ```

    - python3中，file关键字允许一个单个的print调用将文本发送到文件的write方法，这种重定向是暂时的

      

### 第十二章_if测试和语法规则

- if语句用于选取要执行的操作，python中主要的选择工具

- 后面跟着多个可选的elif以及一个最终可选的else

- python会执行第一个结果为真的代码块，或者所有的测试为假，就执行else块

  ```python
  if test:
      <statements1>
  elif test2:
      <statements2>
  else:
      <statements3>
  ```

语法规则：

- 语句是逐个运行的
- 块和语句的边界会自动检测
- 复合语句=首行+“：”+缩进语句
- 空白行、空格以及注释都会忽略
- 文档字符串会忽略，但会保存并由工具显示
  - docstring,和#注释不同，文档字符串会在运行时保留下来以便查看，

代码块分隔符：

- 自动以缩进检测块的边界，快内的语句会垂直对齐，遇到缩进量少的行退出

语句分隔符：

- 使用语法括号对，语句就可以横跨数行——（）[] {} 这类配对中

- 语句以反斜线结束，可以横跨数行

  > 比较过时的功能，如果需要横跨数行，就在前一行末尾加上反斜线  \

- 三重引号可以横跨多行

- 可以用分号终止语句：这种惯例有时用于把一个简单的语句挤进单个行中

- 注释可以出现在任意地方

特殊情况：

```python
# 括号让行保持连续
L = ['good',
    'bad',
    'ugly']
# \
if a == b and c == d and \
    d == e and e == f:
        pass
# 括号
if (a == b and c == d and 
   d == e and e == f):
    pass

```

- 同一行编写多个非复合语句，以分号隔开

  ```
  x = 1; y = 2; print(x)
  ```

- 三重引号

  ```python
  s = '''
  aaaa
  bbbb
  cccc'''
  # 相邻的字符串常量时隐式的连接起来的
  s = ('aaaa'
      'bbbb'
      'cccc')
  ```

- 真值测试

  - 任何非零数字和非空对象都为真

  - 数字零、空对象以及特殊对象None都被认为是假

  - 比较和相等测试会递归的应用在数据结构中

  - 比较和相等测试会返回True或False(0\1的特殊版本)

  - 布尔and \or会返回真或假的操作对象

    - and
    - or
    - not

    > 比较会返回True\False作为结果
    >
    > and \or 返回对象（每个对象本质上不是真就是假）

    > 对于or测试，python从左至右求算，返回第一个为真的对象（python会在其找到第一个真值操作数的地方停止——短路计算）

    ```python
    2 or 3, 3 or 2
    >>>(2,3)
    [] or 3
    >>> 3
    # 左边的为假，python只会计算右边的数并将其返回（可能为真或假）
    [] or {}
    >>>{}
    ```

  - 在结果知道时，and也会停止,从左至右计算，停在第一个为假的对象上

    ```
    []  and {}
    >>>[]
    2 and 3
    >>> 3
    3 and 2
    >>>2
    ```

if /else 三元表达式

```python
if X:
    A = Y
else:
    A = Z

# 等价于
A = Y if X else Z

# bool函数会把X转换为对应的0或1
A = [Y,Z][bool(X)]
```



### 第十三章_while和for循环

> while 提供了编写通用循环的一种方法，for语句用来遍历序列对象内的元素
>
> break、Continue
>
> 常用内置函数range、zip、map
>
> 重复操作的主要语法:while、for、迭代、列表解析
>
> 奇特迭代工具：生成器、filter、reduce

- while 循环

  > 只要顶端测试一直为真，就会重复执行一个语句块，控制权会持续返回到语句的开头部分，直到测试为假，控制权会传给while块后的语句

  ```python
  while test:
      <statements1>
  else:
      <statements2>
  ```

  - break、continue、pass、else

    > 只有嵌套在循环中才起作用，break和continue
    >
    > else和break关联在一起
    >
    > pass空占位语句

    - break:跳出最近循环（整个循环语句）
    - continue：跳到最近循环的开头，来到循环的首行
    - pass:空占位语句
    - else块：只有当循环正常离开时才会执行（也就是没碰到break语句）

  - 一般循环格式

    ```
    while test1:
        <statements1>               
        if test2:break              # exit loop now,skip else
        if test3:continue           # go to top of loop now,to test
    else:
        <statements2>               # run if we didn't hit a 'break'
    ```

    - pass

      > 语法需要语句还没有任何实用的语句时就用pass

      ```
      while Ture : pass
      def fun():
          pass
      ```

      - python 3允许使用 ... (三个连续点来省略代码)，可以当作是pass的一种替代方案

        ```:
        def fun(): ...
        
        def fun():
            ...
        
        # 省略号可以和语句出现在同一行，可以用来初始化变量名
        a = ...
        >>> a
        Ellipsis
        ```

    - continue

      > 语句会立即跳到循环的顶端

    - break

      > 语句会立刻离开循环，位于其后的循环代码都不会执行

    - 循环else

      > 如果==主体从没有执行过，else分句会执行==，while循环中，如果首行的测试一开始就为假，就会 出现这种问题

      ```
      a = 1
      while a> 10:
          if a  == 9:
              print(a)
              break
          a += 1
      else:
          print('a')
      >a
      ```

- for 循环

  - for循环中的元组赋值

    > 如果迭代元组序列，循环目标本身可以是元组，这是元组解包的赋值运算

    ```
    T = [(1,2), (3, 4), (5, 6)]
    for (a,b) in T:
        print(a,b)
    ```

  - for循环中的元组使得用items方法来遍历字典中的键和值和方便

    ```
    D = {'a': 1, 'b': 2, 'c': 3}
    for key in D:
        print(key, '==>', D[key])
    
    for (key, value) in D.items():
        print(key, '==>', value)
    
    # for 之后的任何赋值目标在语法上都是有效的
    for both in T:
        a,b = both
        print(a,b)
    
    for ((a, b), c) in [((1, 2), 3),((4, 5), 6)]:
        print(a,b,c)
    ```

  - python3在for循环中扩展的序列赋值

    - 一个序列可以赋值给一组更为通用的名称（一个带有星号的名称收集多个元素），我们可以在for循环中使用同样的语法提取嵌套的序列

      ```
      for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
          print(a, b, c)
      >1 [2, 3] 4
       5 [6, 7] 8
      ```

  - 文件扫描

    - 文件包含了很多字符和行，是循环常见的案例，要把文件中的内容一次加载至字符串可以用ｒｅａｄ

      

  - 编写循环技巧

    - for比while容易写，执行快速
    - python提供了两个内置函数，在循环内定制迭代
      - range返回一系列连续增加的数，可以作为for中的索引
      - 内置==zip==函数返回并行元素的==元组的列表==，可用于在for中遍历数个序列

  - 循环计数器whlie和range

    - python3中==range是一个迭代器==，我们需要将其包含到一个list调用中以一次性的显示其结果

      ```
      list(range(5))
      >[0, 1, 2, 3, 4]
      ```

  - 修改列表

    ```python
    L = [1,2,3,4,5]
    for x in L:
        x += 1
    # 运行后得到 
    L
    >[1,2,3,4,5]
    x
    >6
    
    # 这样并不行，因为修改的是循环变量x,而不是列表L
    
    # 要在遍历的时候修改列表，我们需要索引，让我们在遍历时替每一个位置赋一个已更新的值，range和len组合可以替我们产生所需要的索引
    L = [1,2,3,4,5]
    for i in range(len(L)):
        L[i] += 1
    L
    > [2,3,4,5,6]
    # for i in L 这种循环会遍历实际的元素，而不是列表的位置
    
    # 等效的while循环
    i = 0
    while i < len(L):
        L[i] += 1
        i += 1
    L
    >[3,4,5,6,7]
    
    # 列表解析也能做类似的工作，但对最初的列表没有进行原处修改
    [x + 1 for x in L]
    ```

  - 并行遍历：zip 和 map

    > zip:会取得一个或多个序列为参数，然会元组的列表（将序列中并排的元素配对）
    >
    > - zip是一个可迭代对象，包含在list中调用会一次性显示所有结果

    ```
    l1 = [1,2,3,4]
    l2 = [5,6,7,8]
    zip(l1, l2)
    ><zip at 0x1f0112655c8>
    list(zip(l1, l2))
    >  [(1, 5), (2, 6), (3, 7), (4, 8)]
    ```

    - zip可以接受任何类型的序列（可迭代对象，包括文件）可以有多个参数，

      ```python
      a,b,c = (1,2,3),(4,5,6),(7,8,9)
      list(zip(a,b,c))
      >[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
      ```

      - 长度不同时，zip会以==最短==序列的长度为准类截断所得的元组

    > map: 会带一个函数，以及一个或多个序列参数，然后用从序列中取得的元素调用函数并收集结果

    - 使用zip构造字典

      ```python
      keys = ['spam', 'eggs', 'toast']
      vals = [1, 3, 5]
      list(zip(keys, vals))
      >[('spam', 1), ('eggs', 3), ('toast', 5)]
      D = {}
      for k,v in zip(keys, vals): D[k] = v
      D
      >  {'spam': 1, 'eggs': 3, 'toast': 5}
      ```

  - 索引和元素：enumerate

    > 有些程序中我们需要索引和元素，这是一个简单的for循环

    ```python
    S = 'spam'
    offset = 0
    for i in S：
       print(i, offset)
       offset += 1
    ```

    - 有一个新的内置函数，可以为我们做这件事

    ```
    S = 'spam'
    for (index, item) in enumerate(S):
        print(index,item)
    >0 s
    1 p
    2 a
    3 m
    ```

    - enumerate函数返回一个生成器对象，这个对象有一个\_\_next\_\_的方法，每次迭代它会返回一个（index, value）的元组，我们可以在for循环中通过元组赋值运算将元组解包

      - 我们一般不会看其作用机制，因为迭代环境（包括列表解析）会自动执行迭代协议

        ```
        [c * i for (i,c) in enumerate(S)]
        ```


- 总结：

  探索了python 的循环语法，深入学习while和for循环，学习其else分句.也研究了break和continue,他们只有在循环中才有意义，介绍了几个在for循环中常用的内置工具，包括range、zip、map、enumerate.下一章将介绍迭代器的概念，



### 第十四章_迭代器和解析（第一部分）

#### 迭代器：初探

python中for循环、列表解析、in成员测试、以及map内置函数等都可用于可迭代对象

- 可迭代对象，是序列观念的通用化，包括实际序列和按照需求而计算的虚拟序列

#### 文件迭代器

文件对象有个readline的方法，可以一次从一个文件中读取一行，到达文件末尾时，会返回空字符串，我们通过它来检测并跳出循环

```
f = open('test.txt')
f.readline()
f.readline()
```

还有另外一个方法，名为\_\_next\_\_,每次调用会返回下一行，唯一的区别，==\_\_next\_\_会引发内置的stopIteration异常，==而不是返回空字符串

- 可迭代的——指的是支持iter的对象
- 迭代器——指的是==iter返回的一个支持next的对象==

这个接口就是 python中的迭代协议：有\_\_next\_\_方法的对象会前进得到下一个结果，而在末尾时，会引发Stop Iteration。**python中，任何这类对象都是可迭代的**

- 任何这类对象也能以for循环或其他迭代工具遍历，因为迭代工具内部工作起来都是在每次迭代中调用\_\_next\_\_,并且捕捉到StopIteration异常来确定何时离开

  - 逐行读取文本最佳的方式就是不去读取，让for循环每轮自动调用next而自动到下一行

    ```python
    for line in open('test.txt'):
        print(line.strip(),end='')
    # 相同效果的原始方式
    for line in open('test.txt').readlines():
        print(line.strip(), end='')
    ```

  - readlines不是最好的方式，它是把整个文件一次性加载到内存，如果文件太大会导致计算机内存空间不够，甚至不能工作

  - while循环逐行读取文件

    ```python
    f = open('test.txt')
    while True:
        line = f.readline()
        if not line: break
        print(line.upper(), end='')
    ```

    尽管这样，比起迭代器for循环版本，这可能运行的更慢一些，因为迭代器在==python中是C语言的速度==运行的，而==while循环则是通过python虚拟机运行==python字节码

#### 手动迭代：iter和next

内置函数next,会自动调用对象的\_\_next\_\_方法，`next(X)`等价于`X.__next__()` ,前者简单很多

- for循环开始时，会 通过它传给iter内置函数，从**可迭代对象**中获得一个**迭代器**

自动和手动迭代之间的对等性：

```python
# 自动迭代
L = [1, 2, 3]
for i in L:
    print(i ** 2, end=' ')
    
# 手动迭代
L = [1, 2, 3]
I = iter(L)
while True:
    try:
        i = next(I)
    except StopIteration:
        break
    print(i ** 2, end = ' ')
```

#### 其他内置类型的迭代器

- 遍历字典键的方法是明确的获取键的列表

  ```python
  D = {'a':1, 'b':2, 'c':3}
  for key in D:
      print(key, D[key])
  > a 1
  b 2
  c 3
  ```

  - 我们不需要调用keys方法来遍历字典键——for循环将使用迭代协议在每次迭代的时候获取一个键

- 迭代协议让我们必须把某些结果包装到一个list调用中一次性看到他们的值：

  ```python
  list(range(5))
  >[0, 1, 2, 3, 4]
  
  # enumerate的工作方式
  E = enumerate('spam')
  I = iter(E)
  next(I)
  > (0, 's')
  list(enumerate('spam'))
  >[(0, 's'), (1, 'p'), (2, 'a'), (3, 'm')]
  ```

#### 列表解析基础知识

列表解析写在一个方括号中，最终构建了一个新的列表

```
# 等价实现
res = []
for x in L:
    res.append(x + 10)
```

列表解析在技术上并非必要，但编写起来更简单，比直接编写for循环运行的更快（快一倍），因为他们的迭代在解释器内部是以C语言的速度执行，而不是以手动python代码实现，特别是对于较大的数据集合，这是使用列表解析的一个主要性能优点

#### 文件上使用列表解析

文件对象的readlines方法，能一次性的==把文件载入到行字符串的一个列表中==

列表解析像for循环是个迭代环境，我们甚至不必提前打开文件，如果我们在表达式中打开，列表解析将自动调用文件的next方法，

```
lines = [line.rstrip() for line in open('script.py')]
```

表达式做了很多隐式的工作，扫描文件自动构建列表

- 高效，速度快

#### 扩展的列表解析

表达式中嵌套的for循环可以有一个相关的if子句

```python
lines = [line.rstrip() for lien in open('script.py') if line[0] == 'p']

# for的等价实现
res = []
for line in open('script.py'):
    if line[0] == 'p':
        res.append(line.rstrip())
```

- for的形式实现复杂，运行慢

列表解析可以变得更复杂，可以包含嵌套的循环，可被编写为一系列的for子句

```python
# 构建一个x+y连接的列表，把一个字符串中的每个x和另外一个字符串中的每个y连接起来
[x + y for x in 'abc' for y in 'lmn']
> ['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
```

#### 其他迭代环境

> 后面我们将会看到用户定义的类也可以实现迭代协议

可对对象从左到右扫描的工具都实现了迭代协议，包括for循环，列表解析，in成员关系测试，map,sorted,zip

- map：把一个函数调用应用于传入的可迭代对象的每一项，可用于列表解析，但有局限性，因为它需要传入一个函数而不是一个表达式，返回一个可迭代对象，必须使用list来查看所有的值
- sorted==排序==可迭代对象中的项
  - 和其他不同的是，sorted返回一个列表而不是可迭代对象
- zip==组合==可迭代的对象中的项
- enumerate根据相对位置来配对可迭代的对象中的项
- filter选择一个函数为真的项
- reduce针对可迭代的对象中==成对的项==运行一个函数

其他内置函数也支持可迭代协议，但很难用在和文件相关的实例中，可以接受任何可迭代对象作为一个参数，并使用迭代协议扫描，但==返回单个结果==：

- sum计算对象总和
- any和 all分布返回True或False
- max和min分别返回最大最小值（也可以 作用于文件，选择具有最高和最低字符串值的行）

python内置工具集中，list,tuple,join都将一个打开的文件上工作，并且自动一次读一行

```
list(open('script.py'))
tuple(open('script.py'))
'$$'.join(open('script.py'))
```

函数调用中有一个特殊的*arg形式，它会把一个集合的值解包为单个的参数，他也会接受任何可迭代对象，包括文件

- zip可用来unzip 已经zip过的元组

  ```python
  a = (1, 2)
  b = (3, 4)
  list(zip(a,b))
  >[(1, 3), (2, 4)]
  
  x,y = zip(*zip(a,b))
  x
  >(1, 2)
  y
  > (3, 4)
  ```

#### python3中新的可迭代对象

像zip这样的函数返回可迭代对象，根据需求产生结果，交互环境中需要额外的录入才能看到结果，但对大型程序来说，这样延迟计算会节约内存并避免暂停

- range

  > range返回一个迭代器，如果需要显示结果，必须使用list()来强制生成一个真正的范围列表

- map、zip、filter迭代器

  > 和range类似，将结果转变成迭代器以节约内存空间，而不是在内存中一次性生成一个结果列表，和range不同的是，他们都是自己的迭代器——在遍历结果一次后就用尽了

  ```python
  M = map(abs,(-1, 0, 1))
  M
  ><map at 0x1f01141c320>
  next(M)
  > 1
   for i in M:
       print(i)
  ```

#### 多个迭代器VS单个迭代器

> range迭代器，支持索引，不是自己的迭代器，支持结果有多个迭代器，这些迭代器会记住他们的位置

```python
R = range(3)
next(R)
> 'range' object is not an iterator
I1 = iter(R)
next(I1)
>  0
I2 = iter(R)
next(I2)
>  0
next(I1)
>  1
```

相反zip,map,filter 不支持相同结果上的多个活跃迭代器

```python
Z = zip((1,2,4),(10,11,12))
I1 = iter(Z)
I2 = iter(Z)
next(I1)
>(1, 10)
next(I1)
>(2, 11)
next(I2)
>(4, 12)
I1 ==  I2
>True
```

```
M = map(abs,(-1, 0, 1))
I1 = iter(M); I2 = iter(M)
I1 == I2
>True
next(I1)
> 1
next(I2)
> 0
next(I1)
> 1
```

可以用类来编写自己的可迭代对象，通过iter调用返回一个新的对象来支持多个迭代器，单个迭代器一般意味着一个对象返回其本身，生成器函数和表达式的行为就像map和zip一样，支持单个的活跃迭代器

#### 字典试图迭代器

> 字典的keys,values,items方法返回可迭代的试图对象，他们一次产生一个结果项，而不是在内存中一次产生7全部结果列表

```python
D = dict(a = 1, b =2, c =3)
D
>{'a': 1, 'b': 2, 'c': 3}
k = D.keys()
k
> dict_keys(['a', 'b', 'c'])
# 键的视图不是可迭代对象
next(k)         
> 'dict_keys' object is not an iterator
# 转换为可迭代对象
I = iter(K) 
```

```python
for k,v in D.items(): print(k,v,end=' ')
> a 1 b 2 c 3
```

- python字典有自己的迭代器，它返回连续的键，无需调用keys

  ```python
  I = iter(D)
  next(I)
  > 'a'
  next(I)
  > 'b'
  
  for k in D: print(k,end = ' ')
  > a b c
  
  D = dict(a = 1, c =3, b =2)
  D
  >{'a': 1, 'c': 3, 'b': 2}
  for k in sorted(D.keys()):print(k,D[k],end=' ')
  >a 1 b 2 c 3
  # 等价方式
  for k in sorted(D):print(k,D[k],end=' ')
  >a 1 b 2 c 3
  ```

#### 其他迭代器主题

-  yield语句：用户定义的函数，可以转换为可迭代的生成器函数
- 当编写在圆括号中的时候，列表解析可以变为生成器表达式
- 用户定义的类，通过\_\_iter\_\_和\_\_getitem\_\_运算符重载变得可迭代



### 第十五章_文档

文档涉及python的语法模型，也是想了解python工具集的读者的资源

#### python文档资源

> 内置工具信息
>
> 文档字符串——docstring
>
> PyDos系统

| 形式                    | 角色                       |
| ----------------------- | -------------------------- |
| \# 注释                 | 文件中的文档               |
| dir函数                 | 对象中可用属性的列表       |
| 文档字符串：\_\_doc\_\_ | 附加在对象上的文件中的文档 |
| PyDoc: help(函数)       | 对象的交互帮助             |
| PyDoc: HTML报表         | 浏览器中的模块文档         |
| 标准手册                | 正式的语言和库的说明       |
| 网站资源                | 在线教材，例子             |
| 出版的书籍              | 商业参考书籍               |

#### # 注释

井号注释是最基本的方式，python会忽略#之后的所有文字（只要井号不是位于字符串常量中），这类注释只能从源代码中看到，要编写能更广泛使用的注释，请使用文档字符串

文档字符串适用于大型功能的文档，#注释适用于较小功能的文档

#### dir函数

抓取对象内可用属性列表的方式（例如对象的方法和简单是数据项）

可用来查看内置对象类型提供了哪些属性，可运行dir并传入所需要类型的常量

```
dir([])
dir('')
# 也可将类型的名称传给dir
dir(str) == dir('')
dir(list) == dir([])
```

- 可作为记忆提醒器，提供属性名称的列表，但并没有告诉你名称的意义

#### 文档字符串：\_\_doc\_\_

python 支持可自动附加在对象上的文档，在运行时可保存查看

从语法上来说，这类注释时写成字符串，放在模块文件、函数以及类语句的顶端，就在任何可执行程序代码前（#注释在其前也没关系），python会自动封装这个字符串，也就是所谓的文档字符串，使其成为相应对象的\_\_doc\_\_属性

#### 用户定义的文档字符串

考虑下面的文件——docstring.py

```python
"""
Module documentation
Words Go Here
"""

spam = 40

def square(x):
    """
    function documentation
    can we have your liver then?
    """
    return x**2              # square

class Employee:
    'class documentation'
    pass
print(square(4))
print(square.__doc__)
```

文档协议的重点在于，注释会保留在_\_doc\_\_属性中以供查看（文件导入后）

因此要显示模块以及其打算关联的文档字符串，我们只需导入这个文件，打印其_\_doc\_\_属性

```python
import docstring
print(docstring.__doc__)
print(docstring.square.__doc__)
print(docstring.Employee.__doc__)

>Module documentation
Words Go Here


    function documentation
    can we have your liver then?
    
class documentation
```

- 要取出模块中类的方法函数字符串，可访问`module.class.method.__doc__`

#### 文档字符串标准

该有什么内容，并没有标准，有些公司有内部标准，现已经有各种标记语言和模板协议(例如HTML，XML)

目前文档字符串没有标准，想用就别犹豫

#### 内置文档字符串

python中内置模块和对象都使用该技术，在dir返回的属性列表前后加上文档

要查看内置模块的可读说明时，可将其导入，并打印其\_\_doc\_\_字符串

内置模块内的函数、类、方法在其\_\_doc\_\_属性内也有附加的说明信息

```
import sys
print(sys.__doc__)

# 也可用于读取内置函数的说明
print(int.__doc__)
```

这种方式可以查看内置工具的大量信息，但不必这样做，help函数会自动做这件事

#### PyDoc：help函数

有很多的方式可启用PyDoc,包括命令行脚本选项，最主要的PyDoc接口是内置的help函数和PyDoc GUI/HTML接口。help函数会启用PyDoc从而产生简单的文字报表

- help() 期待有个对象的引用值传入，对于较大对象，help显示会分为几段
  - class、function、data、file等
- help也能用在模块上

#### 常见编写代码的陷阱

- if\while\for复合语句末尾要加冒号

- 从第一行开始，确定顶层程序从代码第一行开始，包括在模块文件中输入的无嵌套的代码

- 空百行在交互模式提示符下很重要，空白行用来结束语句

- 缩进要一致

- 不要在python中写C代码

- 使用简单的for而不是while和range,for总是容易写并且运行起来更快

- 注意赋值语句中的可变对象

- 不要期待在原处修改对象的函数会返回结果,调用时不要对其结果赋值，

  - list.append()

  - list.sort()

    ```python
    # 结果把列表指定为None
    mylist = mylist.append(x)
    ```

- 一定要使用括号调用函数

- 不要在导入和重载中使用扩展名或路径,因为模块可能有.py以外的其他后缀（如 .pyc）

  ```
  # 在import语句中省略目录路径和文件字尾
  # 导入mod.py
  import mod
  ```

  

## 第四部分_函数

### 第十六章_函数基础

一个函数就是将一些语句集合在一起的部件，能够不止一次的在程序中运行，函数还能计算出一个返回值，能够改变作为函数输入的参数

函数是在编程过程中剪剪贴贴的替代——我们不再有一个操作代码的冗余副本，而是将代码包含到一个单独的函数，大大减少了以后的工作

==函数是python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构==

- 函数相关的表达式
  - calls    myfun(args)
  - def
  - return
  - global
  - nonlocal
  - yield
  - lambda

#### 为何使用函数

- 最大化代码重用和最小化代码冗余

  便于多次使用和维护

- 流程的分解

  将一个系统分割为不同部分

> 函数基本概念、作用域、参数传递、生成器、函数式工具、多态

#### 编写函数

- def是可执行代码——函数并不存在，直到python运行了def后才存在
  - 在if语句、while循环、甚至是其他的def中嵌套是合法的
  - 典型操作中，def语句在模块文件中编写，并自然而然的在模块文件第一次导入的时候生成定义的函数
- def创建了一个对象并将其赋值给某一变量
- lambda创建一个对象但将其作为结果返回
- return将一个结果对象发送给调用者
- yield向调用者发回一个结果对象，但记住它离开的地方
  - 生成器函数通过yield语句返回值，并挂起他们的状态以便稍后能够恢复状态
- global声明了一个模块级别的变量并被赋值
  - 默认情况下在一个函数中被赋值的对象，是函数的本地变量，仅在函数运行过程中存在
  - 为了分配一个可以在整个模块中都可以使用的变量名，函数需要在global语句将它列举出来
  - 变量名需要关注它的作用域（变量存储的地方），并且是通过实现赋值语句将其绑定至作用域的
- nonlocal声明了将要赋值的一个封闭的函数变量
- 函数通过赋值传递
- 参数，返回值以及变量并不是声明
  - 可以传递任意类型的参数，也可以返回任意类型的对象

##### def语句

```python
def name(args):
    ...
    return value
```

return可出现在任何地方，return是可选的，如果没有出现，函数将在控制流执行完成后结束

没有返回值的函数自动返回了None,这个值往往被忽略

##### def语句是实时执行的

def语句运行时创建一个新的函数对象，并将其赋值给一个变量名

def可出现在任何语句可出现的地方，甚至嵌套在其他语句

def在运行时才进行评估，在def之中的代码在函数调用后才会评估

```python
if test:
    def func():
        ...
else:
    def func():
        ...
```

```python
def func(): ...   # create function object
func()            # call object
func.attr = value # attach attributes
```

##### 调用

通过在函数名后加括号调用（运行）这个函数

##### 多态

有时函数的意义取决于输入的参数类型，* 可以执行乘法，也可以执行字符串赋值，它针对被处理的对象做了随机应变——这种依赖类型的行为称为多态（操作的意义取决于被操作的对象的类型）

python是动态语言，多态随处可见

如果传给函数的对象有预期的方法和表达式操作符，他们对于函数的逻辑来说有着即插即用的兼容性

多态的编程模型意味着必须测试 代码取检测错误，而不是 采用编辑器用来检测类型错误的类型声明，以初步测试为代价，减少了我们必须编写的代码

```python
def intersect(seq1, seq2):
    res = []
    for x in seq1:
        if x in seq2:
            res.append(x)
    return res
```

##### 本地变量

本地变量只是在def内的函数中是可见的，并且仅在运行时是存在的

所有的在函数内部进行赋值的变量名都默认为本地变量



### 第十七章_作用域

当在一个程序中使用变量名时，python创建、改变、或查找变量都是在所谓的命名空间中进行的，也就是说代码中的变量名被赋值的位置决定了能被访问到的范围

函数为程序增加了一个命名空间层：

- 在def内定义的变量名能够被def内的代码使用，不能在函数的外部引用这样的变量名
- def之中的变量名和def之外的变量名并不冲突，一个在def之外被赋值的变量X和在这个def之中赋值的变量X是完全不同的变量

变量可以在3个不同的地方分配，分别对应3种不同的作用域：

- 如果一个变量在def内赋值，它被定位在函数之内
- 如果一个变量在一个嵌套的def种赋值，对嵌套的函数来说，它是非本地的
- 如果在def之外赋值，它就是整个文件全局的

我们将其称为语义作用域，函数作用域有助于防止程序之中变量名的冲突，有助于函数成为更加独立的程序单元

#### 作用域法则

- 内嵌的模块是全局作用域，每一个模块都是一个全局作用域，对于外部的全局变量就成为一个模块对象的属性，

- 全局作用域的作用范围仅限于单个文件

  > 在一个文件的顶层的变量名仅对于这个文件内部的代码而言是全局的

- 每次对函数的调用都创建了一个新的本地作用域

- 赋值的变量名除非声明为全局变量或非本地变量，否则均为本地变量

  > 默认在函数内部的变量名是本地作用域内的

  - 如果需要给一个在函数内部却位于模块文件顶层的变量名赋值，需要在函数内部通过global语句声明
  - 如果需要给位于一个嵌套的def中的名称赋值，可以通过nonlocal语句来声明

- 所有其他的变量名都可以归纳为本地、全局或内置变量



交互模式运行的代码实际上是输入到一个叫做\_\_main\_\_的内置模块中

==一个函数内部的任何赋值都会把一个名称划为本地的==：包括 =语句、import中的模块名称、def中的函数名称、函数参数名等

- 原处修改不会把变量划分为本地变量

#### 变量名解析：LEGB原则

对于一个def语句：

- 变量名引用分为三个作用域进行查找：首先是本地，之后是函数内、之后是全局最后是内置
- 默认 情况下，变量名赋值会创建或者改变本地变量
- 全局声明和非本地声明将赋值的变量名映射到模块文件内部的作用域

#### 作用域实例

```python
# global scope
X = 99
def fun(Y):
    # local scope
    Z = X + Y
    return Z
    
# 全局变量名：X,fun
# 本地变量名：Z，Y
```

本地变量是作为临时变量名，只有在函数运行时才需要他们

- 函数使用的绝大多数变量只会在函数自身内部出现，而不是模块文件的任意其他地方
- 本地变量名不会改变程序其他程序，易于调试

#### 内置作用域

内置作用域通过一个名为__builtins__的标准库模块来实现，这个变量名自身并没有放入内置作用域，所以必须导入才能使用：`import builtins`

```python
import builtins
dir(builtins)
>['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
```

前一半是内置异常，后一半是内置函数，两种方式引用一个内置函数：

```
>>> zip
<class 'zip'>
>>> builtins.zip
<class 'zip'>
```

第二种方式在更复杂的任务中是很有用的，

由于LEGB查找流程，会使它找到第一处变量名的地方生效

同时低层的作用域变量名会覆盖高层的作用域变量，全局变量有可能覆盖内置的变量名

#### global语句

__把函数内部的变量变为全局变量，不管这个变量是否在之前出现__

```python
def test():
    global aaa
    aaa = 9
    print('ok',aaa)
test()
> ok 9

aaa = 0
def test():
    global aaa
    aaa = 9
    print('ok',aaa)
test()
> ok 9
```



命名空间的声明：告诉python打算生成一个或多个全局变量名

- 位于模块文件内部的顶层的变量名
- 如果在函数内被赋值的话，必须经过声明
- 全局变量在函数内部可以被引用

global允许我们修改一个模块文件顶层的def之外的名称

global语句包含了关键字global,其后跟着一个或多个由逗号分开的变量名，当函数主体被赋值或引用时，所有列出来的变量名将被映射到整个模块的作用域内

```python
X = 88
def fun():
    global X
    X = 99
fun()
print(X)
>99
```

##### 最小化全局变量

将本地变量变为全局变量会引发一些软件工程问题：

```
X = 99
def fun1():
    global X
    X = 88

def fun2():
    global X
    X = 77
```

如果不确定引用的时间，X的值是多少是个毫无意义的问题

在不熟悉编程的情况下，最好避免使用全局变量

##### 最小化文件间的修改

尽管跨文件变量在python中是可以修改的，这会让两个文件有过强的相关性，会导致代码不灵活，容易出bug

```python
# first.py
X = 99
# second.py
import first
first.X = 88
```

##### 其他访问全局变量的方法

由于全局变量构成了一个被导入的对象的属性，我们能够通过使用导入嵌入的模块，并对其属性进行赋值来仿造出一个global语句

```python
var = 99

def local():
	var = 0

def glob1():
	global var
	# change global var
	var += 1

def glob2():
	var = 0
	import thismod
	thismod.var += 1

def glob3():
	var = 0
	import sys
	glob = sys.modules['thismod']
	glob.var += 1
	return var

def test():
	print(var)
	local();glob1();glob2();glob3()
	print(var)
```

全局变量于模块的属性是等效的，global 允许我们修改模块中的名称

##### 作用域和嵌套函数

LEGB中给Ｅ包含了任意嵌套函数内部的本地作用域（静态嵌套作用域）

> 一个引用首先在本地（函数内）作用域查找变量，之后会在嵌套了的函数中的本地作用域，由内到外，之后查找当前的全局作用域(模块文件)，最后再内置作用域，__全局声明将会直接从全局作用域进行搜索__

```python
x = 99

def f1():
	x = 88
	def f2():
		print(x)
	# f2是f1本地作用域中的变量，f2是一个临时函数
	f2()

f1()
> 88

# 嵌套作用域的查找在嵌套函数已经返回后也是有效的
def f1():
	x = 88
	def f2():
		print(x)
	return f2
action= f1()
action()
>88
```

f2的函数的调用是在f1运行后发生的，f2记住了在f1中嵌套作用域中的x,尽管f1已经不处于激活状态

##### 工厂函数

闭包（closure）有时也叫工厂函数——==一个能记住嵌套作用域的变量值的函数==，尽管那个作用域或许已经不存在了。

尽管类是最适合用作记忆状态的，因为它通过属性赋值让这个过程变得很明了，工厂函数也提供了替代方案

```python
def maker(N):
    def action(x):
        return x**N
    return action
f = maker(2)
f
><function __main__.maker.<locals>.action(x)>
f(3)
>9
f(4)
>16
```

内嵌函数记住了整数2，即变量N的值，尽管调用执行f时maker已经返回退出，实际上本地作用域内的N被==作为执行的状态信息保留了下来==

```python
g = maker(3)
g(3)
>27
```

对一个工厂函数的每次调用，都得到了自己的状态信息的集合，我们赋给g的函数记住了3，f记住了2，每个函数都有自己的状态信息由maker中的变量N保持

嵌套的作用域常常被lambda函数创建表达式使用

嵌套作用域和lambda

lambda是一个表达式

尽管对于def本身来说，嵌套作用域很少用，但是当开始编写lambda表达式时，就要注意了，lambda引入了新的本地作用域

```python
def fun():
    x = 4
    action = (lambda n:x ** n)
    return action

a = fun()
a(2)
>16
```

##### 作用域与带有循环变量的默认参数相比较

```python
def makeAction():
    acts = []
    for i in range(5):
        acts.append(lambda x: i ** x)
    return acts
acts = makeAction()
acts
>[<function __main__.makeAction.<locals>.<lambda>(x)>,
 <function __main__.makeAction.<locals>.<lambda>(x)>,
 <function __main__.makeAction.<locals>.<lambda>(x)>,
 <function __main__.makeAction.<locals>.<lambda>(x)>,
 <function __main__.makeAction.<locals>.<lambda>(x)>]

acts[0](2)
>16
acts[3](2)
>16
```

如果lambda或def在函数中定义，嵌套在一个循环中，并且嵌套的函数引用了一个上层作用域的变量，该变量被循环所改变，所有在这个循环中产生的函数将会有相同的值——==在最后一次循环完成时被引用的变量==

这是在嵌套作用域的值和默认参数方面遗留的一种仍需解释清楚的情况，而不是引用所在嵌套作用域的值

也就是说，为了让这类代码能==工作==，必须==使用默认参数把当前的值传递给嵌套作用域的变量==，==默认参数是在嵌套函数创建时评估的（而不是在调用时），每个函数记住了自己的变量i的值==

```python
def makeAction():
    acts = []
    for i in range(5):
        acts.append(lambda x, i=i: i ** x)
    return acts

f = makeAction()
f[0](2)
>0
f[4](2)
>16
```

##### 任意作用域的嵌套

作用域可以做任意的嵌套，但是只有内嵌的函数（而不是类）会被搜索

```python
def f1():
    x = 99
    def f2():
        def f3():
            print(x)
        f3()
    f2()
f1()
>99
```

python 将会在所有内嵌的def中搜索本地作用域，从内至外，在引用过函数的本地作用域之后，并在搜索模块的全局作用域之前进行这一过程

#### nonlocal 语句

nonlocal时global的近亲，声明了将要在嵌套作用域中修改的名称，nonlocal 应用于==一个嵌套的函数作用域中的一个名称==，而不是所有def之外的全局模块作用域

声明nonlocal的时候，它必须已经存在于该嵌套函数作用域中——它可能只存在于一个嵌套的函数中，并且不能由一个嵌套的def中的第一次赋值创建

##### nonlocal 基础

python3新引入的，它只在一个函数内由意义

```
def fun():
    nonlocal name1,name2,...
```

##### nonlocal 应用

```python
# tester构建并返回nested函数，以便随后使用
def tester(start):
    state = start
    def nested(label):
        print(label, state)
    return nested

F = tester(0)
F('spam')
```

默认情况下，不允许修改嵌套的def作用域中的名称，修改会报错

```python
def tester(start):
    state = start
    def nested(label):
        print(label,state)
        # 尝试修改嵌套作用域变量
        state += 1
    return nested
F = tester(0)
F('spam')
>UnboundLocalError: local variable 'state' referenced before assignment(在赋值前引用)
```

##### 使用nonlocal修改

我们在nested中把tester作用域中的state声明为一个nonlocal,我们就可以在nested函数中修改它了，尽管我们调用返回的nested函数时tester已经返回退出，这也是有效的

```python
def tester(start):
    state = start
    def nested(label):
        nonlocal state
        print(label,state)
        # 修改嵌套作用域变量
        state += 1
    return nested
F = tester(0)
F('spam')
> spam 0
F('adam')
> adam 1
```

##### 边界情况

当执行nonlocal语句时，==nonlocal名称必须已经在一个嵌套的def作用域中赋值过==，否则会报错

```python
def tester(start):
    def nested(label):
        nonlocal state
        print(label,state)
        # 修改嵌套作用域变量
        state += 1
    return nested
F = tester(0)
F('spam')
> SyntaxError: no binding for nonlocal 'state' found
```

nonlocal限制作用域查找仅为嵌套的def,nonlocal不会在嵌套的模块的全局作用域或所有def之外的内置作用域中查找（即使已经有了这些作用域）

```python
state = 11
def tester(start):
    def nested(label):
        nonlocal state
        print(label,state)
        # 修改嵌套作用域变量
        state += 1
    return nested
F = tester(0)
F('spam')
> SyntaxError: no binding for nonlocal 'state' found
```

##### 为什么使用nonlocal

python中有不同的方法来“记住”跨函数和方法的信息，尽管都有利有弊，对于嵌套的作用域引用，nonlocal起到了改进作用——nonlocal语句允许在内存中保持可变状态的多个副本，并且解决了在类无法保证的情况下的简单状态保持

每次调用都创建了可变信息的一个小小的自包含包，可变信息的名称不会与程序的其他部分产生冲突

##### 与全局共享状态

python2.6中实现nonlocal效果的一种通常做法是直接把状态移出全局作用域（模块的嵌套）

```python
def tester(start):
    global state
    state = start
    def nested(label):
        global state
        print(label, state)
        state += 1
    return nested

F = tester(0)
F('spam')
> spam 0
F('abc')
>abc 1
F('eee')
>eee 2

FF = tester(10)
FF('adam')
>adam 10
F('ham')
>ham 11
```

代码是有效的，需要在两个函数中都有global声明，问题是只考虑了模块作用域中状态信息的单个共享副本，如果我们再次调用terster,将会重置模块的状态变量，以至于前面的调用状态被覆盖

##### 使用类的状态

python2中针对可改变信息的另外一种较早的方法是使用带有属性的类

```python
class tester:
    def __init__(self,start):
        self.state = start
    def nested(self, label):
        print(label,self.state)
        self.state += 1
        
F = tester(0)
F.nested('spam')
> spam 0
F.nested('ham')
> ham 1

G = tester(12)
G.nested('toast')
> toast 12
F.nested('bacon')
> bacon 2
```

我们可以利用运算符重载让类看上去像是一个可调用函数，\_\_call\_\_ 获取了一个实例的直接调用，我们不需要调用一个指定的方法

```python
class tester:
    def __init__(self, start):
        self state = start
    def __call__(self, label):
        print(label, self.state)
        self.state += 1

H = tester(99)
H('juice')
> juice 99
H('pancakes')
> pancakes 100
```

- [ ] ##### 使用函数属性的状态

我们有时候使用函数属性实现与nonlocal相同的效果——用户 定义的名称直接附加给函数

```python

```



#### 习题：

```python
# 练习1
# 全局变量
X = 'Spam'
def func():
    print(x)
> Spam

# 练习2
X = 'Spam'
def func():
    X = 'NI'
func()
print(X)
> Spam

# 练习3
X = 'Spam'
def func():
    X = "NI"
    print(X)
func()
print(X)
>NI
>Spam

# 练习4
X = 'Spam'
def func():
    global X
    X = 'NI'
func()
print(X)
> NI

# 练习5
X = 'Spam'
def func():
    X = 'NI'
    def nested():
        print(X)
    return nested
func()
X
> NI
>Spam

# 练习6
def func():
    X = 'NI'
    def nested():
        nolocal X
        X = 'Spam'
    nested()
    print(X)
func()
> Spam
```

###### 函数中保存状态信息的方法

尽管函数返回的时候本地变量已经不存在了，我们可以使用共享的全局变量，嵌套函数内的嵌套函数作用域引用 ，或者使用默认参数值来保持状态信息

函数属性有时候允许把状态附加到函数自身，而不是在作用域中查找



### 第十八章_参数

#### 传递参数

参数是通过赋值来传递的。

- 参数的传递是通过自动将对象赋值给本地变量名来实现
- 在函数内部的参数名的赋值不会影响调用者
  - 在函数头部的参数名是一个新的、本地的变量名
- 改变函数的可变对象参数的值也许会对调用者有影响
- 不可变参数通过值进行传递
- 可变对象通过指针进行传递

##### 参数和共享引用

```python
def f(a):
    a = 99
b = 88
f(b)
print(b)
> 88
```

函数调用的时候变量a赋值了对象88，这是没有名称冲突的含义——对函数中一个参数名的赋值不会影响到函数调用作用域中的变量（函数第一次调用时，只要对参数名重新赋值，这种关系就结束了）

当参数传递像列表和字典这样的可修改对象时，对象的原处修改可能会在函数退出后依然有效，并影响的调用者

```python
def changer(a, b):
    a = 2
    b[0] = 'spam'
X = 1
L = [1, 2]
changer(X, L)
X，L
> (1, ['spam', 2])
```

a是函数作用域内的本地变量名，第一个赋值对函数调用者没有影响，仅把本地变量a修改

b是一个本地变量名，被传给了一个可变对象，对b[0]的赋值结果会在函数返回后影响L的值

![010](D:\project\pycon\Python_学习手册\img\010.JPG)

第二条语句并没有修改b,修改的是b当前所引用对象的一部分，这种原处修改只有在修改的对象比函数调用生命更长的时候，才会影响到调用者

##### 避免可变参数的修改

如果不想要函数内部在原处的修改影响传递给它的对象，可以简单的创建一个明确的可变对象的拷贝

#### 特定的参数匹配

##### 基础知识

- 位置：从左至右匹配
- 关键字参数：通过参数名匹配
- 默认参数：为没有传入值的参数定义参数值
- 可变参数：收集任意多基于位置或关键字的参数，以字符 * 开头
- 可变参数解包：传递任意多的基于位置或关键字的参数，调用者使用*语法将参数打散
- keyword_only参数：参数必须按照名称传递

##### 位置参数

```python
# 调用时必须传入仅有的一个参数x
def power(x):
    return x*x
power(5)
> 25
```

进一步修改为$x^n$的求解

```python
def power(x,n):
    return x**n
# x和n都是位置参数，传入的两个值按照位置以此赋值给x和n
```

##### 默认参数

默认参数允许创建函数可选的参数，如果没有传入值的话，在函数运行前，参数就被赋予了默认值

降低调用函数的难度

power(x,n)函数定义没有问题，但是旧的代码`power(5)`失效了，因为缺失一个参数，这时候默认参数就派上用场

```python
def power(x,n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s*x
    rerurn s
power(5)
>25
```

默认参数可以简化函数的调用，设置默认参数需要注意：

- 必选参数在前，默认参数在后（为什么？）
  - 
- 如何设置默认参数
  - 变化大的参数放在前面，变化小的放后面，变化小的可以作为默认参数

```python
# 我们编写一个学生注册函数
def enroll(name, gender):
    print('name:',name)
    print('gender:', gender)
# 调用函数只需要传入两个参数 enroll('adam', 'F')

# 如果我们要继续传入年龄，城市，这样函数调用难度加大，我们可以把年龄和城市设为默认参数
def enroll(name, gender, age=6, city='Beijing'):
    print('name:', name)
    print('gender:', gender)
    print('age:', age)
    print('city:', city)
# 这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：
 enroll('Sarah', 'F')
# 只有与默认参数不符的学生才需要提供额外的信息
enroll('Adam', 'M', city='Tianjin')
```

- 如何使用默认参数
  - 有多个默认参数时，调用的时候可以==按顺序==提供默认参数
    - `enroll('Bob', 'M', 7)`
  - 可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上
    - `enroll('Adam', 'M', city='Tianjin')`

- 默认参数的坑

  ```python
  def add_end(L=[]):
      L.append('END')
      return L
  # 正常调用
  add_end([1, 2, 3])
  > [1, 2, 3, 'END']
   add_end(['x', 'y', 'z'])
  > ['x', 'y', 'z', 'END']
  
  # 使用默认参数调用
  add_end()
  > ['END']
  add_end()
  > ['END', 'END']
  ```

  Python函数在定义的时候，默认参数`L`的值就被计算出来了，即`[]`，因为默认参数`L`也是一个变量，它指向对象`[]`，每次调用该函数，如果改变了`L`的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的`[]`了

- ==默认参数必须指向不变对象==
- name = value语法
  - 在调用中意味着通过变量名进行匹配
  - 在函数头部为一个可选的参数定义默认值

##### 可变参数

可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。

```python
# 给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……
def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
# 调用的时候，需要先组装出一个list或tuple
calc([1, 2, 3])

# 利用可变参数，调用函数的方式可以简化成这样
calc(1, 2, 3)
# 把函数的参数改为可变参数：
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
```

定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple,`def calc(*numbers)`中的*号是==打包==作用

如果已经有一个list或者tuple，要调用一个可变参数怎么办？

```python
# 可以这样
nums = [1, 2, 3]
calc(nums[0], nums[1], nums[2])
# 写法当然是可行的，问题是太繁琐

# Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去
calc(*nums)
# *nums表示把nums这个list的所有元素作为可变参数传进去
```

##### 关键字参数

可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict

```python
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
# 函数`person`除了必选参数`name`和`age`外，还接受关键字参数`kw`
person('Michael', 30)
>name: Michael age: 30 other: {}
            
# 也可以传入任意个数的关键字参数：
 person('Adam', 45, gender='M', job='Engineer')
```

关键字参数可以扩展函数的功能

和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去

````python
extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra)
````

`**extra`表示把`extra`这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，`kw`将获得一个dict，注意`kw`获得的dict是`extra`的一份拷贝，对`kw`的改动不会影响到函数外的`extra`

- 关键字参数通过变量名匹配，而不是位置 

##### 命名关键字参数

对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数

如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收`city`和`job`作为关键字参数,这种方式定义的函数如下：

```python
def person(name, age, *, city, job):
    print(name, age, city, job)
```

和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。

如果函数定义中已经==有了一个可变参数==，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了,如果==没有可变参数==，就必须加一个`*`作为特殊分隔符。如果缺少`*`，Python解释器将无法识别位置参数和命名关键字参数

```python
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
```

命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错

```python
person('Jack', 24, 'Beijing', 'Engineer')
 > TypeError: person() takes 2 positional arguments but 4 were given
# 由于调用时缺少参数名city和job，Python解释器把这4个参数视为位置参数，但person()函数仅接受2个位置参数
```

命名关键字参数可以有缺省值，从而简化调用：

```python
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
```

##### 解包参数

在调用函数时能

- 使用*进行解包参数集合
- 使用** 以键/值 对的形式解包字典

##### 小结：

- 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误
- ==`*args`是可变参数==，args接收的是一个tuple
  - 可变参数既可以直接传入：`func(1, 2, 3)`，又可以先组装list或tuple，再通过`*args`传入：`func(*(1, 2, 3))`；
- `**kw`是关键字参数，kw接收的是一个dict
  - 关键字参数既可以直接传入：`func(a=1, b=2)`，又可以先组装dict，再通过`**kw`传入：`func(**{'a': 1, 'b': 2})`
- 使用`*args`和`**kw`是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法
- 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
- 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符`*`，否则定义的将是位置参数



### 第十九章_函数的高级话题

这章介绍高级的与函数相关的话题：递归函数、函数属性、注解、lambda表达式、map、filter

#### 设计理念

如何将任务分解为有针对性的函数（导致了聚合性）、函数将如何通信（耦合性）

- 耦合性：
  - 对于输入使用参数并且输出使用return的语句（力求让函数独立于外部的东西）
  - 只有在真正必要的时候使用全局变量（全局变量是一种蹩脚的函数间通信的办法）
  - 不要改变可变类型的参数，除非调用者希望这样（函数会改变传入的可变类型对象，导致函数过于特殊和不友好）
- 聚合性：
  - 每个函数都该有单一的统一的目标
- 每个函数应该相对较小（保持简单，简短）



函数与外部世界的通信：

![011](D:\project\pycon\Python_学习手册\img\011.JPG)

输入可能来自于左侧的元素，结果能以右侧的任意一种形式输出

#### 递归函数

- 递归求和

```python
def mysum(L):
    print(L)
    if not L:
        return 0
    else:
        return L[0] + mysum(L[1:])
    
mysum([1,2,3,4,5])
>[1, 2, 3, 4, 5]
[2, 3, 4, 5]
[3, 4, 5]
[4, 5]
[5]
[]
```

递归的时候，对函数调用的每一个打开层级，运行时调用堆栈上都有自己的一个函数本地作用域的副本，意味着L在每个层级都是不同的

- 替代方案

```python
# 我们可以使用三元表达式来实现
def mysum1(L):
    return 0 if not L else L[0] + mysum(L[1:])

def mysum2(L):
    return L[0] if len(L)==1 else L[0]+mysum(L[1:])

def mysum3(L):
    first,*rest = L
    return first if not rest else first+mysum(rest)
```

后面两个时由于空列表而退出，但是考虑到支持 + 的任何对象类型的序列，而不只是数字

第一种第二种类似第三种，但第一二种期待单个参数，而不是单独的可迭代对象

递归函数可以是直接的，也可以是间接的，就像下面的例子（一个函数调用另外一个函数，后者反过来调用其调用者）

```python
def mysum4(L):
    if not L:return 0
    return nonempty(L)

def nonempty(L):
    return L[0] + mysum4(L[1:])
mysum4([1,2,3,4])
>
10
```

#### 循环语句VS递归

递归对于一些例子有效，但过于追求技巧，while常常使事情更为具体一些

```python
L = [1,2,3,4,5]
sum = 0
while L:
    sum += L[0]
    L = L[1:]
sum
>15

# for循环
L = [1,2,3,4,5]
sum = 0
for i in L:sum += i
sum
>15
```

#### 处理任意结构

递归可要求遍历任意形状的结构

```python
ll = [1,[2,[3,4],5],6,[7,8]]
def sumtree(L):
    tot = 0
    for x in L:
        if not isinstance(x,list):
            tot += x
        else:
            tot += sumtree(x)
    return tot
sumtree(ll)
```

### 函数对象：属性和注解

python函数是俯拾皆是的对象，全部存储在内存块中，可以跨程序自由的传递和调用，也支持与调用根本无关的操作——数学和注解

#### 间接函数调用

函数对象可以赋值给其他名称，传递给其他函数，嵌入到数据结构，从一个函数返回给另外一个函数

def运行之后，函数名直接是一个对象的引用——可以将其赋值给其他的名称并且调用

```python
def echo(message):
    print(message)
    
echo('hello')
a = echo
a('world')
```

把函数对象嵌入到数据结构中

```python
schedule = [(echo,'Spam'),(echo, 'Ham')]
# 元组解包赋值
for (func,arg) in schedule:
    func(arg)
```

函数可以以便后续使用

```python
def make(label):
    def echo(message):
        print(label + ":" + message)
    return echo

F = make('spam')
F('Eggs')
>
spam:Eggs
```

#### 函数内省

内省工具允许我们探索实现细节，例如函数附加了代码对象——提供了函数本地变量和参数方面的细节

```
func.__name__
func.__code__
dir(func)
dir(func.__code__)
```

工具编写者可以根据这些信息来管理函数

#### 函数属性

我们可向 函数附加任意用户定义的属性

```
make.count =2
make.count += 2
make.count
>4
dir(make)
>['__annotations__',
 '__call__',
 '__class__',
 '__closure__',
 '__code__',
 '__defaults__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__get__',
 '__getattribute__',
 '__globals__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__kwdefaults__',
 '__le__',
 '__lt__',
 '__module__',
 '__name__',
 '__ne__',
 '__new__',
 '__qualname__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 'count']
```

这样的属性可以用来直接把状态信息附加到函数对象，而不必使用全局、非本地等技术，不同于非本地，这样的属性可以在函数自身的任何地方访问，这种变量的名称对函数来说是本地的，但是其值在函数退出后任然保留

属性与对象相关而不是与作用域相关

#### 函数注解

可以给函数添加注解信息——与函数的参数和结果相关的任意用户自定义数据。

python为声明注解提供了特殊的语法，但是它自身不做任何事情，出现的时候只是附加到函数对象的\_\_annotations\_\_属性

从语法上讲，函数注解编写在def头部，对于参数，他们出现在紧随参数名之后的冒号之后，对于返回值，编写在紧跟参数列表之后的一个 -> 之后，

```python
def func(a:'spam',b,c:99) -> int:
    return a+b+c

func(1,2,4)
> 7
func.__annotations__
>{'a': 'spam', 'c': 99, 'return': int}
```

当注解出现的时候，python将其收集到字典中并将其附加给函数自身，函数名变为键，如果编写了返回值注解，它存储在return下

编写了注解任然可以对函数使用默认值，注解出现在默认值之前

```python
def fun(a:'spam' = 4, b:(1,10) = 5,c: float =6) -> int:
    return a+b+c
fun()
>15
fun.__annotations__
>{'a': 'spam', 'b': (1, 10), 'c': float, 'return': int}
```

注解是py3的新功能，可以作为参数类型和值的特定限制，是一种功能随着你的想象来变化工具

注解只在def语句中有效，在lambd中无效，因为lambda语法已经限制了它所定义的函数工具



### 匿名函数：lambda

一种生成函数对象的表达式形式，由于它与LISP语言中的一个工具很类似所以称为lambda,,表达式创建了一个可调用的函数，它返回了一个函数，而不是将函数赋值给变量——匿名函数（没有变量名）

#### lambda表达式

lambda关键字 ，之后是多个或一个参数，紧跟一个冒号，之后是表达式

`lambda arg1,arg2,...argN:expression using arguments`

- lambda是一个表达式而不是一个语句
  - lambda能够出现在python语法不允许def出现的地方（列表常量中或函数调用的参数中）
  - lambda返回一个新的函数，可以选择性的赋值给变量，def语句总是得再开头将一个新的函数赋值给一个变量名
- lambda主体是一个单个的表达式，而不是一个代码块
  - 通常比def功能小，能封装有限的逻辑，连if 这样的语句都不能使用——有意限制程序的嵌套
  - lambda是为编写简单的函数而设计的，而def是用来处理更大的任务

```python
def func(x,y,z): return x+y+z
func(2,3,4)
> 9

f = lambda x,y,z: x+y+z
f(2,3,4)
> 9
```

默认参数也是能够在lambda中使用的

```python
x = (lambda a = 'fee', b = 'fie', c = 'foe': a+b+c)
x()
>'feefiefoe'
```

lambda表达式引入的一个本地作用域更像是一个嵌套的def语句，将会自动从上层函数中、模块中、内置作用域中（LEGB）查找变量名

```python
def knights():
    title = 'Sir'
    action = (lambda x:title + ' ' + x)
    # return a function
    return action
act = knights()
act('robin')
>'Sir robin'
```

py2中，title变量名通常会改为默认参数的形式传入，具体原因详17章节

#### 为什么使用lambda

lambda起到了一种函数速写的作用，允许在使用的代码内嵌入一个函数的定义，会带来更简洁的代码结构

lambda通常用来编写跳转表（jump table）,也就是能执行动作的列表或字典

```python
L = [lambda x: x**2,
    lambda x: x**3,
    lambda x: x**4]

for f in L:
  print(f(2))
> 4
8
16
```

当需要把小段的可执行代码编写进def语句不能编写进的地方时，lambda最为有用，

我们可以使用字典或者其他数据结构来构建更多的行为表

```python
key = 'got'
{'already':(lambda :2+2),
'got':(lambda:3*4),
'one':(lambda:2**6)}[key]()
>12
```

#### 嵌套lambda和作用域

lambda是嵌套函数作用域查找的最大受者,==lambda出现在def中，在上层函数调用的时候，lambda能够获取到上层函数作用域中的变量==

```python
def action(x):
  return (lambda y: x + y)

act = action(3)
act(4)
>7
```

lambda也能够获取任意上层lambda中的变量名

```python
action = lambda x:(lambda y: x+y)
# 返回lambda函数
act = action(4)
act(5)
>9
```

处于可读性的需求，最好避免使用嵌套lambda

### 在序列中映射函数：map

程序对列表或其他序列常常要做的就是对每一个元素进行一个操作并把结果集合起来

python提供了内置的工具map,对一个序列对象中的每个元素应用传入的函数，并且返回一个包含了所有调用结果的列表

```python
def power(x):return(x**4) 
list(map(power,range(3)))
```

`list(map_obj)`不同于`[map_obj]`

map生成==map对象==需要list转换，range生成==range对象==(可迭代)

map是可迭代对象

```
map()
map(func, *iterables) --> map object
```

map期待传入一个函数，这恰好是lambda通常出现的地方

map还有一些性能优势，比自己编写的for循环更块

map提供了多个序列作为参数，能够并行返回以每个序列中的元素作为函数对应参数得到的结果

- 对于多个序列，map期待一个N参数的函数作用于N序列

  ```python
  # pow需要两个参数
  list(map(pow,range(3),range(3,6)))
  [0, 1, 32]
  ```

### 函数式编程工具:filter 和 reduce

函数式编程就是对序列应用一些函数工具

- 基于某一测试==过滤==出一些元素---filter
- 对每对元素==应用函数==并运行得到结果---reduce

range和filter都返回==可迭代对象==，需要使用list来显示其结果

```python
list(filter(lambda x:x>0,range(-5,5)))
>[1, 2, 3, 4]

# 等价for循环
l = []
for i in range(-5,5):
    if i > 0:
        l.append(i)
l
>[1, 2, 3, 4]
```

reduce 在python3中位于functools模块中，`reduce`把一个函数作用在一个序列`[x1, x2, x3, ...]`上，这个函数必须接收两个参数，`reduce`把结果继续和序列的下一个元素做累积计算

```python
from functools import reduce
reduce((lambda x,y:x+y),[1,2,3,4])
>10

# 手动实现reduce
# 编写自己的reduce
def myreduce(fun,seq):
    tal = seq[0]
    for i in seq[1:]:
        tal = fun(tal,i)
    return tal

myreduce(lambda x,y:x+y,range(2,5))
```

小结：

- lambda和def都会创建函数，以便稍后调用，==lambda是表达式==，可嵌入def语法无法出现的地方，lambda的使用def总是可以用替代，
- lambda允许内联小代码块，推迟其执行，并且以默认参数和封闭作用域的变量的形式提供状态
- map\reduec\filter三个函数都对一个序列中的各项应用另一个函数
  - map把每一项传递给函数并收集结果
  - filter收集函数返回的True值的项
  - reduce通过对一个累加器和后续项应用函数来计算一个单个的值

- 递归函数调用本身可以直接或间接的进行，从而实现循环
- 函数通常应该较小，尽可能自包含，拥有单一的、统一的用途，并且与输入参数和返回值等其他部分通信，



### 第二十章_迭代和解析（第二部分）

列表解析在一个序列的值上应用一个任意表达式，将其结果收集到一个新的列表中并返回

#### 列表解析与map

- 内置ord函数会返回一个单个字符的ascii整数编码（chr内置函数是它的逆向过程——将一个ascii整数编码转换为字符）  

  - 循环实现
  - map实现
    - 使用map可以使用单个的函数调用，而不必关心列表中的结构
  - 列表解析实现

  > 列表解析在一个序列上应用一个任意表达式，将结果收集到一个新的列表中并返回，它的形式是在方括号中编写一个表达式
  >
  > - 当对一个序列应用一个表达式的时候，列表解析更方便
  >
  >   `[x ** 2 for x in range(10)]`
  >
  > - 当需要在行内创建一个临时函数时，使用 lambda
  >
  >   `list(map((lambda x:x**2),range(10)))`

#### 增加测试与嵌套循环

可以在for之后编写一个if分支，用来增加选择逻辑

```
[x for x in range(5) if x % 2 == 0]
list(filter((lambda x: x%2 ==0),range(5)))
```

求余： % 

map 迭代中混合filter 选择过程：

```
list(map((lambda x: x**2),filter((lambda x:x % 2 ==0),range(10))))
```

- 通用的列表解析结构

  ```
  [expression for target1 in iterable1 [if condition1]
  			for target2 in iterable2 [if condition2] ...
  			for targetN in iterableN [if conditionN]]
  ```

#### 重访迭代器：生成器

python对延迟提供更多的支持——在需要的时候产生结果，而不是立即产生

- 生成器函数：编写为常规的def语句，使用yield 语句一次返回一个结果，在每个结果之间挂起和继续状态
- 生成器表达式：类似于列表解析，返回按需要产生结果的一个对象，而不是一个结果列表
  - 两者都不会一次性构建一个列表，他们节省了内存空间，允许计算时间分散到各个结果请求

##### 生成器函数： yield VS　return

状态挂起：生成器函数在挂起时保存的状态包含他们整个本地作用域，当函数恢复时，他们的本地变量保持了信息并且使其可用

和常规函数的不同：生成器yields一个值，而不是返回一个值，yields语句挂起函数并向调用者返回一个值，并保留足够的状态使函数能从离开的地方继续

##### 迭代协议整合

- 可迭代的对象定义了一个\_\_next\_\_方法,要么返回迭代中的下一项，要么引发一个StopIteration异常来终止迭代
- 一个对象的迭代器用iter内置函数接收

如果支持这种协议，for循环或其他迭代背景使用这种协议来遍历一个序列或值生成器，如果不支持，迭代返回去重复索引序列

- 要支持这一协议，函数包含一条yield语句，该语句特别编译为生成器，调用时返回一个迭代器对象，该对象支持\_\_next\_\_自动创建方法来继续执行接口，生成器函数也可能有一条return语句，总是在def语句的末尾，直接终止值的生成，

简单来说：生成器函数，编写为包含yield语句的def语句，自动的支持迭代协议，并且由此可能用在任何迭代环境中以随着时间并根据需要产生结果

##### 生成器函数应用

```python
# 一个不断生成一系列数平方的函数
def genesquares(N):
    for i in range(N):
        yield i**2
        
# 每次循环时产生一个值，之后将其返还给其他调用者，暂停后，在yield语句之后控制器马上被回收
# 当用在for循环中时，每一次完成yield语句后，控制权返还给函数
for i in genesquares(5):
    print(i,end=":")
>>> 0:1:4:9:16:
                    
                    
x = genesquares(4)
x
>>><generator object genesquares at 0x000001DA049454F8>
# 得到的是一个生成器对象，支持迭代协议，也就是说有一个__next__方法
# next内置方法为我们调用一个对象的 X.__next__()方法
next(x)
>>>0

# 对于这样的例子，我们可以使用for循环，map或者列表解析来实现
for x in [n**2 for n in range(5)]:
    print(x,end=":")
    
for x in map((lambda x:x**2),range(5)):
    print(x,end=":")
   
```

尽管如此，生成器在内存使用和性能方面都更好，当结果的列表很大或处理每一个结果需要很多时间，这时优先使用，==生成器将在loop迭代中处理一系列值的时间分布开来,有了生成器，函数变量就能自动的保存于恢复==

##### 扩展生成器函数协议：send和next

==生成器函数增加了一个send方法，生成一系列结果的下一个元素==，这一点就像\_\_next\_\_ 方法一样，它提供了一中与调用者与生成器之间的通信方法，能够影响它的操作

yield现在是一个表达式的形式，表达式必须包含在括号中，除非它是赋值语句右边的唯一项

```python
# 例如
x = yield Y
# 或者
x = (yield Y) + 42
```

当使用这一额外的协议时，值可以通过调用G.send(value) 发送给一个生成器G ,之后恢复生成器的代码，并且生成器中的yield表达式==返回了为了发送而传入的值==，如果提前调用了正常的G.\_\_next\_\_（）方法（或者对等的next(G)）,yield返回None

```python
def gen():
    for i in range(10):
        x  = yield i
        print(x)

g = gen()
next(g)
>>> 0
next(g)
>>>None
>1
g.send(77)
>>>77
>2
```

- send vs next 总结：







#### 生成器表达式：迭代器遇到列表解析

迭代器和列表解析形成了一个新的特性：生成器表达式

生成器表达式类似于列表解析，但是他们是在圆括号中而不是在方括号中

```
# 列表解析
[x ** 2 for x in range(4)]
>>>
[0, 1, 4, 9]
# 生成器表达式
(x ** 2 for x in range(4))
>>>
<generator object <genexpr> at 0x0000028ABD75D390>
```

生成器表达式不是在内存中构建结果，而是返回一个生成器对象，该对象支持迭代协议

我们不会机械的使用next,因为for循环会自动触发

==迭代语境：==会自动除法迭代的内置函数

- sum、map、sorted、any、all、list ...

如果生成器表达式是在其他的括号内，就像在那些函数调用之中，这种情况下，生成器自身的括号就不必要

````python
sum(s**2 for s in range(4))
>>>
14
sorted(x**2 for x in range(4))
>>>
[0, 1, 4, 9]
# 有额外参数时，需要加括号
sorted((x**2 for x in range(4)),reverse=True)
>>>
[0, 1, 4, 9]
````

生成器表达式可以认为是对内存空间的优化，不会一次构造出整个列表，实际运行可能稍慢一些，对于非常大的结果集合的运算时最优的选择

#### 生成器函数 VS　生成器表达式

同样的迭代，往往可以用一个生成器函数或生成器表达式编写

等价的生成器函数略微多一些代码，但可以编写更多的逻辑和更多的状态信息

生成器是单次迭代器

#### 生成器是单迭代器对象

生成器函数和生成器表达式自身都是迭代器，只支持==一次活跃迭代==

一个生成器的迭代器是生成器本身（在一个生成器上调用iter没有任何效果）

```python
G = (c * 4 for c in 'sapm')
iter(G) is G
>>>
True

# 手动的使用多个迭代器来迭代结果流，会指向相同的位置
G = (c * 4 for c in 'spam')
I1 = iter(G)
next(I1)
>>>
'ssss'
next(I1)
>>>
'pppp'
I2 = iter(G)
next(I2)
>>>
'aaaa'
next(I1)
>>>
'mmmm'
next(I2)
>>>
StopIteration                             Traceback (most recent call last)
```

一旦任何迭代器运行到完成，所有的迭代器都将用尽，必须产生一个新的生成器以再次开始

```python
I3 = iter(G)
next(I3)
>>>
StopIteration                             Traceback (most recent call last)

I3 = iter(c*4 for c in 'spam')
next(I3)
>>>
'ssss'
```

对于生成器函数来说也是如此，只支持一个活跃的生成器并且在一次迭代后用尽

```python
def timesfour(s):
    for c in s:
        yield c*4

G = timesfour('spam')
iter(G) is G
>>>
True
I1,I2 = iter(G),iter(G)
next(I1)
>>>'ssss'
next(I1)
>>>'pppp'
next(I2)
>>>'aaaa'
```

对于某些内置类型，他们支持多个迭代器并且在一个活动迭代器中传递并反映他们的原处修改

```python
L = [1,2,3,4]
I1,I2 = iter(L),iter(L)
I1 is I2
>>> False
next(I1)
>>>1
next(I1)
>>>2
next(I2)
>>>1
del L[2:]
next(I1)
>>>StopIteration                             Traceback (most recent call last)
next(I2)
>>>2
next(I2)
>>>StopIteration                             Traceback (most recent call last)
```

#### 用迭代工具模拟zip和map

```
zip([iterable, ...])
# 输入一个或多个迭代器
# 返回元组列表
```

```
list(zip([1,2,3],[2,3,4,5]))
>>>
[(1,2),(2,3),(3,4)]

list(zip([1,2,3]))
>>>
[(1,), (2,), (3,)]
list(map(pow,[1,2,3],[1,2,3]))
>>>[1, 4, 27]
[((1,),), ((2,),), ((3,),)]
```

##### 编写自己的map（func, ...）

```python
def my_map(func,*seqs):
    result = []
    for args in zip(*seqs):
        result.append(func(*args))
    return result
a = my_map(pow,[1,2,3],[4,5,6])
>>>
[1, 32, 729]
my_map(abs,[1,-2,-3,4])
>>>
[1, 2, 3, 4]
```

这个版本依赖于特殊的 * args 参数传递，==它收集多个序列（可迭代对象）参数==，将其作为zip参数  解包  以便组合，然后成对的zip结果解包作为参数传入到函数

zip是map中的一个基本嵌套操作

利用列表解析实现更精简的my_map：(运行的更快，之前的map一次性构建结果列表，对于较大的列表，可能浪费内存)

```python
def my_map(func,*seqs):
    return [func(*args) for args in zip(*seqs)]
print(my_map(pow,[1,2,3],[4,5,6]))
print(my_map(abs,[1,-2,-3,4]))
>>>
[1, 32, 729]
[1, 2, 3, 4]
```

- 利用生成器函数和表达式实现

  ```python
  # 使用yeild
  def my_map(func,*seqs):
      for args in *seqs:
          yield func(*args)
  a = my_map(pow,[1,2,3],[4,5,6])
  a
  >>>
  <generator object my_map at 0x0000023138AB46D8>
  
  # 返回一个生成器表达式
  def my_map(func,*seqs):
      return (func(*args) for args in zip(*seqs))
  a = my_map(pow,[1,2,3],[4,5,6])
  a
  >>>
  <generator object my_map.<locals>.<genexpr> at 0x0000023138B51F48>
  ```

  ##### 编写自己的zip(...)和map(None, ...)

   ```python
  def my_zip(*seqs):
      seqs = [list(s) for s in seqs]
      res = []
      # 测试序列的真假，以最短的列表生成结果
      while all(seqs):
          res.append(tuple(s.pop(0) for s in seqs))
      return res
  print(my_zip([1,2,3],[4,5,6]))
  >>>
  [(1, 4), (2, 5), (3, 6)]
   ```

  自带的map会生成最短的匹配

  ```
  list(map(pow,[1,2,3],[2,3]))
  >>> [1, 8]
  ```

  编写会自动填充的map

  ```python
  def mypadmap(*seqs,pad=None):
      seqs = [list(s) for s in seqs] 
      res = []
      # 判断是否有序列为真，以便进行填充
      while any(seqs):
          res.append(tuple(s.pop(0) if s else pad for s in seqs))
  mypadmap((1,2,3),[4,5,6])
  >>>
  [(1, 4), (2, 5), (3, 6)]
  ```

  注意all和any函数的应用，如果一个可迭代对象中的所有元素为True或False,分别返回True和False,用来停止循环

  使用yield将他们转换为生成器以便他们每个都是每次返回结果中的一项

  ```python
  # myzip
  def my_zip(*seqs):
      # 将序列转为 列表的列表
      seqs = [list(s) for s in seqs]
      # 设置条件判断以终止循环
      while all(seqs):
          yield tuple(s.pop(0) for s in seqs)
  # 使用list使其显示
  list（my_zip((1,2,3),[4,5,6])）
  >>>
  [(1, 4), (2, 5), (3, 6)]
  
  # mypadmap
  # 嵌套的列表解析使用了两个层级的延迟计算——python的range是一个可迭代对象
  def mypadmap(*seqs,pad=None):
      # 计算最大的长度
      maxlen = max(len(seq) for seq in seqs)
      index = range(maxlen)
      return [tuple((s[i] if len(s) > i else pad) for s in seqs) for i in index]
  
  mypadmap([1,2,3],[4,5,6])
  >>>
  [(1, 4), (2, 5), (3, 6)]
  ```

#### 内置类型和类中的值生成

字典中拥有每次迭代中产生键的迭代器

```python
D = {'a':1,'b':2,'c':3}
for i in D:
    print(i)
>>>
a
b
c
```

文件迭代器中，python简单的载入了一个文件的行

```python
for line in open('temp.txt'):
    print(line)
```

### python3 解析语法概括

```python
# zip可针对多个序列操作
list(zip([1,2,3],[4,5,6],[7,8,9]))
>>>
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
```



已经学习了列表解析和生成器，还有两种可用的解析表达式：集合解析和字典解析

- 对于集合，新的常量形式{1，4，3}等同于set([1,4,3])

  集合解析语法{f(x) for x in s if P(x)} 等价于 set(f(x) for x in s if P(x))

- 对于字典，{key:val for key,val in zip(keys,vals)}  等价于 dict(zip(keys,vals))

  {x:f(x) for x in items} 等价于 dict((x,f(x)) for x in items)

```python
# list comprehension
[x*x for x in range(10)]
# generator expression
(x*x for x in range(10))
# set comprehension
{x*x for x in range(10)}
# dictionary comprehension
{x:x*x for x in range(10)}
```

#### 集合解析和字典解析

对于列表解析总是可以手动构建

```python
res = set()
for x in range(10):
    res.add(x*x)
    
res = {}
for x in range(10):
    # 向字典中添加键值对
    res[x] = x*x
```

尽管这两种方式都接受迭代器，他们没有根据需要产生结果的概念——两种形式都是一次构建所有对象

如果要根据需求产生键值，生成器表达式更合适

```python
G = ((x,x*x) for x in range(10))
```

#### 针对集合和字典的扩展语法

```python
[x + y for x in [1,2,3] for y in [4,5,6]]
```

### 对迭代的方法计时

#### 对模块计时

```python
import time
reps = 1000
repslist = range(reps)

def timer(func,*pargs,**kargs):
    start = time.clock()
    for i in resplist:
        ret = func(*pargs,**kargs)
    slapsed = time.clock()-start
    return (slapsed,ret)
```

##### 计时脚本

```python
# timer.py
import time

reps = 1000
repslist = range(reps)

def timer(func,*pargs, **kargs):
    start = time.clock()
    for i in repslist:
        ret = func(*pargs,**kargs)
    elapsed = time.clock() - start
    return (elapsed, ret)
# 生成耗时和结果
```

计时测试

```python
import sys,timer
reps = 10000
repslist = range(reps)

def forloop():
    res=[]
    for x in repslist:
        res.append(abs(x))
    return res

def listComp():
    return [abs(x) for x in repslist]

def mapCall():
    return list(map(abs,repslist))

def genExpr():
    return list(abs(x) for x in repslist)

def genFunc():
    def gen():
        for x in repslist:
            yield abs(x)
    return list(gen())

print(sys.version)
for test in (forloop, listComp, mapCall, genExpr, genFunc):
    elapsed, result = timer.timer(test)
    print('-'*33)
    print('%-9s: %.5f => [%s ... %s]' % (test.__name__,elapsed,result[0],result[-1]))
```

```
3.7.0 (default, Jun 28 2018, 08:04:48) [MSC v.1912 64 bit (AMD64)]
---------------------------------
forloop  : 1.29046 => [0 ... 9999]
---------------------------------
listComp : 0.80302 => [0 ... 9999]
---------------------------------
mapCall  : 0.36476 => [0 ... 9999]
---------------------------------
genExpr  : 0.92997 => [0 ... 9999]
---------------------------------
genFunc  : 1.14907 => [0 ... 9999]
```

### 函数陷阱

#### 本地变量是静态检验的

python定义的在一个函数中进行分配的变量名是默认为本地变量，存在于函数的作用域并只在函数运行时存在

python是静态检验本地变量的

- 没有在函数中的变量会在整个模块中查找

  ```python
  x = 99
  def selector():
      print(x)
      
  selector()
  >>>
  99
  ```

- 在函数的变量引用之后增加一个赋值语句，要==重点注意==

  ````python
  x = 99
  def selector():
      print(x)
      x = 88
  >>>
  UnboundLocalError: local variable 'x' referenced before assignment
  ````

  __得到一个未定义变量名的错误__：python对代码编译时，看到了x的赋值语句，这决定了x将会在函数的任一地方都将时本地变量

  但当函数运行时，print执行时赋值语句并没有发生，python会告诉你正在使用一个未定义的变量

  >  根据其变量名规则，本地变量x是在其被赋值前调用了

  __任何在函数体内的赋值将会使其成为一个本地变量名__

  import 、=、嵌套def、嵌套类等，都会受这种行为的影响

  ==原因==：==在函数中被赋值的变量名在函数内部是当作本地变量来对待，而不是仅仅在赋值以后的语句中才被当作本地变量==

  ```python
  # 如果需要打印全局变量x，需要一个global语句声明
  x = 99
  def selector():
      global x
      print(x)
      x = 88
  selector()
  print(x)
  >>>
  99
  88
  ```

  这样函数内的赋值语句会改变全局变量x，而不是一个本地变量

  函数中不可能同时使用同一个简单变量名的本地变量和全局变量，如果真的==希望打印全局变量，并在之后设置一个有着相同变量名的本地变量，导入上层的模块，并使用模块的属性标记来获得其全局变量==

  ```python
  x = 99
  def selector():
      # 导入上层模块
      import __main__
      # 通过属性标记获取全局x
      print(__main__.x)
      # 定义本地x
      x = 88
      print(x)
  selector()
  print(x)
  >>>
  99
  88
  99
  ```

#### 默认和可变对象

默认参数是在==def语句运行时==评估并保存的，而不是在函数调用时

从内部来讲，python会将每个默认参数保存为一个对象，附加在函数上

__必须对修改可变的默认参数十分小心__

```python
# 函数使用了一个默认参数，并在每次调用时都对它进行了改变
def saver(x=[]):
    x.append(1)
    print(x)
saver([2])
saver()
saver()
saver()
>>>
[2, 1]
[1]
[1, 1]
[1, 1, 1]
```

有人把这种行为当作一种特性，因为可变类型的默认参数在函数调用之间保存了他们的状态，从某种意义上讲他们能够充当c语言中的静态本地函数变量的角色，在一定程度上，他们工作起来就像全局变量，但是他们的变量名对于函数来说是本地变量，而且不会与程序中的其他变量名发生冲突

可变类型默认参数的值取决于默认对象的构建时间，在上一个例子中，其中只有一个列表对象作为默认值，这个列表对象是在def语句执行时被创建的，不会每次函数调用时都得到一个新的列表，所以每次新的元素加入后，列表会变大，对于每次调用，他都没有重置为空列表

`None or []  语句返回  []`

```python
def saver(x=None):
    if x is None:
        # run code to make a new list
        x = []
    x.append(1)
    print(x)
saver([])
>>>
[1]
```

#### 没有return的函数

当一个函数没有精确的返回值的时候，函数在控制权从函数函数主体脱离时，函数将会退出

所有的函数都返回了一个值，如果没有return，函数将自动返回None对象

```python
# no return is a None return
def no_return(x):
    print(x)
   
x = no_return(1)
>>>1
print(x)
>>>
None
```

#### 嵌套作用域的循环变量

处理嵌套的循环改变了的变量时要小心

### 本章小结

- 方括号中的==列表解析==会一次性在内存中产生结果==列表==，当位于==圆括号==中时，实际上是==生成器==表达式，不会一次产生结果列表，返回一个生成器对象，用在迭代环境中，一次产生结果中的一个元素

- 生成器和迭代器的关系：==生成器是==支持迭代协议的对象，他们有==\_\_next\_\_方法==（重复前进到下个元素，以及到尾端时引发例外事件），我们可以通过def,加圆括号的列表解析的生成器以及以类定义特殊方法\_\_iter\_\_来创建生成器对象

- 如何分辨函数是否为生成器函数

  函数中有了yield语句，会让python把函数编译为生成器，调用时返回生成器对象，支持迭代协议，yield语句运行时会把结果返回给调用者，让函数的状态挂起，然后调用者再次调用\_\_next\_\_方法时，函数就重新再上次yield语句后继续执行，生成器也可以有return方法，用来终止生成器。

- map和列表解析：两者都会收集对==序列或其他可迭代对象==中每个元素==应用运算后的结果==，创建新的列表

  - map会对每个每个元素==应用函数==，而列表解析则是应用==表达式==（更通用），可以像map那样应用函数调用表达式，但是map需要一个函数才能引用其他种类的表达式
  - 列表解析支持扩展语法，例如嵌套for循环和if分句可以实现内置filter的功能













## 第五部分_模块

### 第二十一章_模块：宏伟蓝图

模块是最高级别的程序组织单元，将程序代码封装起来以便重用

每一个文件都是一个模块，并且模块导入其他模块之后就可以使用导入模块定义的变量

- 模块可以由两个语句和一个重要的内置函数进行处理
  - import   以一个整体获取一个模块
  - from     允许客户端从一个模块文件中获取特定的变量名
  - imp.reload    在不终止程序的情况下，提供了一种重载模块文件代码的方法

#### 为什么使用模块

模块的命名空间提供了将部件组织为系统的简单的方法，在一个模块文件的顶层定义的所有的变量名都成了被导入的模块对象的属性（导入给予了对模块的全局作用域中变量名的读取权）

模块的角色：

- 代码重用

  > 模块可重载，模块是定义变量名的空间，被认作是属性，可以被多个外部的客户端引用

- 系统命名空间的划分

  > 模块将变量封装进了自包含的软件包

- 共享服务和数据

  > 模块对实现跨系统共享的组件很方便

#### python程序架构

程序通常不仅仅涉及一个文件，除了最简单的脚本，都会采用多文件系统形式

##### 如何组织一个程序

程序是作为一个主体的、顶层的文件来构造，配合有零个或多个支持的文件，这些文件被称为模块

顶层文件包含了程序的主要控制流程：用来启动应用的文件

##### 导入和属性

模块通常是被其他文件导入的，这些文件想要使用模块定义的工具

### import如何工作

程序第一次导入文会执行三个步骤：

1. 找到模块文件
2. 编译成位码（需要时）
3. 执行模型的代码来创建其所定义的对象

以上步骤只是在程序执行时，第一次导入时才进行，这之后导入相同模块会跳过这三个步骤，只提取内存中已加载的模块对象

> 技术上python把载入的模块存储到一个名为sys.modules的表中，并在一次导入的时候检查该表，如果不存在将会启动以上三步骤

#### 1.搜索

python首先查找引用模块，只列简单名称，路径和后缀是刻意省略，因为python使用了==标准模块搜索路径==来找出import语句所对应的模块文件

#### 2.编译（可选）

遍历模块搜索路径，找到目标文件，必要的话python会将其编译成字节码

python会自动检查文件的时间戳，如果发现字节码文件比源代码旧，就会在程序运行时自动重新生成字节码

如果发现.pyc字节码不比对应的.py文件旧，就会跳过编译

如果python在搜索路径上只发现了字节码，而没有源代码，就会直接加载字节码（这意味着你可以把一个程序只作为字节码发布，而避免发送源码）

换句话说，有可能使程序启动加速，就会跳过编译步骤

当文件导入时，就会进行编译，通常不会看见顶层程序文件的 .pyc字节码文件，除非这个文件也被其他文件导入，只有导入的文件会在机器上留下.pyc,顶层文件的字节码在内部使用后丢弃了，被导入文件的字节码则保存在文件中可提高以后的导入速度

顶层文件通常是设计为直接执行，而不是被导入

#### 3.运行

import操作的最后步骤是执行模块的字节码。文件中的语句依次执行，步骤中任何对变量名的赋值运算都会产生所得到的模块文件的属性

这个步骤会生成模块代码所定义的所有工具

> def语句会在导入时执行，来创建函数，并将模块内的属性赋值给函数

最后的导入步骤实际上是执行文件的程序代码

### 模块搜索路径

对程序员来说，导入最重要的部分是最早的部分---定位导入文件

sys.path的组成：

1. 程序主目录
2. pythonpath目录
3. 标准链接库目录
4. 任何.pth文件的内容

1、3路径是自动定义的，2、4可用于拓展路径

- 主目录

  python首先搜索主目录，就是程序的顶层脚本的目录

  该目录最先被搜索，其文件将覆盖路径上的其他目录中同名的模块

  > 要注意自己的模块命名，不要意外的隐藏库模块

- pythonpath目录

  之后python会从左至右搜索pythonpath环境变量中的目录，简而言之pythonpath是设置包含python程序文件的目录的列表

  python会先搜主目录，当搜索跨文件目录时，这个设置才显得重要---如果你需要被导入的文件和进行导入的文件不在同目录时

- 标准库目录

  接下来python会自动搜索标准库模块安装在机器上的目录

- .pth文件目录

  python有个新功能，允许用户把有效的目录添加到模块搜索路径，==也就是在后缀名为.pth的文本文件==中一行一行的列出目录，这些路径配置文件时和安装相关的高级功能，不进行全面的讨论，

下面是pythonpath设置的一中替代方案

> 简而言之，当内含目录名称的文本文件放在适当目录时，可以概括的扮演与pythonpath环境变量相同的角色
>
> > 例如当你运行win和python3,一个名为myconfig.pth的文件可以放在python==安装目录==（C:\python3）的顶层或者标准库所在的位置(sitepackages子目录（C:\python3\lib\sitepackages）)

当目录存在时，python会把文件加载到模块搜索路径的最后

### sys.path列表

可以使用sys.path来查看模块搜索路径在机器上的实际配置

- 提供一种方式确认你所做的搜索路径的设置

- 提供一种方式可以手动调整搜索路径

  通过修改sys.path列表加入将来需要的导入路径，这种修改只会在脚本存在期间保持而已

  > pythonpath和.pth文件提供了持久从路径修改方法

### 模块文件的选择

文件的后缀名自动从import语句中省略，python会选择搜索路径中第一个符合导入文件名的文件

import b 可能会导入：

- 源代码   b.py
- 字节码   b.pyc
- 目录   b
- 编译扩展模块 （b.dll 或b.pyd）
- C 编写的内置模块
- ZIP文件组件，导入时自动解压
- java类
- .NET组件

### 总结

- 模块的源代码在导入时自动生成模块对象
- 设置pythonpath可以从正在用的目录以外的其他目录进行导入
- 命名空间是一种独立完备的变量包，而变量就是命名空间对象的属性
  - 模块命名空间包含了代码在模块顶层赋值的所有变量，从技术上来讲，模块的全局作用域会变成模块对象的属性命名空间



### 第二十二章_模块代码编写基础

#### 模块的使用

import会读取整个模块

from将获取模块特定的变量名

from  ... import  * 语句会获取模块==顶层所有赋值的变量名==拷贝

`from module import *`

#### 导入只发生一次

导入操作开销较大，只会在第一次导入时载入并执行，之后的操作只会取出已加载的模块对象

模块文件中的顶层程序只执行一次，可以凭借这种特性对变量进行初始化

#### import和from是赋值语句

两个都是可执行语句，而不是编译期间的声明，可以嵌套在if中，出现在def中，直到执行程序时，才会进行解析

import 和 from 是隐性的赋值语句

- import将整个模块赋值给一个变量名
- from将一个或多个变量名赋值给另一模块中的同名对象

from复制的变量名会变成对共享对象的引用

#### 文件间变量名的改变

以from复制而来的变量名和其他来源的文件没有联系，为了实际修改另一文件内的全局变量名，必须使用import

==这里再测试过程有问题，待确认==



#### from语句的陷阱

from语句有破环命名空间的潜质---如果使用from导入变量碰巧和作用域中的现有变量同名，变量就会被覆盖

#### 何使使用import

当需要使用的两个不同模块中还有相同的变量名时，必须使用import

#### 模块命名空间

模块是命名空间，存在于模块中的变量就是模块的属性

#### 文件生成命名空间

- 模块语句会在首次导入时执行

  第一次导入时会建立空的模块对象，并逐一执行语句

- 顶层的赋值语句创建模块属性

- ==模块的命名空间==可通过属性==\_\_dict\_\_或dir(M)==获取

  由导入而建立的模块命名空间是字典，可通过模块对象关联的内置_\_dict\_\_属性来读取，而且能通过dir函数查看，dir函数包含了类继承的变量名

- 模块是一个独立的作用域（本地变量是全局变量）

  模块范围会在模块加载后变成模块对象的属性辞典，和函数不同的是函数本地变量名只有在运行时才存在

\_\_dict\_\_的使用：`module.__dict__.keys()`,_\_dict\_\_是一个视图要包含在list中使用



- \_\_dict\_\_

  - 类的静态函数，类函数，普通函数，全局变量以及内置属性都放在类__dict__中，

  - 对象的__dict__中存储了self.xx的东西

  - 内置的数据类型没有__dict__属性

    

##### 属性名的点号运算

点号运算可以获取对象的属性

点号运算是表达式

- 简单变量

  x是指在当前作用域内搜索变量名x(LEGB)

- 点好运算

  x.y是指在当前范围内搜索x,然后搜索对象x中的属性y

- 多层点号运算

#### 命名空间的嵌套

```python
# mod3.py
x = 3

# mod2.py
x = 2
import mod3
print(x,end=' ')
print(mod3.x)

# mod1.py
x = 1
import mod2
print(x,end=' ')
print(mod2.x,end=' ')
print(mod2.mod3.x)
```

导入会使命名空间发生向下的嵌套

#### 重载模块嵌套

模块程序代码默认只对每个过程执行一次，要强制使模块代码重新载入并重新运行，可使用reload函数

- 只会在模块第一次导入时加载和执行模块代码
- 之后的导入只会使用已加载的模块对象，不会重载或重新执行文件的代码
- reload函数会强制已加载的模块代码重新载入并重新执行

为何需要重载？

> reload函数可以修改程序的一部分而无需停止整个程序，利用reload可以立即看到对组件的修改
>
> > 数据库程序在启动时链接了服务器，程序修改或调整可在重载后立即测试，在调试时，只需要连接一次即可

#### reload基础

与import和from不同的是：

- reload是内置函数，而不是语句
- 传给reload的数已经存在的模块对象，而不是变量名
- reload在python3中位于模块中，必须自己导入

reload期望得到的是对象，重载前模块已经预先成功导入

reload需要小括号，import不需要

__导入一个模块，在文本编辑器内修改其源码，然后将其重载，调用reload时，python会重读模块代码__

```
import module
# 修改 module 模块源代码后，利用reload重载
from imp import reload
reload(module)

```

- reload在当前命名空间执行模块新代码，覆盖现有命名空间，并非进行删除而重建
- 文件顶层赋值语句会使得变量名换成新值
- 重载会影响所有使用import读取了模块的客户端，因为import的客户端需要通过点号运算取出属性，重载后，模块对象中变成了新值
- 重载只会对以后使用from的客户端造成影响，之前使用from来读取属性的客户端并不受重载影响，依然是之前的旧值

#### 总结：

- 每个原代码文件自动成为模块，没有语法声明模块
- from语句是导入整个模块，如同import,但是会多一个步骤，就是会从被导入的模块中复制一个或多个变量到from语句所在作用域，这样就可直接使用被导入的变量名
- 默认是每个进程模块只导入一次，reload会强制模块再次被导入，基本上用于开发过程中选取模块源代码的新版本，或者用于动态定制场景中
-  当需要读取不同模块的相同变量名时，必须用import而不是from
- from：让变量变得模糊，通过reload调用时会有问题（变量还是之前版本），会破环命名空间，





### 第二十三章_模块包

除了模块名之外，导入也可以指定目录路径

python代码的目录成为包

包导入是把计算机上的目录变成另外一个python命名空间，而属性则对应于目录中所包含的子目录和模块文件

对于组织大型系统内的文件很方便

当多个相同名称的程序文件安装在机器上时，包导入可以解决导入的不确定性，它只与包中的代码相关

#### 包导入基础

包导入，路径名称彼此以点号分隔

```python
import dir1.dir2.mod
from dir1.dir2.mod import x
```

点号路径对应于机器上目录层次的路径

import 语句中目录路径只能是以点号间隔的变量，不能再import语句中使用任何平台特定的路径语法

#### \_\_init\_\_.py包文件

包导入语句路径的每个目录内必须有\_\_init\_\_.py文件，否则导入失败

> 如果目录结构是 dir0\dir1\dir2\mod.py
>
> 以 import dir1.dir2.mod
>
> 这种形式导入，须遵守以下规则：
>
> - dir1和dir2中必须含有\_\_init\_\_.py文件
> - dir0是容器，不需要_\_init\_\_.py文件
> - dir0必须在模块搜索路径上

![013](D:\project\pycon\Python_学习手册\img\013.JPG)

\_\_init\_\_.py可以包含python代码，就像普通文件，从某种程度上是python的一种声明

作为声明，这些文件可以防止有相同名称的目录不小心隐藏在模块搜索路径中

\_\_init\_\_.py扮演了包初始化的钩子，替目录产生模块命名空间以及使用目录导入时实现from * 的行为

##### 包的初始化

python 首次导入某个目录，会自动执行\_\_init\_\_.py文件中的程序代码

因此这类文件自然就是放置包内文件所需要初始化的代码场所

> 例如使用其初始化文件，创建所需要的数据文件，连接数据库等

一般如果直接执行，\_\_init\_\_.py文件没什么用，当包首次读取时，会自动运行

##### from * 的行为

可以在\_\_init\_\_.py文件内时\_\_all\_\_列表来定义目录以from*语句形式导入时需要导出什么

_\_all\_\_列表是指当包名称使用from*的时候，应该导入的子模块的名称清单，如果没有设定\_\_all\_\_, from * 语句不会自动加载嵌套于该目录内的子模块

#### 包对于的from和import语句

使用from语句来避免每次读取时都得输入路径，import提供一个完整路径较短的同义词

```
from dir1.dir2 import mod

import dir2.dir2.mod as mod
```

#### 为何使用包导入

包让导入根更具信息性，可以作为组织工具，简化模块搜索路径，可以解决模糊性

包导入提供了程序文件的目录信息，没有包导入时通常得产看模块搜索路径才能找出文件

如果有跨目录的导入都使用包导入，共用一个根目录，让导入更明确，解决了模糊性



只有在跨目录导入时才需要模块搜索路径的设置



#### 包相对导入

包自身的内部，包文件可以使用和外部导入相同的路径语法

python3.0需要显式的相对导入语法，增强代码可读性

#### python3的变化

- 修改了模块导入搜索路径语义，默认跳过包自己的目录，
- 扩展看from的语法，允许显式的要求导入只搜索包的目录

#### 相对导入基础

- 导入相对于外围的包，只在包内搜索

  ```
  from . import span
  from .span import name
  ```

python3中，不带点号的import总是会引发python略过模块导入搜索路径的相对部分，并且在sys.path所包含的绝对路径中查找

```
import string
# 总是在sys.path上的某处查找string模块，而不查找该包中具有的相同模块
```

点号可以用来仅对from语句强制导入，而不对import,python3中，import modname任然执行相对导入（先搜索包内目录），python2.7中，将变成绝对的

#### python3相对导入

```python
# 在包外找到模块
import string
# 前面没有点号的from语句，看做是绝对的
from string import name
# 从包中导入模块
from . import string
```

点号 .  用来表示包含文件的包目录，导入就出现在该文件，前面加一个点   ..   ,将执行从当前包的父目录相对导入

```python
from .. import spam
```

位于某个模块A.B.C 的代码可以做如下导入

```python
# A.B.D
from . import D
# A.E
from .. import E
# A.B.D.x
from .D import x
# A.E.x
from ..E import x
```

#### 相对导入 VS 绝对包路径

可以在一个绝对导入语句中显式的指定包`from mypkg import string`

这样导入时必须列出包的根目录下是所有目录

#### 模块查找规则

- 简单模块通过搜索sys.path路径上的目录查找，从左到右进行
- 包是带有一个特殊\_\_init\_\_.py文件的python模块的目录，可以使用点号路径方法

```
from mypkg import spam 是绝对导入
from . import spam 是相对导入，spam的查找相对于该语句所在的包，然后才会搜索sys.path
```

导入详解

<https://blog.csdn.net/weixin_38256474/article/details/81228492>











### 第二十四章_高级模块话题

#### 在模块中隐藏数据

python会导出文件顶层赋值的所有变量名

实际上没有防止客户端修改模块内变量名的方法

python的封装是打包，而不是约束

#### 最小化from* 的破环：_x 和\_\_all\_\_

把下划线放在变量名前（_x）可以防止客户端使用from * 语句导入时把其中的那些变量名复制出去，是为了对命名空间的破环最小化而已

下划线不是“私有”声明，可以使用其他导入形式看见并修改这类变量

也可以在模块顶层把变量名的字符串列表赋值给_\_all\_\_，以达到类似于\_x命名惯例的隐藏效果

_\_all\_\_ = ['Error','encode','decode']

这样 from * 语句只会把_\_all\_\_列表中的这些变量名复制出来

_\_all\_\_是指出要复制的变量，\_x是指出不被复制的变量

python 会先寻找_\_all\_\_列表，如果没有定义，会复制开头没有下划线的所有变量名

```python
__foo__: 定义的是特殊方法，一般是系统定义名字
_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *
__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了
```



#### 混合用法模式：_\_name\_\_ 和 _\_main\_\_

这是特殊的模块技巧，可以把文件作为模块导入，并以独立程序的形式运行

每个模块都有个名为_\_name\_\_ 的属性，python自动设置该属性

- 如果文件是以顶层程序文件执行，在启动时，_\_name\_\_ 就会被自动设置为‘’_\_\_main\_\_‘’
- 如果文件被导入，_\_name\_\_就会被改成模块名

模块可以自己检测自己的_\_name\_\_,来确定是在执行还是导入

`if __name__ == "__main__:"`

- 实际上一个模块的_\_name\_\_变量充当一个使用模式标志

#### 以_\_name\_\_进行单元测试

可以把程序自我测试的代码放在_\_name\_\_判断前，在判断后加入程序输出部分

#### 修改模块搜索路径

模块搜索路径是一个目录列表，可以通过环境变量pythonpath以及.pth进行定制

python程序本身可以修改搜索路径，也就是修改sys.path的内置列表

sys.path在程序启动时就会初始化，在之后可随意对元素进行删除、附加和重设

```
import sys
sys.path
sys.path.append()
```

这样可以对程序中搜索路径动态配置，sys.path的设置方法只在修改的python会话（程序-即进程）中有效

#### import语句和from语句的as扩展

```python
import modulename as name
# 等价于
import modulename
name = modulename
del modulename

from modulename import attrname as name
```

这种方式很常用，替变量名较长的变量提供简短的同义词

当已经在脚本中使用一个变量名使得执行普通import语句会被覆盖，使用as，就可避免变量名冲突

#### 模块是对象：元程序

模块通过内置属性显示了他们的大多数特性，可编写程序来管理其他程序，这类管理程序为元程序（metaprogram）

例：获取M模块内名为name的属性

```python
# 下面得到相同的结果
M.name
M.__dict__['name']
sys.modules['M'].name
getattr(M,'name')
```

```python
>>> import tkinter
>>> tkinter.__doc__
'Wrapper functions for Tcl/Tk.\n\nTkinter provides classes which allow the display, positioning and\ncontrol of widgets. Toplevel widgets are Tk and Toplevel. Other\nwidgets are Frame, Label, Entry, Text, Canvas, Button, Radiobutton,\nChnCheckbutton, Scale, Listbox, Scrollbar, OptionMenu, Spinbox\nLabelFrame and PanedWindow.\n\nProperties of the widgets are specified with keyword arguments.\nKeyword arguments have the same name as the corresponding resource\nunder Tk\nW.\n\nWidgets are positioned with one of the geometry managers Place, Pack\nor Grid. These managers can be called with methods place, pack, grid\navailable in every Widget.\n\nActions are bound to events by resources (e.g. keyword argucomment\ncommand) or with the method bind.\n\nExample (Hello, World):\nimport tkinter\nfrom tkinter.constants import *\ntk = tkinter.Tk()\nframe = tkinter.Frame(tk, relief=RIDGE, borderwidth=2)\nframe.pack(fill=BOTH,expand=1)\nlabel = tkel(inter.Label(frame, text="Hello, World")\nlabel.pack(fill=X, expand=1)\nbutton = tkinter.Button(frame,text="Exit",command=tk.destroy)\nbutton.pack(side=BOTTOM)\ntk.mainloop()\n'
>>> tkinter.__name__
'tkinter'
>>> tkinter.__file__
'C:\\Users\\Dell\\Anaconda3\\lib\\tkinter\\__init__.py'
```

==_\_name\_\_, _\_file\_\_, _\_doc\_\_==

#### 用名称字符串导入模块

无法使用import 语句来直接载入以字符串形式给出名称的模块

```python
import 'string'
>>>
 File "<stdin>", line 1
    import 'string'
                  ^
SyntaxError: invalid syntax
    
x = 'string'
import x

# 这里python会尝试导入一个x.py的文件
```

import语句中的名称，既变成了赋给载入模块的一个变量，也从字面上标识了该外部文件

- 解决方法：

  ```python
  # 把导入语句构建成为python 代码的一个字符串，将其传递给exec内置函数
  modname = 'string'
  exec('import '+modname)
  string
  >>>
  <module 'string' from 'D:\\project\\pycon\\Python_学习手册\\Exercise\\相对导入\\string.py'>
  ```

exec函数及其近亲 eval 编译一个代码字符串，并将其传递给解释器以执行

exec唯一的缺点是，每次运行时必须编译import语句，如果它运行多次，如果使用内置的_\_import\_\_函数来从一个名称字符串载入的话，代码可能运行得更快

_\_import\_\_ 运行模块对象，因此在这将其赋值给一个名称以保存它

```python
modname = 'string'
string = __import__(modname)
string
>>>
<module 'string' from 'D:\\project\\pycon\\Python_学习手册\\Exercise\\相对导入\\string.py'>
```

#### 过渡性模块重载

如果重载模块A，A导入模块B和C ,重载只适用于A，而不适用于B和C

A中导入B和C的语句在重载的时候重新运行，但只是获取已经载入的B和C模块

不能依赖重载来过渡性的选择程序中所有模块中的修改，必须使用多次reload调用来独立的更新子部分，对于交互测试的系统，工作量很大，可以通过在A这样的父模块中添加reload调用，自动重载子部分

- 一种更好的方式是编写一个通用的工具自动过渡性重载，通过扫描\_\_dict\_\_属性并检查每一项的type找到要重新载入的嵌套模块，函数递归的调用自己，来导航任意形式的导入依赖性链条



要使用这一工具，导入其reload_all函数并将一个已经载入的模块的名称传入

#### 模块设计理念

- 总是在python模块内编写代码

  在交互模式下输入的程序代码，其实是存在于内置模块\_\_main\_\_之内，交互模式独特之处在于程序是执行后立刻丢弃

- 模块耦合要降到最低：全局变量

  模块尽可能和其他模块的全局变量无关

- 最大化模块的黏合性，统一目标，最大化黏合性来最小化模块耦合性

- 模块应该少去修改其他模块的变量

#### 模块陷阱

##### 顶层代码的语句次序的重要性

模块文件顶层的代码，运行时立即执行，无法引用文件后面赋值的变量名

位于函数主体的代码直到调用时才会运行，函数内的变量在实际执行前不会解析

函数可以任意引用变量名

##### from复制变量名，而不是连接

from也是python各种潜在陷阱的源头，from在当前作用域对变量名的赋值语句，也就是拷贝变量名，而不是变量名的别名机制

> 如果我们在模块内导入两个变量名，就会得到两个变量名的拷贝，而不是对两个变量名的连接

在导入者内修改变量名，只会重设变量名在本地作用域的绑定值，而不是导入的模块中的变量

```python
# nested1.py
x = 99
def printer(): 
    print(x)
```

```python
# nested2.py
from nested1 import x,printer
x = 88
printer()
>>>
99
```

如果我们使用了import ,然后赋值某个点号运算的变量名，就会修改被导入模块的变量名，点号运算定向到了模块对象的变量名，而不是导入者的变量名

```python
# nested3.py
import nested1
nested1.x = 88
nested1.printer()
>>>
88
```

##### from * 让变量语义模糊

使用from module import * 语句时，可能会意外的覆盖了作用域内已经使用的变量名，很难确认来自何处

- 试着在from语句中明确列出想要的属性，限制每个文件最多有一个被导入的模块使用from * 方式

##### reload不会影响from导入

from 在执行是复制变量名，不会连接到变量名的那个模块，通过from导入的变量名变成了对象的引用

重载使用from导入的模块变量名对客户端无影响

为了保证重载有效，可以使用import以及点号运算来取代from,点号运算总是会回到模块

##### 递归形式的from导入无法工作

导入会从头到尾执行一个文件，使用相互导入的模块时，因为一个模块内的语句在其导入另外一个模块时不会全部执行

如果使用import取出整个模块，模块的变量名在稍后使用点号运算，在获取值之前都不会读取

如果使用from读取特定的变量名，只能读取在模块中已经赋值的变量名





## 第六部分_类和OOP

类是python实现支持继承的新种类的对象的部件

类就是一些函数的包

采用战略模式工作的人（做长期产品开发）对类感兴趣

- 为何使用类

  - 继承

  - 组合

  - 多重实例

    类是产生对象的工厂，每次调用一个类，就会产生一个有独立命名空间的新对象，每个由类产生的对象都能读取类的属性，获得自己的命名空间来储存数据

  - 通过继承进行定制

    在类的外部重新定义其属性而扩充这个类，类可以建立命名空间层次结构

  - 运算符重载

    通过提供特定的协议方法，类可以定义对象来响应在内置类型上的几种运算



### 第二十五章_OOP:宏伟蓝图

#### 属性继承搜索

对类采用`object.attribute`,表达式会启动搜索，搜索对象连接的树，来寻找attribute首次出现的对象

先搜索object,然后是该对象之上的所有类，由下至上由左至右

取出属性只是简单的搜索“树”，我们称这种搜索程序为继承，因为树种位置较低的对象继承了树中位置较高的对象拥有的属性

类：是实例工厂，类的属性提供了行为（数据和函数），所有从类产生的实例都继承该类的属性

实例：代表程序领域中具体的元素，实例属性记录数据，每个特定对象的数据都不同

#### 类和实例

不同的对象类型，在搜索树中几乎相同，类和实例的主要差异，类是一种产生实例的工厂

#### 编写类树

- 每个class语句会生成一个新的类对象
- 每次类调用时，就会生成一个新的实例对象
- 实例自动连接至创建了这些实例的类
- 类连接至其超类的方式是，将超类列在类头部的括号内，从左到右的顺序决定了树中的次序

附加在实例的属性至属于那些实例，附加在类上的属性由所有子类和实例共享

- 属性通常是在class语句中通过赋值语句添加在类中，而不是潜入在def语句中
- 属性通常是在类内，对传给函数的特殊参数（self）,做赋值运算而添加在实例中

#### 本章习题

- oop就是代码的重用：分解代码，最小化代码冗余以及对现存的代码进行定制来编写程序，而不是实地修改代码 
- 继承搜索会先在实例对象中搜索属性，然后是创建实例的类，之后是较高的超类，由底端到顶端，从左到右
- 类和实例对象都是命名空间，两者主要差别是，类是建立多个实例的工厂
- 类方法参数中的第一个参数之所以特殊，是因为它总是接收将方法调用视为隐含主体的实例对象，按惯例，通常称为self,因为方法函数==默认总是有个隐含的主体对象环境==，所以说这是面对对象
- 如果类中编写了会继承了_\_init\_\_方法，每次创建实例时会自动调用它
- 可以调用类名称来创建类实例，任何==传给类名称的参数都要出现在_\_init\_\_ 构造函数中第二和其后的参数==，新的实例会记得创建它的类，实现继承











### 第二十六章_类代码编写基础

#### 类产生多个实例对象

- 类对象提供默认行为，像是对象的工厂
- 实例对象处理实际对象，各自有独立的命名空间，也可自动存取创建该实例的类中的变量
- 类对象来自语句，实例对象来自调用
- 每次调用类，会得到类的新的实例

#### 类对象提供默认行为

- class语句创建类对象并将其赋值给变量名，class语句是可执行语句，执行时产生新的类对象，class语句一般是在文件导入时执行的
- class语句内的赋值语句会创建类的属性，class语句的作用域会变成类对象的属性命名空间
- 类属性提供对象的状态和行为

#### 实例对象是具体元素

- 像函数调用类对象会创建新的实例对象
- 每个实例对象继承类的属性并获得了自己的命名空间
- 在方法内对self属性做赋值运算会产生实例自己的属性

#### 例子

def是赋值运算，把函数对象赋值给类变量

对实例以及类对象内的属性进行点号运算，python会通过继承搜索从类中取得变量名

继承是在点号运算时发生的

类会产生多个实例，方法必须经过self才会获取正在处理的实例

```python
class FirstClass:
    def setdata(self, value):
        self.data = value
    def display(self):
        print(self.data)
# data属性在setdata赋值前，不会再内存中存在
# 创建两个实例 x,y
x = FirstClass()
y = FirstClass()
```

再类的内部或外部修改实例属性，再类内通过方法内对self进行赋值运算，再类外通过对实例对象进行赋值

- 通过在类方法函数外对变量名进行赋值运算，可以在实例命名空间产生新的属性,实例对象的任何类方法都可以使用，通常通过self参数进行赋值运算建立实例的属性

```python
# 对实例对象进行赋值
x.data = 'New value'
x.display()
>>> New value
```

- 可以为类实例添加新的属性，实例对象x的任何类方法都可以使用它

```python
# 给实例添加新属性
x.anothername = 'spam'
```

#### 类通过继承进行定制

类可以作为工厂生成多个实例，也可以引入新组件（子类）进行修改，而不对现有组件进行原地修改

类实例会继承类的属性

类也可以继承其他类，这是编写类层次结构的大门，在阶层较低的地方覆盖现有的属性，让行为特定化

向层次的下端越深入，软件会越来越特定

模块的属性存在于一个单一的、平坦的命名空间中，该命名空间不接受定制化

==实例从类中继承，类继承于超类==

- 属性继承
  - 超类列在了类开头的括号中
  - 类从超类中继承属性
  - 实例继承所有可读取的类属性
  - 每个object.attribute都会开启新的独立搜索
  - 逻辑的修改是通过创建子类，而不是修改超类

#### 例子

```python
class FirstClass:
    def setdata(self, value):
        self.data = value
    def display(self):
        print(self.data)

# 通过继承进行定制
class SecondClass(FirstClass):
    def display(self):
        # 定义了不同格式的打印，取代了与FirstClass中同名的属性
        print('Current value = {}'.format(self.data))

# SecondClass覆盖了FirstClass中的display
# 我们把这种较低处发生的重新定义的、取代属性的动作称为重载
# 结果就是SecondClass改变了继承方法display的行为，把FirstClass特定化了
z = SecondClass()
z.setdata(111)
z.display()
```

![捕获](D:\project\pycon\Python_学习手册\img\14.JPG)

继承可以让我们在外部组件内进行修改，类所支持的扩展和重用通常比函数或模块好

#### 类是模块内的属性

```python
# 复制作用域
from modulename import className
class someClass(className):
    pass
# 等效
import modulename
class someClass(mudulename.className):
    pass
```

类名称总是存在于模块中，class语句会在导入时执行已定义的变量名，而这些变量名会变成独立的模块属性

每个模块可以任意混合任意数量的变量，函数以及类，模块内所有变量名的行为相同

```python
#food.py
var = 1
def fun():
    ...

class spam:
    ...

class ham:
    ...

class eggs:
    ...
```

#### 类可以截获python运算符

##### 类和模块的三个主要差别：

- 运算符重载：让用类写成的对象可以截获并响应用在内置类型上的运算：加法、切片、打印和点号运算

  - 表达式和其他内置运算流程要通过类的实现来控制
  - 模块可以实现函数调用，而不是表达式的行为

  1. 以双下划线命名的方法（`__X__`）是特殊钩子。

     > python运算法重载的实现是提供特殊命名方法来拦截运算。python替每种运算和特殊命名间的方法提供了固定不变的映射

  2. 当实例出现在内置运算时，这些方法会自动调用

     > 如果实例继承了`__add__`方法，当对象出现在 + 表达式内时，方法会调用

  3. 类可覆盖多数内置类型运算

     > 有几十种运算符重载的方法名称，几乎可以截获并实现内置类型的所有运算，包括了表达式，打印和对象建立等基本运算

  4. 运算符覆盖方法没有默认值，而且也不需要

     > 如果类没有定义或继承运算符重载方法，就是说相应的运算在实例中并不支持

  5. 运算符可让类与python的对象模型相集成

     > 重载类型运算时，对象的行为和内置对象一样，提供了一致性，以及与预期接口的兼容

  >运算符重载主要是替其他python程序员开发工具的人在使用，而不是应用程序开发人在使用 

`__init__`被称为构造方法，用于初始化对象的状态

#### 例子

实现三个特殊名称的属性，让python自动进行调用：

- 当新的实例构造时，会调用`__init__` 
- 当ThirdClass实例出现在 + 表达式中时，会调用`__add__`
- 当打印一个对象的时候（当通过str内置函数或者其python内部的等价形式来将其转换为打印字符串的时候），运行`__str__`

```python
class FirstClass:
    def setdata(self, value):
        self.data = value
    def display(self):
        print(self.data)

# 通过继承进行定制
class SecondClass(FirstClass):
    def display(self):
        # 定义了不同格式的打印，取代了与FirstClass中同名的属性
        print('Current value = {}'.format(self.data))

# SecondClass覆盖了FirstClass中的display
# 我们把这种较低处发生的重新定义的、取代属性的动作称为重载
# 结果就是SecondClass改变了继承方法display的行为，把FirstClass特定化了
z = SecondClass()
z.setdata(111)
z.display()


class ThridClass(SecondClass):
    def __init__(self, value):
        self.data = value
    def __add__(self,other):
        return ThridClass(self.data + other)
    def __str__(self):
        return '[ThirdClass: %s]' % self.data
    def mul(self, other):
        self.data *= other

print('-'*15)
# 创建实例时，传入类名括号里的变量是 __init__ 初始化函数的变量
# __init__被调用
a = ThridClass('abc')
# 调用继承方法
a.display()
# 调用 __str__ 函数
print(a)
# 创建新的实例
b = a + 'xyz'
# 调用继承方法
b.display()
print(b)
a.mul(3)
print(a)
>>>
Current value = abc
[ThirdClass: abc]
Current value = abcxyz
[ThirdClass: abcxyz]
[ThirdClass: abcabcabc]
```

ThirdClass是一个SecondClass对象，但ThirdClass生成的调用现在会传递一个参数（`__init__`构造函数内的参数），并将其赋值给self.data

ThirdClass对象现在可以出现在 + 表达式和print调用中

- 对于 + ，python把左侧的实例对象传给`__add__`中的self参数，把右边的值传给other,`__add__`返回的内容成为 + 表达式的结果

  ![15](D:\project\pycon\Python_学习手册\img\15.JPG)

- 对于print,python要把打印的对象传递给`__str__`中的self

#### 世界上最简单的python类

类中可以没有任何东西

```python
class rec: pass
# 没有写任何方法，所以我们需要无操作的pass语句
# 可在最初的class语句外，通过赋值变量名给类增加属性
rec.name = 'Bob'
rec.age = 40
```

创建属性后，可以用一般的语法将其取出

```python
print(rec.name)
>>>BOb
```

类还没有实例，也可以这样操作，==类本身也是对象，也是没有实例==

__类只是独立完备的命名空间，只要有类的引用值，就可以在任何时段设定或修改其属性__

```python
class rec: pass

# 没有写任何方法，所以我们需要无操作的pass语句
# 可通过赋值变量名给类增加属性
rec.name = 'Bob'
rec.age = 40
print('hello')

# 创建两个实例
x = rec()
y = rec()
print(x.name, y.name)

# 实例并没有属性，它们只是从类对象取出name属性
# 如果把一个属性赋值给一个实例，就会在对象内创建（或修改）该属性
# 属性赋值运算只会影响属性赋值所在对象
x.name = 'adam'
print(rec.name, x.name, y.name)
```

`__dict__`属性是针对大多数基于类的对象的==命名空间字典==

```python
print(rec.__dict__)
>>>
{'__module__': '__main__', '__dict__': <attribute '__dict__' of 'rec' objects>, '__weakref__': <attribute '__weakref__' of 'rec' objects>,
'__doc__': None, 'name': 'Bob', 'age': 40}

print(x.__dict__.keys())
>>>
dict_keys(['name'])
print(y.__dict__.keys())
>>>
dict_keys([])
```

`__class__`每个实例都连接至类，便于继承

```python
print(x.__class__)
>>>
<class '__main__.rec'>
```

`__bases__`属性是==超类的元组==

```python
print(rec.__bases__)
>>>
(<class 'object'>,)
```

__类和实例只是命名空间，属性是通过赋值语句动态建立__

方法也可以完全独立的在任意类对象的外部创建

```python
# 在任意类之外定义一个简单的函数
# 需要传入self参数
def upperName(self):
    return self.name.upper()
```

这里与类完全没有关系，只是一个简单的函数，当我们传入一个带有那么属性的对象，就可以调用

```python
upperName(x)
>>>
ADAM
```

当我们把这个函数赋值成类的属性，就会变成方法，可以由任何实例调用

```python
def upperName(self):
    print(self.name.upper())
    
print('_'*7)
print(upperName(x))
>>>
_______
ADAM

rec.method = upperName
x.method()
y.method()
rec.method(x)
>>>
None
ADAM
BOB
ADAM
```

__Python的OOP 就是在已连接命名空间对象内寻找属性__

#### 类与字典的关系

可以用类的键来记录属性：

```python
class rec:pass
rec.name='mel'
rec.age=45
rec.job='writer'
print(rec.age)
```

可以字典来记录

```python
rec={}
rec['name']='mel'
rec['job']= 'writer'
```

类的等价形式比字典要小很多，可以产生一个空类的实例来表示不同的记录

```python
class rec:pass
per1 = rec()
per1.name='mel'

per2 = rec()
per2.name='vls'
```

#### 总结

- 类位于模块中，是模块的属性，类和模块都是命名空间，类对应于语句，支持多实例，

- 类是通过class语句创建，实例是像函数那样调用来创建

- 类属性的创建是通过把属性赋值给类对象实现的，类属性通常是由class语句中的顶层赋值语句产生，每个在class语句代码区中赋值的变量，会变为类对象的属性，也可以在任何引用类对象的地方对其属性赋值，从而创建类属性

- 实例属性是通过对实例对象赋值属性来创建的，一般是在class语句中的类方法函数中对self参数（永远是隐含实例）赋值创建的，也可以在任何地方引用实例通过赋值语句来创建属性，即使在class语句外，一般来说，所有的实例属性都是在`__init__`构造函数中初始化

- self通常是给与类方法函数中的第一个参数的名称，python会自动填入实例对象（方法调用的隐含的主体），这个参数不必叫self,其位置才是重点（同c++于java中的this）

- python类中的运算符重载是用特定名称的方法写成的，这些方法的开头和结尾都是双下划线，通过这种办法使其变得独特，这些不是内置或保留字，当实例出现在相应运算中时，python会自动执行，python为这些运算和特殊方法的名称定义了对应关系

- 运算符重载可用于实现模拟内置类型的对象，以及模拟代码中所预期的内置类型接口

- `__init__`构造函数是最常用的，几乎每个类都使用这个方法为实例属性进行初始化，以及执行其他的启动任务

  

### 第二十七章_更多实例

python中第二常用的运算符重载方法是继`__init__`之后的`__str__`——提供打印显示

#### 扩展方法的方式

- 不好的方式

```python
class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job 
        self.pay = pay
    def lastName(self):
        return self.name.split()[-1]
    def giveRaise(self, percent):
        self.pay = int(self.pay * (1+percent))
    def __str__(self):
        return '[Person: %s, %s]' % (self.name, self.pay)


# 扩展方法——不好的方式
class Manager1(Person):
    def giveRaise(self, percent, bonus=.10):
        # 不好的方式是复制和粘贴person中的giveraise的代码
        self.pay = int(self.pay * (1 + percent + bonus))
```

复制粘贴的代码基本上都会使未来的维护工作倍增——如果改变了涨工资的方式，将必须修改两个地方的代码

- 好的方式

```python
# 扩展方法——好的方式
class Manager(Person):
    def giveRaise(self, percent, bonus=0.10):
        # 使用扩展的方式来直接调用最初的方式
        Person.giveRaise(self, percent + bonus)
```

类方法总是可以在实例中调用，或者通过类来调用

```python
instance.method(args...)
等价于
class.methon(instance,args...)
```



### 第二十八章_类代码编写细节

#### class 语句

和def一样，class语句是对象的创建者并且是一个隐含的赋值运算——执行时他会产生类对象，并把其引用值存储在前面所使用的变量名，class语句也是真正的可执行代码，直到python抵达并运行定义的class语句前，类不存在

class语句是复合语句，class语句内，任何赋值语句都会产生类属性，而且还有特殊方法重载运算符，`__init__`函数会实例对象构造时调用，任何种类的语句都可位于class内，class语句自身运行时，class语句内的所有语句都会执行

#### 调用超类构造函数

类几乎就是命名空间，也就是定义变量名的工具，把数据和逻辑导出给客户端

class是符合语句，任何种类的语句都可以位于其主体内，class语句运行时，语句内的所有语句都会执行



方法一般是通过实例调用的，所有属性`__init__`方法是由继承查找的，在构造时，python只会找出并只调用一个`__init__`,如果要保证子类的构造函数也会执行超类的构造逻辑，一般都会通过类明确的调用超类的`__init__`

```python
class Supper:
    def __inint__(self,x):
        # default code...
class Sub(Supper):
    def __init__(self,x,y):
        Supper.__init__(self,x)
        # default code
```

如果没有这样的调用，子类会完全取代超类的构造函数

#### 继承

在python中当对对象进行点号运算时，就会发生继承，而且涉及到了属性定义树，每次使用object.attr 的表达式时就会从头至尾搜索命名空间树，树中较低的定义会覆盖较高的定义，继承构成了专有化的基础

#### 属性树的构造

- 实例属性是由对方法内self的属性进行赋值而生成的
- 类属性是通过class语句内的语句赋值而生成
- 超类的连接是通过class语句首行的括号内列处类而生成的

![16](D:\project\pycon\Python_学习手册\img\16.jpg)

#### 类接口技术

扩展只是一种与超类接口的方式

- super:定义一个method函数以及在子类中期待一个动作的delegate
- Inheritor:没有提供任何新的变量名，获得super中定义的一切内容
- replacer:用自己的版本覆盖super的method
- extender:覆盖并回调默认方法，从而定制super的方法
- provider:实现super的delegage方法预期的action

```python
class Super:
    def method(self):
        print('in Super.method')
    def delegate(self):
        # 超类中可以有未定义的方法，继承类可调用此方法来激活自己定义的函数
        self.action()

class Inheritor(Super):
    pass

class Replacer(Super):
    def method(self):
        print('in Replacer.method')
    
class Extender(Super):
    def method(self):
        print('starting Extender.method')
        Super.method(self)
        print('Ending Extender.method')

class Provider(Super):
    def action(self):
        print('in Provider.action')

if __name__ == '__main__':
    for klass in (Inheritor, Replacer, Extender):
        print('\n' + klass.__name__ + '...')
        klass().method()
        print('\nProvider ...')
        x = Provider()
        x.delegate()
        # Provider 调用 delegate方法时，由两个独立的继承搜索发生：
        # 1.在x.delegate调用中，python会搜索provider实例和它上层的对象，知道在super中找到
        # delegate方法，实例会传递给该方法self参数
        # 2.在super.delegate方法中，self.action会对self以及它上层的对象启动搜索，因为self
        # 指的是provider实例，在provider子类中就会找到action方法
>>>
Inheritor...
in Super.method

Provider ...
in Provider.action

Replacer...
in Replacer.method

Provider ...
in Provider.action

Extender...
starting Extender.method
in Super.method
Ending Extender.method

Provider ...
in Provider.action
```

#### 抽象超类

```python
Provider 调用 delegate方法时，由两个独立的继承搜索发生：
1.在x.delegate调用中，python会搜索provider实例和它上层的对象，知道在super中找到
delegate方法，实例会传递给该方法self参数
2.在super.delegate方法中，self.action会对self以及它上层的对象启动搜索，因为self
指的是provider实例，在provider子类中就会找到action方法
```

这种‘填空’ 的代码结构一般就是OOP的软件框架

从delegage的角度，这个例子中的超类也称作是抽象超类——==类的部分默认行为由其子类提供==（如果预期的方法没有在子类中定义，当继承搜索失败时，会引发未定义变量名异常）

#### 命名空间

- 无点号运算的变量名与作用阈相对应
- 点号的属性名使用的是对象的命名空间
- 有些作用域会对对象的命名空间进行初始化

##### 简单变量名:如果赋值就不是全局变量

赋值语句使变量成为本地变量，在当前作用域内创建或改变变量名X，除非声明它是全局变量

引用：先在当前作用域搜索变量名，之后是在所有的嵌套函数中搜索，然后是在当前的全局作用域中搜索，最后在内置的作用域搜索

##### 属性名称：对象命名空间

点号的属性名指的是特定对象的属性，并且遵循模块和类的规则

赋值语句，在进行点号运算的对象的命名空间创建或修改属性，继承树的搜索只发生在属性引用时，而不是属性的赋值运算时

引用：使用继承搜索流程

##### 命名空间的”禅“，赋值将变量名分类

赋值变量的场所决定了变量名所在的作用域或对象

```python
# global name/attribute
x = 11
def f():
    # access global x
    print(x)
def g():
    # local variable
    x = 22
    print(x)
class C:
    # class attribute
    x = 33
    def m(self):
        # local variable in method
        x = 44
        # instance attribute
        self.x = 55

if __name__ == '__main__':
    print(x)
    f()
    g()
    print(x)

    obj = C()
    print(obj.x)

    # obj.m()
    print(obj.x)
    print(C.x)

'''
11
11
22
11
33
33
33
'''
```

可以通过类来读取其属性，但无法从def语句外读取函数或方法内的局部变量，局部变量对def内的其余代码可见，只有当函数调用或执行时，才会存在于内存中

##### 命名空间字典

模块的命名空间是以字典的形式实现的，并且可以由内置属性`__dict__`显示着一点

属性点号运算内部是字典的索引运算，而属性继承就是搜索连接的字典而已

实例和类对象就是带有连接的字典而已，python暴露这些字典，还有字典间的链接，以便在高级角色中使用

```python
class super:
    def hello(self):
        self.data1 = 'spam'
        
class sub(super):
    def hola(self):
        self.data2 = 'eggs'

x = sub()
x.__dict__
>>>{}
# __class__功能和type()函数一样，都是查看对象所在的类
x.__class__
>>>__main__.sub
__class__功能和type()函数一样，都是查看对象所在的类sub.__bases__
>>>(__main__.super,)
super.__bases__
>>>(object,)
```

属性会位于实例的属性命名空间内，而不是类的，实例对象的命名空间保存了数据，随实例的不同而不同

==self是进入命名空间的钩子==

```python
y = sub()
x.hello()
x.__dict__
>>>
{'data1': 'spam'}
x.hola()
x.__dict__
>>>{'data1': 'spam', 'data2': 'eggs'}
sub.__dict__.keys()
>>>dict_keys(['__module__', 'hola', '__doc__'])
super.__dict__.keys()
>>>dict_keys(['__module__', 'hello', '__dict__', '__weakref__', '__doc__'])
y.__dict__
>>>{}
```

每个实例都有独立的命名空间字典，一开始是空的，可以记录于同一个类的其他实例命名空间字典完全不同的属性

属性实际上是python的字典键，所以有两种方式对其读取和赋值：==通过点号运算或者通过键索引运算==

```python 
x.data1,x.__dict__['data1']
>>>('spam', 'spam')
x.data3 = 'toast'
x.__dict__
>>>{'data1': 'spam', 'data2': 'eggs', 'data3': 'toast'}
x.__dict__['data3'] = 'ham'
x.__dict__
>>>{'data1': 'spam', 'data2': 'eggs', 'data3': 'ham'}
```

这种等效关系只适用于附加在实例上的属性

属性点号可以存取命名空间字典索引无法读取的属性，例如继承属性 x.hello 无法由`x.__dict__['hello']`读取

###### dir能用在任何带有属性的对象上

dir(object) 类似于 `object__dict__.keys()`调用，dir会排序其列表并引入一些系统属性，python3中包含了从所有类的隐含超类继承的名称

```python
list(x.__dict__.keys())
>>>['data1', 'data2', 'data3']
dir(x)
>>>['__class__',
......
 '__weakref__',
 'data1',
 'data2',
 'data3',
 'hello',
 'hola']
```

##### 命名空间链接

`__class__ 和 __bases__`可以在程序代码内查看继承层次，可以使用他们来显示类树

`__name__` 在自己用时就是 main，当自己作为模块被调用时就是自己的名字

`__bases__`列出其基类

`__class__`功能和type()函数一样，都是查看对象所在的类

```python
'''
Climb inheritance trees using namespace links,
displaying higher superclasses with indentation
'''

def classtree(cls, indent):
    print('.' * indent + cls.__name__)
    # 遍历类的基类
    for supercls in cls.__bases__:
        classtree(supercls, indent + 3)

def instancetree(inst):
    print('Tree of %s' % inst)
    classtree(inst.__class__, 3)

def selftest():
    class A:        pass
    class B(A):     pass
    class C(A):     pass
    class D(B,C):   pass
    class E:        pass
    class F(D,E):   pass
    instancetree(B())
    instancetree(F())

if __name__ == '__main__':
    selftest()

'''
Tree of <__main__.selftest.<locals>.B object at 0x000001D27B3D5B70>
...B
......A
.........object
Tree of <__main__.selftest.<locals>.F object at 0x000001D27B3D5B70>
...F
......D
.........B
............A
...............object
.........C
............A
...............object
......E
.........object
'''
```

##### 文档字符串

文档字符串是出现在各种结构的顶部的字符串常量，在`__doc__`属性自动保存，适用于模块文件，函数定义，以及类和方法

```python
# docstr.py
'I am: docstr.__doc__'

def func(args):
    'I am: docstr.func.__doc__'
    pass
class spam:
    'I am: spam.__doc__ or docstr.spam.__doc__'
    def method(self, args):
        'I am: spam.method.__doc__ or self.method.__doc__'
        pass
```

```pyton
import docstr

>>> docstr.__doc__
'I am: docstr.__doc__'
>>> docstr.func.__doc__
'I am: docstr.func.__doc__'
>>> docstr.spam.__doc__
'I am: spam.__doc__ or docstr.spam.__doc__'
>>> docstr.spam.method.__doc__
'I am: spam.method.__doc__ or self.method.__doc__'
```

文档字符串在运行时可用，语法上比 # 号注释缺乏灵活性

- 针对功能性文档（对象做什么）使用文档字符串
- 对更加微观的文档，使用 # 注释

#### 类与模块的关系

模块

- 是数据/逻辑包
- 通过编写python文件或c扩展来创建
- 通过导入来使用

类

- 实现新的对象
- 由class语句创建
- 通过调用使用
- 位于一个模块中

#### 小结

- 抽象类是会调用方法的类，没有继承或定义该方法，而是期待该方法由子类填补，当行为无法预测，得等到更为具体的子类编写时才知道，通常可以使用这种方式把类通用化，

- 简单语句（x = y）出现在类语句顶端时，会把数据属性附加在这个类上（class.x）,会由所有的实例共享

- 当类定义自己的`__init__`函数，但也必须启用超类构建其代码，就必须手动调用超类的`__init__`方法，python只会自动执行一个构造函数（树中最低的那个），超类的构造函数是通过类名称来调用，手动传入self实例 ：`superclass.__init__(self, ...)`

- 要增强继承的方法而不是完全替代，还得在子类中重新定义，但要从子类的新版方法中手动回调超类版本的方法，也就是把self实例手动传给超类的这个方法：`superclass.method(self,...)`

- self 代表类的实例，self 在定义类的方法时是必须有的,类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的**第一个参数名称**

- python内置类属性

  ```
  __dict__ : 类的属性（包含一个字典，由类的数据属性组成）
  __doc__ :类的文档字符串
  __name__: 类名
  __module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）
  __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）
  ```

  

### 第二十九章_运算符重载

#### 基础知识

实际上__运算符重载__只是意味着在类方法中__拦截__内置的操作,当类实例出现在内置操作中，python会自动调用你的方法，并且你的方法的返回值变成了相应操作的结果

- 运算符重载让类拦截常规的python运算
- 类可以重载所有的python表达式运算符
- 类可以重载打印，函数调用，属性点号运算等内置运算
- 重载使类实例的行为像内置类型
- 重载是通过提供特殊名称的类方法实现的

当类中提供了某个特殊名称的方法，在该类出现在他们相关的表达式时，python会自动调用他们

##### 常见运算符重载

| 方法         | 重载     | 调用                     |
| ------------ | -------- | ------------------------ |
| \_\_init\_\_ | 构造函数 | 对象建立：X= Class(args) |
| _\_del\_\_   | 析构函数 | x对象回收,在对象销毁的时候被调用，当对象不再被使用时，__del__方法运行 |
| _\_add\_\_  |  运算+ |                          |
| _\_or\_\_ | 运算符 \|（位 or） |                          |
| _\_repr\_\_,_\_str\_\_ | 打印、转换 | print(x),repr(x),str(x) |
| _\_call\_\_ | 函数调用 | x(*args, **kargs) |
| _\_getattr\_\_ | 点号运算 | x.undefined |
| _\_setattr\_\_ | 属性赋值 | x.any = value |
| _\_delattr\_\_ | 属性删除 | del x.any |
| _\_getattribute\_\_ | 属性获取 | x.any |
| _\_getitem\_\_ | 索引运算 | x[key],x[i:j],没\_\_iter\_\_时的for循环和其他迭代器 |
| _\_setitem\_\_ | 索引赋值 |                          |
| _\_deltitem\_\_ | 索引和分片删除 | del x[key], del x[i:j] |
| _\_len\_\_ | 长度 | len(x),,如果没有\_\_bool\_\_,真值测试 |
| _\_bool\_\_ | 布尔测试 | boo(x) |
| _\_lt\_\_,_\_gt\_\_ | 比较 | x<y,x>y |
| _\_le\_\_,_\_ge\_\_ | 比较 | x<=y ,x>=y |
| _\_eq\_\_,_\_ne\_\_ | 比较 | x == y, x!= y |
| _\_radd\_\_ | 右侧加法 | other + x |
| _\_iadd\_\_ | 增强的加法 | x +=y |
| _\_iter\_\_,_\_next\_\_ | 迭代环境 | I = iter(x), next(I), for loops, |
| _\_contains\_\_ | 成员关系测试 |                          |
| _\_index\_\_ | 整数值 | hex(x), bin(x), oct(x), O(x) |
| _\_enter\_\_,\_\_exit\_\_ | 环境管理，详33章 |                          |
| _\_get\_\_,\_\_set\_\_ | 描述符属性 | x.attr, x.attr = value, del x.attr |
| _\_delete\_\_ | 描述符属性 |                          |
| _\_new\_\_ | 描述符属性 | 在 \_\_init\_\_之前创建对象 |

所有重载方法名称前后都有下划线字符，以便区分变量

特殊方法名称和表达式或运算有映射关系，用python语言预定于好

pg746

















































### 第三十章_类的设计

#### python和OOP

oop的实现可以概括为三个概念：

- 继承

  基于python的属性查找

- 多态

  x.method方法中，method的具体意义取决于x的类型

  是由于python没有类型申明而出现的，属性总是在运行期解析

- 封装

  方法和运算法实现行为，数据隐藏默认是一种惯例

  在python中打包，实现细节隐藏在接口之后，

#### OOP和继承：“是一个”关系

继承是由属性点号运算启动，继承是一种定义集合成员关系的方式

```python
class Employee:
    def __init__(self, name, salary=0):
        self.name = name
        self.salary = salary
    def giveRaise(self, percent):
        self.salary = self.salary * (1  +percent)
    def work(self):
        print(self.name, 'does stuff')
    def __repr__(self):
        return "<Employee: name=%s, salary=%s>" % (self.name, self.salary)

class Chef(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 50000)
    def work(self):
        print(self.name, 'makes food')

class Server(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 40000)
    def work(self):
        print(self.name, 'interfaces with customer')

class PizzaRobot(Chef):
    def __init__(self, name):
        Chef.__init__(self, name)
    def work(self):
        print(self.name, 'makes pizza')

if __name__ == '__main__':
    bob = PizzaRobot('bob')
    print(bob)
    bob.work()
    bob.giveRaise(0.2)
    print(bob)

    for klass in Employee, Chef, Server, PizzaRobot:
        obj = klass(klass.__name__)
        # obj.work()
        print(obj)
        print('---')
```

#### OOP和组合：”有一个“关系

==组合==就是指内嵌对象集合体，反应各组成部分之间的关系

组合涉及把其他对象嵌入容器对象中，并使其实现容器方法

```python
from employee import PizzaRobot, Server

class Customer:
    def __init__(self, name):
        self.name = name
    def order(self, server):
        print(self.name, 'orders from', server)
    def pay(self, server):
        print(self.name, 'pays for item to', server)

class Oven:
    def bake(self):
        print('oven bakes')

# 是容器和控制器
class PizzShop:
    def __init__(self):
        # 构造函数将导入的类实例化并将其嵌入
        self.server = Server('Pat')
        self.chef = PizzaRobot('Bob')
        self.oven = Oven()
    
    def order(self, name):
        customer = Customer(name)
        customer.order(self.server)
        self.chef.work()
        self.oven.bake()
        customer.pay(self.server)

if __name__ == '__main__':
    scene = PizzShop()
    scene.order('Homer')
    print('...')
    scene.order('shaggy')
```

组合与继承是互补的工具，简单来说把对象实例化放到一个新的类里面叫做类的组合，==组合指几个横向关系的类放在一起==，==纵向关系的类放在一起是继承==，根据场景确定，组合用于‘有一个’的场景，继承用于‘是一个’的场景

> 例如：
>
> 城市里有高楼，家里有家具，这类适合用组合
>
> ‘华为荣耀’是手机，oppo是手机，这类适合用继承

##### 重访流处理器

```python
class Processor:
    def __init__(self, reader, writer):
        self.reader = reader
        self.writer = writer
    def process(self):
        while 1:
            data = self.reader.readline()
            if not data: break
            data = self.converter(data)
            self.writer.write(data)
    def converter(self, data):
        assert False,'converter must be defined'
```

类定义了一个转换器方法，期待子类来填充，读取器和写入器内嵌在类示例当中（组合）,我们是在子类内提供转换器的逻辑，而不是传入一个转换器（继承）

定义一个转换器,可以传入包装在类中的任何对象

```python
from streams import Processor

class Uppercase(Processor):
    # 继承并重写converter方法
    def converter(self, data):
        return data.upper()

# 定义一个writer
class HTMLize:
    def write(self, line):
        print('<PRE>%s</PRE>' % line.rstrip())

if __name__ == '__main__':
    import sys

    obj = Uppercase(open('spam.txt'), sys.stdout)
    obj.process()
    Uppercase(open('spam.txt'), HTMLize()).process()
```

#### OOP和委托：“包装”对象

委托：通常就是指控制器对象内嵌其它对象，而把运算请求传给那些对象

委托通常是以`__getattr__`钩子方法实现的，因为这个方法会拦截对不存在属性的读取，包装类可以使用`__getattr__`把任意读取转发给被包装对象

```python
class wrapper:
    def __init__(self, object):
        # object 是所有类的基类
        self.wrapped = object
    def __getattr__(self, attrname):
        print('Trace', attrname)
        print(attrname)
        return getattr(self.wrapped, attrname)

'''
>>> from delegation import wrapper
>>> x = wrapper([1,2,3])
>>> x.append(4)
Trace append
append
'''
```

可以使用这个模块包装类的做法，管理任何带有属性的对象的存取：列表，字典甚至类和实例

wrapper类只是在每个属性读取时打印跟踪消息，并把属性请求委托给嵌入的wrapped对象

#### 类的伪私有属性

每个模块文件顶层赋值的变量都会导出，默认情况下，类也是这样，数据隐藏是一个惯例，客户端可以读取或修改任何他们想要的类或实例的属性。

python支持变量名压缩的概念，让类内的某些变量局部化，压缩后的变量名有时会被认为是‘私有属性’，其实是一种把类所创建的变量名局部化的方式而已：名称压缩无法阻止类外代码对它的读取

主要是为了避免实例内的命名空间冲突，而不限制变量名的读取，压缩的变量名最好称为‘伪私有’，而不是“私有”

伪私有变量名是高级且完全可选的功能，多人大项目中作用突出

python程序员用一个单个的下划线来编写内部名称（\_X）,这是非正式的惯例，让你知道这是一个不应该修改的名字。

##### 变量名压缩概览

- class语句内开头有两个下划线，但结尾没有两个下划线的变量名，会自动扩张，从而包含了所在类的名称

  > 如： Spam内 ==\_\_X== 这样的变量名会自动变成   ==\_Spam\_\_X==
  >
  > 原始变量名前面会加上一个下划线和类名称，相当于变得独特，不会和同一层次中其他类创建的变量名类似变量名冲突

- 变量名压缩只发生在class语句内，只针对开头有两个下划线的变量名。

  每个开头有两个下划线的变量名都会发生这件事，包括方法名称和实例属性名称

  > 例如： 在Spam内，引用的self.\_\_X实例属性会变成 self.\_Spam\_\_X
  >
  > 不止有一个类在给实例新增属性，所以这种方法有助于避免变量冲突

##### 为什么使用伪私有属性

python类方法中，当方法赋值self属性时（ self.attr = value）,就会子在该实例内修改或创建该属性（继承搜索只发生在引用时，而不是赋值时）。在类层次中有多个类赋值相同的属性，也是如此，可能发生冲突



```python
# __例1__：假设一个程序员编写一个类，他认为属性名称X是在该实例中，在类的方法中，变量被设定，然后取出
class C1:
    def meth1(self): self.X = 88             # I assume X is Mine
    def meth2(self): print(self.X)
# __例2__: 另一个程序员独立作业，他对类也有同样的假设
class C2:
    def metha(self): self.X = 99             # Me too
    def methb(self): print(self.X)
# 这两个类各行其事，当混合在相同类树中，问题就出现了
class C3(C1, C2):
    pass
I = C3()                                     # only 1X in I
```

为了保证属性会属于它的类，可以在类的任何地方使用，在变量前面加两个下划线

```python
class C1:
    def meth1(self): self.__X = 88
    def meth2(self): print(self.__X)
class C2:
    def metha(self): self.__X = 99
    def methb(self): print(self.__X)
class C3(C1, C2): pass

I = C3()
print(I.__dict__)
I.meth1(); I.meth2()
print(I.__dict__)
I.metha(); I.methb()
print(I.__dict__)

'''
{}
88
{'_C1__X': 88}
99
{'_C1__X': 88, '_C2__X': 99}
'''
# 继承类实例化后变量才会进入主类的变量中
```

加了双下划线前缀，属性会扩张从而包含它的类名称，让变量在实例内变得独特

在较大的框架中，既可以避免引入可能在类树中某处偶然隐藏定义的方法名，也可以减少内部方法在被树的低处定义名称替代的机会。==如果一个方法倾向于只在一个可能混合到其他类的类中使用，在前面使用双下划线，以确保该方法不受到树种其他名称的干扰，特别是多继承环境

只有当单个类真的需要控制某些变量时才使用这个功能

#### 方法是对象：绑定或无绑定

方法也是一种对象，可以用与其他对象大部分相同的方式来使用——赋值，传递给函数，存储在数据结构等，

由于方法可以从一个实例或一个类种访问，实际上有两种形式：

- 无绑定类方法对象：无self

  通过对类进行==点号运算==从而获得类的函数属性，会传回无绑定的（unbound）方法对象。调用该方法时必须明确提供实例对象作为第一个参数。python3中无绑定方法和简单的函数相同，可以通过类名来调用

- 绑定类方法对象：self + 函数对

  通过对==实例进行全运算==从而获取类的函数属性，会传回绑定（bound）方法对象。python在绑定方法对象中自动把实例和函数打包，所以不用传递实例取调用该方法

这两种方法都是功能齐全的对象，可四处传递，就像字符串和数字。执行时，两者都需要他们在第一参数中的实例（也就是self的值）。

```python
class Spam:
    def doit(self, message):
        print(message)
object1 = Spam()
object1.doit('hello world')
# 绑定方法对象是在过程中产生的，就在方法调用的括号前
# 可以获取绑定方法而不进行实际的调用
# object.name 点号运算是一个对象表达式
# 创建实例
object2 = Spam()
x = object2.doit        # 绑定方法对象，将其赋值给另外一个变量，就可以像函数一样进行调用
x('hello world')

# 如果对类(不带括号)进行点号运算获得方法，会得到无绑定方法对象，调用这类方法，必须传入实例作为左侧参数
object3 = Spam()
t = Spam.doit          #对类进行点号运算——无绑定方法对象
t(object3, 'hello world')
```

如果我们引用的self的属性是引用类中的函数，以上相同规则也适用于类方法，self.method是绑定方法对象，self是实例对象

```python
class Eggs:
    def m1(self, n):
        print(n)
    def m2(self):
        x = self.m1     # 绑定方法对象
        x(42)
Eggs().m2()
```

==无绑定方法一般需要传入明确的实例对象==

##### 在python3中，无绑定方法(无self)是函数

只有对通过实例调用，python才会向方法传递一个实例，当通过一个类调用的时候，只有在方法期待一个实例的时候，才必须手动传递一个实例

python3中没有self参数的方法，，不会接受一个实例参数。

```python
class Selfless:
    def __init__(self, data):
        self.data = data
    def selfless(arg1, arg2):
        return arg1 + arg2
    def normal(self, arg1, arg2):
        return self.data + arg1 + arg2

X = Selfless(2)
print(X.normal(3,4))
> 9
# 常规调用
print(Selfless.normal(X, 3, 4))
> 9
# 无绑定调用
print(Selfless.selfless(3,4))
> 7

# 实例调用非绑定方法会报错
# X.selfless(3,4)
# 类调用绑定方法不传实例会报错，
# Selfless.normal(3,4)
```

##### 绑定方法和其他可调用对象

绑定方法可以作为一个通用对象处理，可以任意在一个程序中传递，可以像任何可调用对象对待

```python
class Number:
    def __init__(self, base):
        self.base = base
    def double(self):
        return self.base * 2
    def triple(self):
        return self.base * 3
x = Number(2)
y = Number(3)
z = Number(4)
# 调用绑定对象
print(x.double(), y.double(), y.triple(), z.double())
#  4 6 9 8
```

绑定方法有自己的内省信息，包括配对的实例对象和方法函数访问的属性。

```python
bound = x.double
print(bound.__self__, bound.__func__)
print(bound.__self__.base)
# <__main__.Number object at 0x00000158466FE588> <function Number.double at 0x00000158466C6828>
# 2
```

绑定方法只是python众多可调用对象中的一种，简单函数编写为一个def或lambda,实例继承一个\_\_call\_\_,绑定实例方法都能以相同的方式调用：

```python
def square(arg):
    return arg ** 2

class Sum:
    def __init__(self, val):
        self.val = val
        # 类中定义__call__方法可以让实例变成一个可调用函数
    def __call__(self, arg):
        return self.val + arg
class Product:
    def __init__(self, val):
        self.val = val
    def method(self, arg):
        return self.val * arg 
   
sobj = Sum(2)
pobj = Product(3)
actions = [square, sobj, pobj.method]
for act in actions:
    print(act(5))
```

##### 为何要关注：绑定方法和回调函数

绑定方法自动让实例和类方法函数配对，可以在任何希望得到简单函数的地方使用。最常见的调用就是把方法注册成tkinterGUI 接口中事件回调处理器的代码

```python
def handler():
    '''use global for state'''
    
widget = Button(text='spam', command=handler)
```

为按钮点击事件注册一个处理器，通常是将一个不带参数的可调用对象传递给command关键字。函数名和lambda都可以使用，类的绑定方法也可以。

```python
class Mywidget:
    def handler(self):
        '''use global for state'''
    def makewidgets(self):
        b = Button(text='spam', command=self.handler)
```

#### 多重继承：混合类

class语句中，首行括号内可以列出一个以上的超类，这样就是在使用多重继承，类和其实例继承了所有超类的变量名

搜说属性时，python会由左至右搜索类首行中的超类。对于更大的类树，搜索更复杂

- 传统类（默认的类，直到python3.0）中，属性搜索对所有路径深度优先，然后从左到右
- 新式类（以及python3.0的所有类中）中，属性搜索沿着层级广度优先

当一个类拥有多个超类的时候，他们会根据class语句头部行中列出的顺序从左到右查找，使用多重继承，对象获得了所有超类中行为的组合

##### 编写混合显示类

可以提供一个\_\_str\_\_or \_\_repr\_\_,以实现制定后的字符串表达形式。可以在一个通用类中编写一次，其他需要的类继承即可

编码一组3个混合类，这三个类充当通用的显示工具，可以列出类树上所有对象的实例属性、继承属性和属性

##### _\_dict\_\_列出实例属性

```python
# 每个实例都有一个__class__属性，用来引用创建自己的类，
# 每个类都有__name__属性，引用了头部的名称
# 表达式 self.__class__.__name__ 获取实例类的名称
```

- id（Instance）获取实例的内存地址，id()返回任何对象的地址
- 伪私有命名模式：为了保证不能在class之外访问私有变量,Python会在类的内部自动的把我们定义的\_\_spam私有变量的名字替换成为==_classname\_\_spam==  (注意,classname前面是一个下划线,spam前是两个下划线)

```python
# lister.py
class ListInstance:
    """
    Mix-in class that provides a formatted print() or str() of
    instances via inheritance of __str__, coded here; displays
    instance attrs only; self is the instance of lowest class;
    use __X names to avoid clashing with client's attrs
    """
    def __str__(self):
        # 所有派生自该类的实例在打印的时候会调用该方法
        return 'Instance of %s, address %s:\n%s' %(
            self.__class__.__name__,
            id(self),
            self.__attrnames()
        )
    def __attrnames(self):
        result = ''
        for attr in sorted(self.__dict__):
            result += '\tname %s=%s\n' %(attr, self.__dict__[attr])
        return result
```

```python
if __name__ == '__main__':
    class Spam(ListInstance):
        def __init__(self):
                self.data1 = 'food'
    x = Spam()
    print(x)
    # 获取输出为字符串显示
    print(repr(str(x)))
```

ListInstance对于任何类都有用，即使类已经有多个超类，这就是多继承的用武之地

```python
from lister import *

class Super:
    def __init__(self):
        self.data1 = 'spam'
    def ham(self):
        pass

class Sub(Super, ListInstance):
    def __init__(self):
        Super.__init__(self)
        self.data2 = 'eggs'
        self.data3 = 42
    def spam(self):
        pass

if __name__ == '__main__':
    X = Sub()
    print(X)
>>>
Instance of Sub, address 2597402912776:
        name data1=spam
        name data2=eggs
        name data3=42
```

LIstInstance在它混入的任何类中都有效，因为self引用拉入了这个类的子类的一个实例。

混合类是模块的类等价形式——在各种客户中都有用的方法包

对于类继承类之外的属性设置也起作用

```python
import lister
class C(lister.ListInstance):
    pass
x = C()
x.a = 1
x.b = 2
x.c = 3
print(x)
>>>
Instance of C, address 2296491508616:
        name a=1
        name b=2
        name c=3
```

##### 使用dir列出继承的属性

python3中更多的属性显示出来，因为所有的类是新式的，并从隐式的object那里继承了名称

- **dir()** 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息

- 使用**getattr**内置函数获取属性

  返回对象属性名对应的值

  - ```
    getattr(object, name[, default])
    ```

```python
class ListInherited:
    def __str__(self):
        return '<instance of %s , address %s:\n%s>' %(
            self.__class__.__name__,
            id(self),
            self.__attrenames()
        )
    def __attrenames(self):
        results = ''
        for attr in dir(self):
            if attr[:2] == '__' and attr[-2:] == '__':
                results += '\tname %s=<>\n' % attr
            else:
                results += '\tname %s=%s\n' %(attr, getattr(self, attr))
        return results
```



### 第三十一章_类的高级主题

- 对于python3,所有的类都是“新式类”，所有的类都是继承自object, 所有对象是object的实例

- 新式类的特性是常规的类特性

- 类就是类型，二者同义

- `type(I)`返回实例所创建自的类，通常和`.__class__`相同

- 类实例的类型是它所产生自的类，类的类型是type类

- 实例和类都是派生自内置的object

- 每个类都有一个隐式或显式的超类

- 类型派生自object, object派生自type ,类型是生成类的类

  ```
  >>> isinstance(object,type)
  True
  >>> isinstance(type,object)
  True
  >>> type(type)
  <class 'type'>
  >>> type(object)
  <class 'type'>
  ```

- ​	`__getattribute__`方法只适用于新式类，可以让类拦截所有属性的引用，而不局限于未定义的引用

  #### 元类

  类是类型，类型是类

  元类是子类化了type对象并且拦截类创建调用的类

  #### 静态方法和类方法

  类方法传递类而不是实例

  要调用需使用内置函数 staticmethod 和 classmethod

  python3中无实例的方法只通过类名调用，不需要使用staticmethod声明

  ##### 为什么使用特殊方法

  - 类方法通常在其第一个参数中传递一个实例对象，以充当方法调用的一个隐式主体

  > 有时候程序需要处理与类而不是与实例相关的数据（考虑记录由一个类创建的实例的数目），这种信息通常存储在类自身上，不需要任何实例也可处理

  python通过静态方法来支持这样的目标——嵌套在类中的没有self参数的简单函数，并且旨在操作类属性而不是实例属性，静态方法不会接受一个自动的self参数，不管是通过一个类还是实例调用

  python3中只有当一个方法期待实例的时候，我们才给他传入一个实例，没有self实例参数的方法可以通过类调用而不需要传入一个实例

  ==python3中，如果一个方法只通过类调用，我们不需要将这样的方法声明为静态的，但是要通过实例来调用，必须这么做==

  > python 2中，类的无绑定实例方法不完全等同于简单的函数，该方法以然期待一个实例
  >
  > python3中，对无self方法的调用，类调用有效，实例调用失效
  >
  > - 因为实例会自动传给方法，而方法没有参数来接受它

  ##### 静态方法替代方案

  ```python
def printNumInstances():
      print('Number of instance created: ', Spam.numInstances)
  
  class Spam:
      numInstances = 0
      def __init__(self):
          Spam.numInstances += 1
  
  if __name__ == '__main__':
      a = Spam()
      b = Spam()
      c = Spam()
      print(printNumInstances())
      print(printNumInstances())
  >>>
  Number of instance created:  3
  None
  Number of instance created:  3
  None
  ```
  
  类名称对简单函数而言是可读取的全局变量，在以上单个模块中，函数名也是全局变量
  
  模块是命名空间分隔工具，通常不需要把函数放到类中，除非它实现了对象行为
  
  以上案例的缺点：
  
  > - 给文件作用域增加了一个额外名称
  > - 函数与类的关系小，不能通过继承定制，子类不能通过重新定义这样的函数来扩展它
  
  ```python
  # 升级版本
  class Spam:
      numInstances = 0
      def __init__(self):
          Spam.numInstances += 1
      def printNumInstances(self):
          print(f'{Spam.numInstances}')
  
  a, b, c = Spam(), Spam(), Spam()
  a.printNumInstances()
  print(Spam.numInstances)
  print(Spam().printNumInstances())
  
  >>>
  3
  3
  4
  None
  ```
  
  最后一行类的实例调用改变了计数，下面我们使用静态方法把类中的一个方法标记为不需要实例
  
  ##### 使用静态方法和类方法
  
  python支持三种类相关的方法：实例，静态和类
  
  实例方法一定要用实例对象调用，通过实例调用时，python会把实例自动传给第一个参数，类调用时需要手动传入实例
  
  ```python
  class Methods:
      def imeth(self,x):
          print(self, x)
      def smeth(x):
          print(x)
      def cmeth(cls,x):
          print(cls, x)
      smeth = staticmethod(smeth)
      cmeth = classmethod(cmeth)
  # make an instance
  obj = Methods()
  
  # 常规实例调用方式,第一个参数自动传入
  obj.imeth(1)
  # 等价方法，类调用，手动传入实例参数
  Methods.imeth(obj, 2)
  
  # 静态方法
  Methods.smeth(3)
  obj.smeth(4)
  
  # # 类方法
  Methods.cmeth(4)
  obj.cmeth(5)
  ```
  
  
  
  
  
  















































## 第七章_异常和工具

### 第三十二章_异常基础

### 第三十三章_异常编码细节

### 第三十四章_异常对象

### 第三十五章_异常的设计


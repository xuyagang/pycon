[TOC]

# 《Python学习手册》

本书覆盖python3.0和2.6，实例中使用3.0的print,介绍2.6语法，我的练习中使用3.0语法。

每章节和每部分后面都用练习题，解答在书的附录B中。



## 第一部分_使用入门

### 第一章_Python 如何运行

#### 1.1 为什么用python

- python注重可读性、一致性和软件质量
- 提高了效率，是c++或者Java的1/5~1/3，无需编译，可立即运行
- 可在所有主流计算机平台上快速移植代码
- 内置多种预编译并可移植模块
- 可以与应用程序的其他部分通信，是产品定制和扩展的工具

#### 1.2 python可定义为面对对象的脚本语言

- 脚本：倾向描述简单的顶层代码
  - 脚本语言可以理解为应用于快速编程任务的简单语言
- 程序：描述相对复杂的多文件应用

#### 1.3 python 的缺点

- 执行速度不够快
- python标准格式-->字节码--->解释字节码
  - 字节码是一种无关平台的格式，具有可移植性
  - 因为没有将代码编译成二进制码，python程序会比像C这样的完全编译语言慢

#### 1.4 python可以做什么？

- 从网站和游戏开发到航天飞机的控制
  - 系统编程
  - 用户图形接口
    - 内置了TKinter
  - internet脚本
  - 组件集成
  - 数据库编程
  - 数值计算和科学计算
  - 游戏、图像、人工智能、XML、机器人

#### 1.5 谁在用？

- youtube视频分享服务
- EVE Online大型多人游戏
- Maya提供了python编程API
- ...



### 第二章_python如何运行程序

- 解释器是代码与机器硬件之间的软件逻辑层
  - 解释器是_让python程序运行起来的程序_
- __.pyc__文件就是编译过的__.py__文件
  - 如果python在机器上有写入权限，程序运行后会在源码同目录下看到.pyc文件
  - 如果运行后源码未修改，下次运行直接加载.pyc文件，跳过编译步骤
  - 必须重新编译时，python会检查源文件和字节码文件的时间戳
- 程序编译为字节码后会发送到python虚拟机（PVM）
  - PVM是python的运行引擎，不是程序，无需安装，是所谓“python解释器”的最后一步

![000](D:\project\pycon\Python_学习手册\img\000.PNG)

- python语言三种主要的实现方式
  - Cpython:标准的的python实现方式
  - Jython：为了与Java集成，包含了java类
    - 让python代码能够脚本化java程序
  - IronPython：让python可以与win平台上的.NET框架和Linux上开源的Mono编写成的应用集成
- 冻结二进制文件/__Frozen Binary__
  - 用python程序生成的__独立的可执行二进制代码__
  - 简单来说就是：将python程序转为可执行程序
    - Frozen Binary 将程序的字节码，PVM以及任何程序所需要的python支持文件捆绑在一起，形成一个单独的文件包---可执行二进制程序（类似win平台的 .exe文件）
- 生成方式：
  - py2exe——win下使用
  - PyInstaller——在Linux和UNIX上使用



### 第三章_如何运行程序

- 交互提示模式运行代码

  - 在for循环和if中，用一个空行结束多行符合语句，需要按下两次Enter

- python file.py             运行file文件，在命令窗口输出结果

- python file.py > result.txt     输出结果到result.txt文件中，命令窗口不显示
  - 叫做__流重定向__(stream redirection),用于文本的输入和输出，保存起来以备查看使用
  - shell重定向方法，与python无关，只是python支持而已
    - C:\Users\Dell\Desktop>python aa.py > d:\aa.txt         （在桌面运行并输出结果到d盘）

- 模块导入和重载

  - 每一个.py文件都是 一个模块，可以导入一个模块来读取模块的内容

  - 模块通过这样的属性被外部使用

  - 大型程序有多个模块文件组成，其中一个文件设计成主文件（==顶层文件==：就是启动后运行整个程序的文件）

  - 导入工作只在第一次运行，第一次导入后，之后的导入都不会再工作，甚至改变并保存了模块源代码也不行

  - 导入开销很大，每个文件和程序运行不能重复多于一次

  - 导入必须找到文件并将其编译成字节码之后运行

  - 如果非要在同一会话（不停止和重启会话）再次运行文件，需要调用imp模块中的reload函数

    - ```python
      #  the imp module is deprecated in favour of importlib
      from imp import reload
      reload(script1)
      ```

  - reload函数希望获得的参数是一个已经加载了的模块对象名称

  - reload需要加括号，import 不需要（reload是被调用的函数，import是语句）

- 模块的属性

  - 模块是变量名的封装，被认为是命名空间，包中的变量就是所谓的属性

  - 属性就是绑定在特定对象（比如模块）上的变量名

  - 模块变量名可通过一下语句读取：

    - import
    - from
    - reload调用

  - ```python
    # 我们已有文件test.py
    	# 内容：content = ‘The Meaning of Life'
    # 方式一：grab the whole module
    import test
    test.content
    # 方式二：copy myltiple names
    from test import content
    content
    ```

  - 以上结果相同，from和import类似，from增加了对载入组件的额外赋值（content=test.content）

    - 使用from会获取文件变量的==复本==,可使用__dir()__函数查看
    - 使用import会把文件生成到一个单独的模块名称空间中，所付出的代价就是代码修改后运行需要__重载__

  - 每个模块是一个独立完备的变量包，即一个命名空间，一个模块看不到其他文件的变量名（除非显示的导入），模块在代码文件中起到了==最小化命名冲突==的作用

  - from把变量从一个文件复制到另外文件中，可能会导致相同名称的变量被覆盖（不会给出警告）

  - reload 不可传递，重载一个模块不会重载该模块导入的任何模块，因此有时需要reload多个文件

- 使用exec()运行模块文件

  - ```python
    exec(open('test.py').read())
    ```

- IDLE用户界面

  - 提供了python开发的图形界面，是使用TKinter GUI开发出来，可以在几乎任何python平台使用。

- 嵌入式调用

  - 在一些特定的领域，python代码会在一个封闭的系统中运行
  - 这样的嵌入式执行模式一般支持终端用户定制，用户可修改python代码（==python代码是解释性的，不必重新编译==）

- 总结：

  - 在系统平台终端命令行的地方运行一个脚本文件，也可通过导入、重载、exec()、IDLE的run等运行脚本



## 第二部分_类型和运算

### 第四章_python对象类型

python程序：==程序==由模块组成，==模块==包含语句，==语句==包含表达式，==表达==式建立并处理对象

#### 4.1 为什么使用内置类型

- 内置类型使程序容易编写
- 内置类型是扩展的组件
- 内置比定制的更有效率
- 内置对象是语言标准的一部分

#### 4.2 核心数据类型

- 数字
- 字符串
- 列表
- 元组
- 字典
- 集合
- 文件
- 其他：None、Bool
- 编程单元：函数、模块、类

以上并不完整，python章每样东西都是一种对象

- python中没有类型声明，运行表达式的语法决定了对象的类型，对象一旦创建就和操作集合绑定了（对字符串只可进行字符串相关操作）
  - 动态语言：自动跟踪类型而不是要求声明
  - 强类型语言：只能对一个对象进行适合该类型的语言
- 寻求帮助：
  - dir()
  - help()

___

- python核心数据名称：数字，字符串，列表，元祖，姐，字典，文件，
  - 多种数字类型：整数，浮点，复数，分数，十进制数
  - “核心”是因为他们是python语言的一部分，大多数都有特定的语法去生成他们，
- 一个具有不可变性的对象是一个__创建后不能够改变的对象__，python中的__数字、字符串和元祖__属于这个分类，尽管无法就地改变，但总可以通过运行一个表达式创建一个 新的对象
- 一个__序列__是一个_对位置进行排序的对象的集合_,字符串、列表、元祖是python中的所有的序列，他们拥有一般的序列操作（索引、切片、合并），但又有自己类型的特定方法
- __映射__表示将键和相关值相互关联的对象，字典是核心类型中唯一的映射类型。映射没有从左至右的位置顺序，支持通过键获取数据，并包含了特定的方法
- __多态__是指一个操作符（如 +）的意义取决于被操作的对象，这是python的关键思想：==不要把代码限制在特定的类型上，是代码自动适用于多种类型==



### 第五章_数字

在python中数据采用了对象的形式，无论是内置对象还是用python的工具创建的对象。

- 在python中，数字并不是一个真正的对象类型，而是__一组类似类型的分类__，数字类型完整工具包括：
  - 整数和浮点数
  - 复数
  - 固定精度的十进制
  - 有理分数
  - 集合
  - 布尔类型
  - 无穷的整数精度
  - 各种内置的函数和模块

#### 5.1 数字常量

- python提供整数（正整数和负整数）和浮点数，允许使用十六进制，八进制和二进制常量表示整数，提供复数类型，允许整数具有无穷的精度
  - 十六进制：以ox或OX开头，后接16进制数0-9，A-F
  - 八进制：0o或0O，后接0-7数
  - 二进制：0b或0B开头，后接0-1
  - 整数转为对象字符串
    - hex(int)
    - oct(int)
    - bin(int）
  - 给定进制字符串转为整数
    - int(str,base)
  - 复数
    - 复数写成实部+虚部，虚部以J或j结尾
    - 也可用内置的complex(real,imag)创建复数

#### 5.2 表达式操作符

- 表达式是处理数字的基本工具，表达式通常使用_数学符号_和_操作符_写出来

- 操作符：

  - yield x                                          生成器函数发送协议
    - 返回生成器中的send(...)参数
  - lambda  args: expression         生成匿名函数
  - x if y else z                                  三元选择表达式
  - x   or  y                                         逻辑或（只有x为假，才会计算y）
  - x   and  y                                      逻辑与（只有x为真，才会计算y)
  - not  x                                            逻辑非
  - in， not  in                                   成员关系
  - is,  is not                                       对象实体测试
  - <,<=,>,>=，==，！=                     大小比较，相等性
  - x | y                                               位或，并集
  - x ^ y                                               位异或，集合对称差
  - x & y                                              位与，交集
  - x << y , x>> y                                 左移/右移y位
  - +，-，*，/                                     加减乘除
  - x % y                                              余数/格式化
  - x // y                                               floor 除法（整除）
  - -x,+x                                                一元操作
  - ~x                                                    按位取反
  - x**y                                                幂运算
  - x[i]                                                  索引
  - x[i:j:k]                                             分片
    - 等同于 x[slice(I,J,K)]
  - x(...)                                                 调用函数、方法、其他可调用类型
  - x.attr                                               属性引用
  - （...）                                              元组，表达式，生成器表达式
  - [...]                                                   列表，列表解析
  - {...}                                                   字典、集合、集合和字典解析

- 操作符优先级

  - 上表中越靠后的优先级越高
  - 比较运算和表达式通常从左到右组合，幂运算是从右到左组合
  - 如果用用括号对表达式的各部分进行分组，就可以忽略优先级的事情了
    - 使用括号划分子表达式的时候，python总是会先计算括号中的表达式，然后将结果用于整个表达式中
  - 混合类型自动升级
    - 表达式中能混合数字类型（整数和浮点数相加）
    - 混合类型中，python首先==将操作对象转换为其中最复杂的操作对象类型==，然后运算
    - python中：整数比浮点数简单，浮点数比复数简单
    - 混合操作类型仅仅在数字类型混合到一个表达式中适用

- 变量和基本表达式

  - 变量在第一次赋值时创建
  - 变量在表达式中使用将会被替换为它的值
  - 变量在表达式中使用前必须已赋值
  - 变量不需要预先声明，但要赋值一次

- 数字显示的格式

  - 由于浮点数的硬件限制，无法准确显示一些值

  - ```python
    num = 1/3
    '%e' % num		# string formatting expression
    >>> 3.333333e-01
    '%4.2f' %num
    >>> 0.33
    '0:4.2f'.format(num)
    >>> 0.33
    ```

  - str 和repr 的显示格式

    - 默认的交互模式回显和打印的区别相当于repr和str函数的区别
      - repr:产生的结果看起来像代码（__额外细节__）
      - str:用户友好模式(__一般用途__)
        - 除了为任意对象打印字符串，str内置函数也是字符串类型的名字

- 比较

  - 一般的和连续的

  - 除了正常的大小值比较，python允许我们把多个比较连续起来执行==范围测试==

    - 例：

    - ```python
      # 测试B是否在A和C之间
      A < B < C			
      # 等同于
      A < B and B < C
      
      # 第一个简单便于使用，并且B值计算一次，速度要快一些
      ```

- 除法：

  - x/y	真除法

  - x//y       整除法（floor）

    - 截断除法：真正结果之下的最近整数

  - ```python
    >>> 10//4
    2
    >>> 10//4.0
    2.0
    # 操作数中有一个是浮点数，结果就是浮点数，否则结果是整数
    ```

- 整数精度

  - python3支持整数的无穷大小，实际中，长整数的运算比正常整数慢，以性能换精度

- 复数

  - 表示为两个浮点数（实部和虚部）并在虚部增加了J/j的后缀
  - 复数允许我们分解它的是实部和虚部作为属性
  - 可通过标准的cmath模块处理

- 十六进制/八进制/二进制

  - pg167









### 第五章_数字

### 第六章_动态类型简介

### 第七章_字符串

### 第八章_列表字典

### 第九章_元祖、文件及其他

## 第三部分_语法和语句

### 第十章_python语句简介

### 第十一章_赋值、表达式和打印

### 第十二章_if测试和语法规则

### 第十三章_while和for循环

### 第十四章_迭代器和解析（第一部分）

### 第十五章_文档

## 第四部分_函数

### 第十六章_函数基础

### 第十七章_作用域

### 第十八章_参数

### 第十九章_函数的高级话题

### 第二十章_迭代和解析（第二部分）

## 第五部分_模块

### 第二十一章_模块：宏伟蓝图

### 第二十二章_模块代码编写基础

### 第二十三章_模块包

### 第二十四章_高级模块话题

## 第六部分_类和OOP

### 第二十五章_OOP:宏伟蓝图

### 第二十六章_类代码编写基础

### 第二十七章_更多实例

### 第二十八章_类代码编写细节

### 第二十九章_运算符重载

### 第三十章_类的设计

### 第三十一章_类的高级主题

## 第七章_异常和工具

### 第三十二章_异常基础

### 第三十三章_异常编码细节

### 第三十四章_异常对象

### 第三十五章_异常的设计

